
/**
 * Client
**/

import * as runtime from '../@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    Agreement: AgreementPayload<ExtArgs> | null
    Article: ArticlePayload<ExtArgs>[]
    Asked: AskedPayload<ExtArgs>[]
    AskedUser: AskedUserPayload<ExtArgs> | null
    BoardOrganizations: BoardManagerPayload<ExtArgs>[]
    Comment: CommentPayload<ExtArgs>[]
    Image: ImagePayload<ExtArgs>[]
    Like: LikePayload<ExtArgs>[]
    ReComment: ReCommentPayload<ExtArgs>[]
    SocialLogin: SocialLoginPayload<ExtArgs> | null
    UserSchool: UserSchoolPayload<ExtArgs> | null
    UserSchoolVerify: UserSchoolVerifyPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    email: string | null
    password: string | null
    name: string
    profile: string | null
    isVerified: boolean
    phone: string | null
    createdAt: Date
    provider: UserLoginProviderType
    userSchoolId: string | null
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type SchoolPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    UserSchool: UserSchoolPayload<ExtArgs>[]
    Article: ArticlePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    schoolId: string
    org: string
    x: number
    y: number
    atptCode: string
    defaultName: string
    name: string | null
    type: string
  }, ExtArgs["result"]["school"]>
  composites: {}
}

/**
 * Model School
 * 
 */
export type School = runtime.Types.DefaultSelection<SchoolPayload>
export type ImagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
    UserSchoolVerify: UserSchoolVerifyPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    key: string
    userId: string
    createdAt: Date
  }, ExtArgs["result"]["image"]>
  composites: {}
}

/**
 * Model Image
 * 
 */
export type Image = runtime.Types.DefaultSelection<ImagePayload>
export type PhoneVerifyRequestPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    phone: string
    code: string
  }, ExtArgs["result"]["phoneVerifyRequest"]>
  composites: {}
}

/**
 * Model PhoneVerifyRequest
 * 
 */
export type PhoneVerifyRequest = runtime.Types.DefaultSelection<PhoneVerifyRequestPayload>
export type SocialLoginPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    accessToken: string
    refreshToken: string | null
    userId: string
    socialId: string
    provider: SocialLoginProviderType
  }, ExtArgs["result"]["socialLogin"]>
  composites: {}
}

/**
 * Model SocialLogin
 * 
 */
export type SocialLogin = runtime.Types.DefaultSelection<SocialLoginPayload>
export type AgreementPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    updatedAt: Date
    userId: string
    receive: boolean
  }, ExtArgs["result"]["agreement"]>
  composites: {}
}

/**
 * Model Agreement
 * 
 */
export type Agreement = runtime.Types.DefaultSelection<AgreementPayload>
export type UserSchoolVerifyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    image: ImagePayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    imageId: string
    schoolId: string
    grade: string
    class: string
    message: string | null
    process: Process
    createdAt: Date
    schoolName: string
    userName: string
    dept: string
  }, ExtArgs["result"]["userSchoolVerify"]>
  composites: {}
}

/**
 * Model UserSchoolVerify
 * 
 */
export type UserSchoolVerify = runtime.Types.DefaultSelection<UserSchoolVerifyPayload>
export type UserSchoolPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    school: SchoolPayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    userId: string
    schoolId: string
    dept: string
    grade: string
    class: string
  }, ExtArgs["result"]["userSchool"]>
  composites: {}
}

/**
 * Model UserSchool
 * 
 */
export type UserSchool = runtime.Types.DefaultSelection<UserSchoolPayload>
export type BusStationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    busStationId: string
    busStationName: string
    address: string
    x: number
    y: number
  }, ExtArgs["result"]["busStation"]>
  composites: {}
}

/**
 * Model BusStation
 * 
 */
export type BusStation = runtime.Types.DefaultSelection<BusStationPayload>
export type BusRoutePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    busRouteId: string
    busRouteNum: string
    busRouteTp: string
    endNodeName: string
    startNodeName: string
    endVehicleTime: string
    startVehicleTime: string
    intervalTime: string
    intervalSatTime: string
    intervalSunTime: string
  }, ExtArgs["result"]["busRoute"]>
  composites: {}
}

/**
 * Model BusRoute
 * 
 */
export type BusRoute = runtime.Types.DefaultSelection<BusRoutePayload>
export type BusArrivalPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    busStationId: string
    busStationName: string
    busRouteNum: string
    busRouteTp: string
    arrprevStationCnt: string
    arrTime: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["busArrival"]>
  composites: {}
}

/**
 * Model BusArrival
 * 
 */
export type BusArrival = runtime.Types.DefaultSelection<BusArrivalPayload>
export type AskedUserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    Asked: AskedPayload<ExtArgs>[]
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    userId: string
    customId: string | null
    statusMessage: string | null
    receiveAnonymous: boolean
    receiveOtherSchool: boolean
    lastUpdateCustomId: Date | null
  }, ExtArgs["result"]["askedUser"]>
  composites: {}
}

/**
 * Model AskedUser
 * 
 */
export type AskedUser = runtime.Types.DefaultSelection<AskedUserPayload>
export type AskedPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    AskedUser: AskedUserPayload<ExtArgs>
    QuestionUser: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    askedUserId: string
    process: Process
    question: string
    answer: string | null
    createdAt: Date
    answerTimeAt: Date | null
    isAnonymous: boolean
  }, ExtArgs["result"]["asked"]>
  composites: {}
}

/**
 * Model Asked
 * 
 */
export type Asked = runtime.Types.DefaultSelection<AskedPayload>
export type AdminPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    loginId: string
    password: string
    flags: number
  }, ExtArgs["result"]["admin"]>
  composites: {}
}

/**
 * Model Admin
 * 
 */
export type Admin = runtime.Types.DefaultSelection<AdminPayload>
export type BoardPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    Article: ArticlePayload<ExtArgs>[]
    managers: BoardManagerPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    schoolId: string
    name: string
    description: string
    default: boolean
    noticeId: number[]
  }, ExtArgs["result"]["board"]>
  composites: {}
}

/**
 * Model Board
 * 
 */
export type Board = runtime.Types.DefaultSelection<BoardPayload>
export type BoardManagerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    board: BoardPayload<ExtArgs>
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    boardId: number
    name: string
    userId: string
  }, ExtArgs["result"]["boardManager"]>
  composites: {}
}

/**
 * Model BoardManager
 * 
 */
export type BoardManager = runtime.Types.DefaultSelection<BoardManagerPayload>
export type ArticlePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    Board: BoardPayload<ExtArgs>
    User: UserPayload<ExtArgs>
    school: SchoolPayload<ExtArgs>
    Comment: CommentPayload<ExtArgs>[]
    ReComment: ReCommentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    schoolId: string
    title: string
    content: string
    images: string[]
    isAnonymous: boolean
    userId: string
    createdAt: Date
    boardId: number
  }, ExtArgs["result"]["article"]>
  composites: {}
}

/**
 * Model Article
 * 
 */
export type Article = runtime.Types.DefaultSelection<ArticlePayload>
export type DeletedArticlePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: number
    schoolId: string
    title: string
    content: string
    images: string[]
    isAnonymous: boolean
    userId: string
    createdAt: Date
    DeletedAt: Date
    boardId: number
  }, ExtArgs["result"]["deletedArticle"]>
  composites: {}
}

/**
 * Model DeletedArticle
 * 
 */
export type DeletedArticle = runtime.Types.DefaultSelection<DeletedArticlePayload>
export type BoardRequestPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    name: string
    description: string
    userId: string
    schoolId: string
    schoolName: string
    process: BoardRequestProcess
    message: string | null
  }, ExtArgs["result"]["boardRequest"]>
  composites: {}
}

/**
 * Model BoardRequest
 * 
 */
export type BoardRequest = runtime.Types.DefaultSelection<BoardRequestPayload>
export type CommentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    Article: ArticlePayload<ExtArgs>
    User: UserPayload<ExtArgs>
    recomments: ReCommentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    id: number
    articleId: number
  }, ExtArgs["result"]["comment"]>
  composites: {}
}

/**
 * Model Comment
 * 
 */
export type Comment = runtime.Types.DefaultSelection<CommentPayload>
export type ReCommentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    Article: ArticlePayload<ExtArgs>
    Comment: CommentPayload<ExtArgs> | null
    User: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: number
    articleId: number
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    commentId: number | null
  }, ExtArgs["result"]["reComment"]>
  composites: {}
}

/**
 * Model ReComment
 * 
 */
export type ReComment = runtime.Types.DefaultSelection<ReCommentPayload>
export type ReportPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    reportUserId: string
    targetType: ReportTargetType
    message: string
    targetId: string
    reportUserName: string
    process: ReportProcess
  }, ExtArgs["result"]["report"]>
  composites: {}
}

/**
 * Model Report
 * 
 */
export type Report = runtime.Types.DefaultSelection<ReportPayload>
export type LikePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    userId: string
    targetId: number
    targetType: LikeTargetType
    likeType: LikeType
  }, ExtArgs["result"]["like"]>
  composites: {}
}

/**
 * Model Like
 * 
 */
export type Like = runtime.Types.DefaultSelection<LikePayload>
export type MealPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {}
  scalars: $Extensions.GetResult<{
    id: string
    MLSV_FGR: number
    DDISH_NM: string
    ORPLC_INFO: string
    CAL_INFO: string
    NTR_INFO: string
  }, ExtArgs["result"]["meal"]>
  composites: {}
}

/**
 * Model Meal
 * 
 */
export type Meal = runtime.Types.DefaultSelection<MealPayload>

/**
 * Enums
 */

export const UserLoginProviderType: {
  id: 'id',
  social: 'social'
};

export type UserLoginProviderType = (typeof UserLoginProviderType)[keyof typeof UserLoginProviderType]


export const SocialLoginProviderType: {
  google: 'google',
  kakao: 'kakao'
};

export type SocialLoginProviderType = (typeof SocialLoginProviderType)[keyof typeof SocialLoginProviderType]


export const Process: {
  pending: 'pending',
  denied: 'denied',
  success: 'success'
};

export type Process = (typeof Process)[keyof typeof Process]


export const BoardRequestProcess: {
  pending: 'pending',
  denied: 'denied',
  success: 'success'
};

export type BoardRequestProcess = (typeof BoardRequestProcess)[keyof typeof BoardRequestProcess]


export const ReportTargetType: {
  user: 'user',
  article: 'article',
  comment: 'comment',
  asked: 'asked',
  recomment: 'recomment'
};

export type ReportTargetType = (typeof ReportTargetType)[keyof typeof ReportTargetType]


export const ReportProcess: {
  pending: 'pending',
  success: 'success'
};

export type ReportProcess = (typeof ReportProcess)[keyof typeof ReportProcess]


export const LikeTargetType: {
  article: 'article',
  comment: 'comment',
  recomment: 'recomment'
};

export type LikeTargetType = (typeof LikeTargetType)[keyof typeof LikeTargetType]


export const LikeType: {
  like: 'like',
  dislike: 'dislike'
};

export type LikeType = (typeof LikeType)[keyof typeof LikeType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **School** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.SchoolDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.phoneVerifyRequest`: Exposes CRUD operations for the **PhoneVerifyRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhoneVerifyRequests
    * const phoneVerifyRequests = await prisma.phoneVerifyRequest.findMany()
    * ```
    */
  get phoneVerifyRequest(): Prisma.PhoneVerifyRequestDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.socialLogin`: Exposes CRUD operations for the **SocialLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialLogins
    * const socialLogins = await prisma.socialLogin.findMany()
    * ```
    */
  get socialLogin(): Prisma.SocialLoginDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.agreement`: Exposes CRUD operations for the **Agreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agreements
    * const agreements = await prisma.agreement.findMany()
    * ```
    */
  get agreement(): Prisma.AgreementDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userSchoolVerify`: Exposes CRUD operations for the **UserSchoolVerify** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSchoolVerifies
    * const userSchoolVerifies = await prisma.userSchoolVerify.findMany()
    * ```
    */
  get userSchoolVerify(): Prisma.UserSchoolVerifyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userSchool`: Exposes CRUD operations for the **UserSchool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSchools
    * const userSchools = await prisma.userSchool.findMany()
    * ```
    */
  get userSchool(): Prisma.UserSchoolDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.busStation`: Exposes CRUD operations for the **BusStation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusStations
    * const busStations = await prisma.busStation.findMany()
    * ```
    */
  get busStation(): Prisma.BusStationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.busRoute`: Exposes CRUD operations for the **BusRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusRoutes
    * const busRoutes = await prisma.busRoute.findMany()
    * ```
    */
  get busRoute(): Prisma.BusRouteDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.busArrival`: Exposes CRUD operations for the **BusArrival** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusArrivals
    * const busArrivals = await prisma.busArrival.findMany()
    * ```
    */
  get busArrival(): Prisma.BusArrivalDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.askedUser`: Exposes CRUD operations for the **AskedUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AskedUsers
    * const askedUsers = await prisma.askedUser.findMany()
    * ```
    */
  get askedUser(): Prisma.AskedUserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.asked`: Exposes CRUD operations for the **Asked** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Askeds
    * const askeds = await prisma.asked.findMany()
    * ```
    */
  get asked(): Prisma.AskedDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.board`: Exposes CRUD operations for the **Board** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boards
    * const boards = await prisma.board.findMany()
    * ```
    */
  get board(): Prisma.BoardDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.boardManager`: Exposes CRUD operations for the **BoardManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardManagers
    * const boardManagers = await prisma.boardManager.findMany()
    * ```
    */
  get boardManager(): Prisma.BoardManagerDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.article`: Exposes CRUD operations for the **Article** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Articles
    * const articles = await prisma.article.findMany()
    * ```
    */
  get article(): Prisma.ArticleDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.deletedArticle`: Exposes CRUD operations for the **DeletedArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeletedArticles
    * const deletedArticles = await prisma.deletedArticle.findMany()
    * ```
    */
  get deletedArticle(): Prisma.DeletedArticleDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.boardRequest`: Exposes CRUD operations for the **BoardRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BoardRequests
    * const boardRequests = await prisma.boardRequest.findMany()
    * ```
    */
  get boardRequest(): Prisma.BoardRequestDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.reComment`: Exposes CRUD operations for the **ReComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReComments
    * const reComments = await prisma.reComment.findMany()
    * ```
    */
  get reComment(): Prisma.ReCommentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.like`: Exposes CRUD operations for the **Like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Likes
    * const likes = await prisma.like.findMany()
    * ```
    */
  get like(): Prisma.LikeDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.meal`: Exposes CRUD operations for the **Meal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meals
    * const meals = await prisma.meal.findMany()
    * ```
    */
  get meal(): Prisma.MealDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.1
   * Query Engine version: b20ead4d3ab9e78ac112966e242ded703f4a052c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    School: 'School',
    Image: 'Image',
    PhoneVerifyRequest: 'PhoneVerifyRequest',
    SocialLogin: 'SocialLogin',
    Agreement: 'Agreement',
    UserSchoolVerify: 'UserSchoolVerify',
    UserSchool: 'UserSchool',
    BusStation: 'BusStation',
    BusRoute: 'BusRoute',
    BusArrival: 'BusArrival',
    AskedUser: 'AskedUser',
    Asked: 'Asked',
    Admin: 'Admin',
    Board: 'Board',
    BoardManager: 'BoardManager',
    Article: 'Article',
    DeletedArticle: 'DeletedArticle',
    BoardRequest: 'BoardRequest',
    Comment: 'Comment',
    ReComment: 'ReComment',
    Report: 'Report',
    Like: 'Like',
    Meal: 'Meal'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'school' | 'image' | 'phoneVerifyRequest' | 'socialLogin' | 'agreement' | 'userSchoolVerify' | 'userSchool' | 'busStation' | 'busRoute' | 'busArrival' | 'askedUser' | 'asked' | 'admin' | 'board' | 'boardManager' | 'article' | 'deletedArticle' | 'boardRequest' | 'comment' | 'reComment' | 'report' | 'like' | 'meal'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
            payload: UserPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
            payload: UserPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
            payload: UserPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
            payload: UserPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
            payload: UserPayload<ExtArgs>
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
            payload: UserPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserPayload<ExtArgs>
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
            payload: UserPayload<ExtArgs>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
            payload: UserPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
            payload: UserPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
            payload: UserPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
            payload: UserPayload<ExtArgs>
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
            payload: UserPayload<ExtArgs>
          }
        }
      }
      School: {
        operations: {
          findUnique: {
            args: Prisma.SchoolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SchoolPayload> | null
            payload: SchoolPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SchoolPayload>
            payload: SchoolPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.SchoolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SchoolPayload> | null
            payload: SchoolPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.SchoolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SchoolPayload>
            payload: SchoolPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.SchoolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SchoolPayload>[]
            payload: SchoolPayload<ExtArgs>
          }
          create: {
            args: Prisma.SchoolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SchoolPayload>
            payload: SchoolPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.SchoolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: SchoolPayload<ExtArgs>
          }
          delete: {
            args: Prisma.SchoolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SchoolPayload>
            payload: SchoolPayload<ExtArgs>
          }
          update: {
            args: Prisma.SchoolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SchoolPayload>
            payload: SchoolPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.SchoolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: SchoolPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.SchoolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: SchoolPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.SchoolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SchoolPayload>
            payload: SchoolPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSchool>
            payload: SchoolPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.SchoolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SchoolGroupByOutputType>[]
            payload: SchoolPayload<ExtArgs>
          }
          count: {
            args: Prisma.SchoolCountArgs<ExtArgs>,
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
            payload: SchoolPayload<ExtArgs>
          }
        }
      }
      Image: {
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ImagePayload> | null
            payload: ImagePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ImagePayload>
            payload: ImagePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ImagePayload> | null
            payload: ImagePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ImagePayload>
            payload: ImagePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ImagePayload>[]
            payload: ImagePayload<ExtArgs>
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ImagePayload>
            payload: ImagePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ImagePayload<ExtArgs>
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ImagePayload>
            payload: ImagePayload<ExtArgs>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ImagePayload>
            payload: ImagePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ImagePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ImagePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ImagePayload>
            payload: ImagePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateImage>
            payload: ImagePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ImageGroupByOutputType>[]
            payload: ImagePayload<ExtArgs>
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>,
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
            payload: ImagePayload<ExtArgs>
          }
        }
      }
      PhoneVerifyRequest: {
        operations: {
          findUnique: {
            args: Prisma.PhoneVerifyRequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerifyRequestPayload> | null
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.PhoneVerifyRequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerifyRequestPayload>
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.PhoneVerifyRequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerifyRequestPayload> | null
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.PhoneVerifyRequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerifyRequestPayload>
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.PhoneVerifyRequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerifyRequestPayload>[]
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          create: {
            args: Prisma.PhoneVerifyRequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerifyRequestPayload>
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.PhoneVerifyRequestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          delete: {
            args: Prisma.PhoneVerifyRequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerifyRequestPayload>
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          update: {
            args: Prisma.PhoneVerifyRequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerifyRequestPayload>
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.PhoneVerifyRequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.PhoneVerifyRequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.PhoneVerifyRequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PhoneVerifyRequestPayload>
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.PhoneVerifyRequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePhoneVerifyRequest>
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.PhoneVerifyRequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PhoneVerifyRequestGroupByOutputType>[]
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
          count: {
            args: Prisma.PhoneVerifyRequestCountArgs<ExtArgs>,
            result: $Utils.Optional<PhoneVerifyRequestCountAggregateOutputType> | number
            payload: PhoneVerifyRequestPayload<ExtArgs>
          }
        }
      }
      SocialLogin: {
        operations: {
          findUnique: {
            args: Prisma.SocialLoginFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialLoginPayload> | null
            payload: SocialLoginPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.SocialLoginFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialLoginPayload>
            payload: SocialLoginPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.SocialLoginFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialLoginPayload> | null
            payload: SocialLoginPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.SocialLoginFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialLoginPayload>
            payload: SocialLoginPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.SocialLoginFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialLoginPayload>[]
            payload: SocialLoginPayload<ExtArgs>
          }
          create: {
            args: Prisma.SocialLoginCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialLoginPayload>
            payload: SocialLoginPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.SocialLoginCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: SocialLoginPayload<ExtArgs>
          }
          delete: {
            args: Prisma.SocialLoginDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialLoginPayload>
            payload: SocialLoginPayload<ExtArgs>
          }
          update: {
            args: Prisma.SocialLoginUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialLoginPayload>
            payload: SocialLoginPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.SocialLoginDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: SocialLoginPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.SocialLoginUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: SocialLoginPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.SocialLoginUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SocialLoginPayload>
            payload: SocialLoginPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.SocialLoginAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSocialLogin>
            payload: SocialLoginPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.SocialLoginGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SocialLoginGroupByOutputType>[]
            payload: SocialLoginPayload<ExtArgs>
          }
          count: {
            args: Prisma.SocialLoginCountArgs<ExtArgs>,
            result: $Utils.Optional<SocialLoginCountAggregateOutputType> | number
            payload: SocialLoginPayload<ExtArgs>
          }
        }
      }
      Agreement: {
        operations: {
          findUnique: {
            args: Prisma.AgreementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementPayload> | null
            payload: AgreementPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.AgreementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementPayload>
            payload: AgreementPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.AgreementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementPayload> | null
            payload: AgreementPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.AgreementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementPayload>
            payload: AgreementPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.AgreementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementPayload>[]
            payload: AgreementPayload<ExtArgs>
          }
          create: {
            args: Prisma.AgreementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementPayload>
            payload: AgreementPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.AgreementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AgreementPayload<ExtArgs>
          }
          delete: {
            args: Prisma.AgreementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementPayload>
            payload: AgreementPayload<ExtArgs>
          }
          update: {
            args: Prisma.AgreementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementPayload>
            payload: AgreementPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.AgreementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AgreementPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.AgreementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AgreementPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.AgreementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AgreementPayload>
            payload: AgreementPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.AgreementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAgreement>
            payload: AgreementPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.AgreementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AgreementGroupByOutputType>[]
            payload: AgreementPayload<ExtArgs>
          }
          count: {
            args: Prisma.AgreementCountArgs<ExtArgs>,
            result: $Utils.Optional<AgreementCountAggregateOutputType> | number
            payload: AgreementPayload<ExtArgs>
          }
        }
      }
      UserSchoolVerify: {
        operations: {
          findUnique: {
            args: Prisma.UserSchoolVerifyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolVerifyPayload> | null
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.UserSchoolVerifyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolVerifyPayload>
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.UserSchoolVerifyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolVerifyPayload> | null
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.UserSchoolVerifyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolVerifyPayload>
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.UserSchoolVerifyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolVerifyPayload>[]
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          create: {
            args: Prisma.UserSchoolVerifyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolVerifyPayload>
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.UserSchoolVerifyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          delete: {
            args: Prisma.UserSchoolVerifyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolVerifyPayload>
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          update: {
            args: Prisma.UserSchoolVerifyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolVerifyPayload>
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.UserSchoolVerifyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.UserSchoolVerifyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.UserSchoolVerifyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolVerifyPayload>
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.UserSchoolVerifyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserSchoolVerify>
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.UserSchoolVerifyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserSchoolVerifyGroupByOutputType>[]
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
          count: {
            args: Prisma.UserSchoolVerifyCountArgs<ExtArgs>,
            result: $Utils.Optional<UserSchoolVerifyCountAggregateOutputType> | number
            payload: UserSchoolVerifyPayload<ExtArgs>
          }
        }
      }
      UserSchool: {
        operations: {
          findUnique: {
            args: Prisma.UserSchoolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolPayload> | null
            payload: UserSchoolPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.UserSchoolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolPayload>
            payload: UserSchoolPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.UserSchoolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolPayload> | null
            payload: UserSchoolPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.UserSchoolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolPayload>
            payload: UserSchoolPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.UserSchoolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolPayload>[]
            payload: UserSchoolPayload<ExtArgs>
          }
          create: {
            args: Prisma.UserSchoolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolPayload>
            payload: UserSchoolPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.UserSchoolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserSchoolPayload<ExtArgs>
          }
          delete: {
            args: Prisma.UserSchoolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolPayload>
            payload: UserSchoolPayload<ExtArgs>
          }
          update: {
            args: Prisma.UserSchoolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolPayload>
            payload: UserSchoolPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.UserSchoolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserSchoolPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.UserSchoolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: UserSchoolPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.UserSchoolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserSchoolPayload>
            payload: UserSchoolPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.UserSchoolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserSchool>
            payload: UserSchoolPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.UserSchoolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserSchoolGroupByOutputType>[]
            payload: UserSchoolPayload<ExtArgs>
          }
          count: {
            args: Prisma.UserSchoolCountArgs<ExtArgs>,
            result: $Utils.Optional<UserSchoolCountAggregateOutputType> | number
            payload: UserSchoolPayload<ExtArgs>
          }
        }
      }
      BusStation: {
        operations: {
          findUnique: {
            args: Prisma.BusStationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusStationPayload> | null
            payload: BusStationPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.BusStationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusStationPayload>
            payload: BusStationPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.BusStationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusStationPayload> | null
            payload: BusStationPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.BusStationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusStationPayload>
            payload: BusStationPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.BusStationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusStationPayload>[]
            payload: BusStationPayload<ExtArgs>
          }
          create: {
            args: Prisma.BusStationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusStationPayload>
            payload: BusStationPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.BusStationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusStationPayload<ExtArgs>
          }
          delete: {
            args: Prisma.BusStationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusStationPayload>
            payload: BusStationPayload<ExtArgs>
          }
          update: {
            args: Prisma.BusStationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusStationPayload>
            payload: BusStationPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.BusStationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusStationPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.BusStationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusStationPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.BusStationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusStationPayload>
            payload: BusStationPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.BusStationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBusStation>
            payload: BusStationPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.BusStationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BusStationGroupByOutputType>[]
            payload: BusStationPayload<ExtArgs>
          }
          count: {
            args: Prisma.BusStationCountArgs<ExtArgs>,
            result: $Utils.Optional<BusStationCountAggregateOutputType> | number
            payload: BusStationPayload<ExtArgs>
          }
        }
      }
      BusRoute: {
        operations: {
          findUnique: {
            args: Prisma.BusRouteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusRoutePayload> | null
            payload: BusRoutePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.BusRouteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusRoutePayload>
            payload: BusRoutePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.BusRouteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusRoutePayload> | null
            payload: BusRoutePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.BusRouteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusRoutePayload>
            payload: BusRoutePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.BusRouteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusRoutePayload>[]
            payload: BusRoutePayload<ExtArgs>
          }
          create: {
            args: Prisma.BusRouteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusRoutePayload>
            payload: BusRoutePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.BusRouteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusRoutePayload<ExtArgs>
          }
          delete: {
            args: Prisma.BusRouteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusRoutePayload>
            payload: BusRoutePayload<ExtArgs>
          }
          update: {
            args: Prisma.BusRouteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusRoutePayload>
            payload: BusRoutePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.BusRouteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusRoutePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.BusRouteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusRoutePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.BusRouteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusRoutePayload>
            payload: BusRoutePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.BusRouteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBusRoute>
            payload: BusRoutePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.BusRouteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BusRouteGroupByOutputType>[]
            payload: BusRoutePayload<ExtArgs>
          }
          count: {
            args: Prisma.BusRouteCountArgs<ExtArgs>,
            result: $Utils.Optional<BusRouteCountAggregateOutputType> | number
            payload: BusRoutePayload<ExtArgs>
          }
        }
      }
      BusArrival: {
        operations: {
          findUnique: {
            args: Prisma.BusArrivalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusArrivalPayload> | null
            payload: BusArrivalPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.BusArrivalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusArrivalPayload>
            payload: BusArrivalPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.BusArrivalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusArrivalPayload> | null
            payload: BusArrivalPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.BusArrivalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusArrivalPayload>
            payload: BusArrivalPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.BusArrivalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusArrivalPayload>[]
            payload: BusArrivalPayload<ExtArgs>
          }
          create: {
            args: Prisma.BusArrivalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusArrivalPayload>
            payload: BusArrivalPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.BusArrivalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusArrivalPayload<ExtArgs>
          }
          delete: {
            args: Prisma.BusArrivalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusArrivalPayload>
            payload: BusArrivalPayload<ExtArgs>
          }
          update: {
            args: Prisma.BusArrivalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusArrivalPayload>
            payload: BusArrivalPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.BusArrivalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusArrivalPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.BusArrivalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BusArrivalPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.BusArrivalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BusArrivalPayload>
            payload: BusArrivalPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.BusArrivalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBusArrival>
            payload: BusArrivalPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.BusArrivalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BusArrivalGroupByOutputType>[]
            payload: BusArrivalPayload<ExtArgs>
          }
          count: {
            args: Prisma.BusArrivalCountArgs<ExtArgs>,
            result: $Utils.Optional<BusArrivalCountAggregateOutputType> | number
            payload: BusArrivalPayload<ExtArgs>
          }
        }
      }
      AskedUser: {
        operations: {
          findUnique: {
            args: Prisma.AskedUserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedUserPayload> | null
            payload: AskedUserPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.AskedUserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedUserPayload>
            payload: AskedUserPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.AskedUserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedUserPayload> | null
            payload: AskedUserPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.AskedUserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedUserPayload>
            payload: AskedUserPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.AskedUserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedUserPayload>[]
            payload: AskedUserPayload<ExtArgs>
          }
          create: {
            args: Prisma.AskedUserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedUserPayload>
            payload: AskedUserPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.AskedUserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AskedUserPayload<ExtArgs>
          }
          delete: {
            args: Prisma.AskedUserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedUserPayload>
            payload: AskedUserPayload<ExtArgs>
          }
          update: {
            args: Prisma.AskedUserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedUserPayload>
            payload: AskedUserPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.AskedUserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AskedUserPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.AskedUserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AskedUserPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.AskedUserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedUserPayload>
            payload: AskedUserPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.AskedUserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAskedUser>
            payload: AskedUserPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.AskedUserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AskedUserGroupByOutputType>[]
            payload: AskedUserPayload<ExtArgs>
          }
          count: {
            args: Prisma.AskedUserCountArgs<ExtArgs>,
            result: $Utils.Optional<AskedUserCountAggregateOutputType> | number
            payload: AskedUserPayload<ExtArgs>
          }
        }
      }
      Asked: {
        operations: {
          findUnique: {
            args: Prisma.AskedFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedPayload> | null
            payload: AskedPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.AskedFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedPayload>
            payload: AskedPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.AskedFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedPayload> | null
            payload: AskedPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.AskedFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedPayload>
            payload: AskedPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.AskedFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedPayload>[]
            payload: AskedPayload<ExtArgs>
          }
          create: {
            args: Prisma.AskedCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedPayload>
            payload: AskedPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.AskedCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AskedPayload<ExtArgs>
          }
          delete: {
            args: Prisma.AskedDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedPayload>
            payload: AskedPayload<ExtArgs>
          }
          update: {
            args: Prisma.AskedUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedPayload>
            payload: AskedPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.AskedDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AskedPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.AskedUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AskedPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.AskedUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AskedPayload>
            payload: AskedPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.AskedAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAsked>
            payload: AskedPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.AskedGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AskedGroupByOutputType>[]
            payload: AskedPayload<ExtArgs>
          }
          count: {
            args: Prisma.AskedCountArgs<ExtArgs>,
            result: $Utils.Optional<AskedCountAggregateOutputType> | number
            payload: AskedPayload<ExtArgs>
          }
        }
      }
      Admin: {
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload> | null
            payload: AdminPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
            payload: AdminPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload> | null
            payload: AdminPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
            payload: AdminPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>[]
            payload: AdminPayload<ExtArgs>
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
            payload: AdminPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AdminPayload<ExtArgs>
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
            payload: AdminPayload<ExtArgs>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
            payload: AdminPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AdminPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: AdminPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AdminPayload>
            payload: AdminPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
            payload: AdminPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
            payload: AdminPayload<ExtArgs>
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
            payload: AdminPayload<ExtArgs>
          }
        }
      }
      Board: {
        operations: {
          findUnique: {
            args: Prisma.BoardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardPayload> | null
            payload: BoardPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.BoardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardPayload>
            payload: BoardPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.BoardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardPayload> | null
            payload: BoardPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.BoardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardPayload>
            payload: BoardPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.BoardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardPayload>[]
            payload: BoardPayload<ExtArgs>
          }
          create: {
            args: Prisma.BoardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardPayload>
            payload: BoardPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.BoardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BoardPayload<ExtArgs>
          }
          delete: {
            args: Prisma.BoardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardPayload>
            payload: BoardPayload<ExtArgs>
          }
          update: {
            args: Prisma.BoardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardPayload>
            payload: BoardPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.BoardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BoardPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.BoardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BoardPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.BoardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardPayload>
            payload: BoardPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.BoardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBoard>
            payload: BoardPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.BoardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BoardGroupByOutputType>[]
            payload: BoardPayload<ExtArgs>
          }
          count: {
            args: Prisma.BoardCountArgs<ExtArgs>,
            result: $Utils.Optional<BoardCountAggregateOutputType> | number
            payload: BoardPayload<ExtArgs>
          }
        }
      }
      BoardManager: {
        operations: {
          findUnique: {
            args: Prisma.BoardManagerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardManagerPayload> | null
            payload: BoardManagerPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.BoardManagerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardManagerPayload>
            payload: BoardManagerPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.BoardManagerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardManagerPayload> | null
            payload: BoardManagerPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.BoardManagerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardManagerPayload>
            payload: BoardManagerPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.BoardManagerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardManagerPayload>[]
            payload: BoardManagerPayload<ExtArgs>
          }
          create: {
            args: Prisma.BoardManagerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardManagerPayload>
            payload: BoardManagerPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.BoardManagerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BoardManagerPayload<ExtArgs>
          }
          delete: {
            args: Prisma.BoardManagerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardManagerPayload>
            payload: BoardManagerPayload<ExtArgs>
          }
          update: {
            args: Prisma.BoardManagerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardManagerPayload>
            payload: BoardManagerPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.BoardManagerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BoardManagerPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.BoardManagerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BoardManagerPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.BoardManagerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardManagerPayload>
            payload: BoardManagerPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.BoardManagerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBoardManager>
            payload: BoardManagerPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.BoardManagerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BoardManagerGroupByOutputType>[]
            payload: BoardManagerPayload<ExtArgs>
          }
          count: {
            args: Prisma.BoardManagerCountArgs<ExtArgs>,
            result: $Utils.Optional<BoardManagerCountAggregateOutputType> | number
            payload: BoardManagerPayload<ExtArgs>
          }
        }
      }
      Article: {
        operations: {
          findUnique: {
            args: Prisma.ArticleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ArticlePayload> | null
            payload: ArticlePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ArticlePayload>
            payload: ArticlePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ArticleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ArticlePayload> | null
            payload: ArticlePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ArticleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ArticlePayload>
            payload: ArticlePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ArticleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ArticlePayload>[]
            payload: ArticlePayload<ExtArgs>
          }
          create: {
            args: Prisma.ArticleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ArticlePayload>
            payload: ArticlePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ArticleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ArticlePayload<ExtArgs>
          }
          delete: {
            args: Prisma.ArticleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ArticlePayload>
            payload: ArticlePayload<ExtArgs>
          }
          update: {
            args: Prisma.ArticleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ArticlePayload>
            payload: ArticlePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ArticleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ArticlePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ArticleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ArticlePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ArticleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ArticlePayload>
            payload: ArticlePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ArticleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateArticle>
            payload: ArticlePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ArticleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ArticleGroupByOutputType>[]
            payload: ArticlePayload<ExtArgs>
          }
          count: {
            args: Prisma.ArticleCountArgs<ExtArgs>,
            result: $Utils.Optional<ArticleCountAggregateOutputType> | number
            payload: ArticlePayload<ExtArgs>
          }
        }
      }
      DeletedArticle: {
        operations: {
          findUnique: {
            args: Prisma.DeletedArticleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeletedArticlePayload> | null
            payload: DeletedArticlePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.DeletedArticleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeletedArticlePayload>
            payload: DeletedArticlePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.DeletedArticleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeletedArticlePayload> | null
            payload: DeletedArticlePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.DeletedArticleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeletedArticlePayload>
            payload: DeletedArticlePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.DeletedArticleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeletedArticlePayload>[]
            payload: DeletedArticlePayload<ExtArgs>
          }
          create: {
            args: Prisma.DeletedArticleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeletedArticlePayload>
            payload: DeletedArticlePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.DeletedArticleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: DeletedArticlePayload<ExtArgs>
          }
          delete: {
            args: Prisma.DeletedArticleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeletedArticlePayload>
            payload: DeletedArticlePayload<ExtArgs>
          }
          update: {
            args: Prisma.DeletedArticleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeletedArticlePayload>
            payload: DeletedArticlePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.DeletedArticleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: DeletedArticlePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.DeletedArticleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: DeletedArticlePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.DeletedArticleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DeletedArticlePayload>
            payload: DeletedArticlePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.DeletedArticleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDeletedArticle>
            payload: DeletedArticlePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.DeletedArticleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DeletedArticleGroupByOutputType>[]
            payload: DeletedArticlePayload<ExtArgs>
          }
          count: {
            args: Prisma.DeletedArticleCountArgs<ExtArgs>,
            result: $Utils.Optional<DeletedArticleCountAggregateOutputType> | number
            payload: DeletedArticlePayload<ExtArgs>
          }
        }
      }
      BoardRequest: {
        operations: {
          findUnique: {
            args: Prisma.BoardRequestFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardRequestPayload> | null
            payload: BoardRequestPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.BoardRequestFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardRequestPayload>
            payload: BoardRequestPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.BoardRequestFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardRequestPayload> | null
            payload: BoardRequestPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.BoardRequestFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardRequestPayload>
            payload: BoardRequestPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.BoardRequestFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardRequestPayload>[]
            payload: BoardRequestPayload<ExtArgs>
          }
          create: {
            args: Prisma.BoardRequestCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardRequestPayload>
            payload: BoardRequestPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.BoardRequestCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BoardRequestPayload<ExtArgs>
          }
          delete: {
            args: Prisma.BoardRequestDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardRequestPayload>
            payload: BoardRequestPayload<ExtArgs>
          }
          update: {
            args: Prisma.BoardRequestUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardRequestPayload>
            payload: BoardRequestPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.BoardRequestDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BoardRequestPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.BoardRequestUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: BoardRequestPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.BoardRequestUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<BoardRequestPayload>
            payload: BoardRequestPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.BoardRequestAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBoardRequest>
            payload: BoardRequestPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.BoardRequestGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BoardRequestGroupByOutputType>[]
            payload: BoardRequestPayload<ExtArgs>
          }
          count: {
            args: Prisma.BoardRequestCountArgs<ExtArgs>,
            result: $Utils.Optional<BoardRequestCountAggregateOutputType> | number
            payload: BoardRequestPayload<ExtArgs>
          }
        }
      }
      Comment: {
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload> | null
            payload: CommentPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
            payload: CommentPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload> | null
            payload: CommentPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
            payload: CommentPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>[]
            payload: CommentPayload<ExtArgs>
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
            payload: CommentPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: CommentPayload<ExtArgs>
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
            payload: CommentPayload<ExtArgs>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
            payload: CommentPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: CommentPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: CommentPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CommentPayload>
            payload: CommentPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
            payload: CommentPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
            payload: CommentPayload<ExtArgs>
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
            payload: CommentPayload<ExtArgs>
          }
        }
      }
      ReComment: {
        operations: {
          findUnique: {
            args: Prisma.ReCommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReCommentPayload> | null
            payload: ReCommentPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ReCommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReCommentPayload>
            payload: ReCommentPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ReCommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReCommentPayload> | null
            payload: ReCommentPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ReCommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReCommentPayload>
            payload: ReCommentPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ReCommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReCommentPayload>[]
            payload: ReCommentPayload<ExtArgs>
          }
          create: {
            args: Prisma.ReCommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReCommentPayload>
            payload: ReCommentPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ReCommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ReCommentPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ReCommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReCommentPayload>
            payload: ReCommentPayload<ExtArgs>
          }
          update: {
            args: Prisma.ReCommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReCommentPayload>
            payload: ReCommentPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ReCommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ReCommentPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ReCommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ReCommentPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ReCommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReCommentPayload>
            payload: ReCommentPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ReCommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReComment>
            payload: ReCommentPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ReCommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReCommentGroupByOutputType>[]
            payload: ReCommentPayload<ExtArgs>
          }
          count: {
            args: Prisma.ReCommentCountArgs<ExtArgs>,
            result: $Utils.Optional<ReCommentCountAggregateOutputType> | number
            payload: ReCommentPayload<ExtArgs>
          }
        }
      }
      Report: {
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload> | null
            payload: ReportPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
            payload: ReportPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload> | null
            payload: ReportPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
            payload: ReportPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>[]
            payload: ReportPayload<ExtArgs>
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
            payload: ReportPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ReportPayload<ExtArgs>
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
            payload: ReportPayload<ExtArgs>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
            payload: ReportPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ReportPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: ReportPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ReportPayload>
            payload: ReportPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReport>
            payload: ReportPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportGroupByOutputType>[]
            payload: ReportPayload<ExtArgs>
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
            payload: ReportPayload<ExtArgs>
          }
        }
      }
      Like: {
        operations: {
          findUnique: {
            args: Prisma.LikeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LikePayload> | null
            payload: LikePayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.LikeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LikePayload>
            payload: LikePayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.LikeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LikePayload> | null
            payload: LikePayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.LikeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LikePayload>
            payload: LikePayload<ExtArgs>
          }
          findMany: {
            args: Prisma.LikeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LikePayload>[]
            payload: LikePayload<ExtArgs>
          }
          create: {
            args: Prisma.LikeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LikePayload>
            payload: LikePayload<ExtArgs>
          }
          createMany: {
            args: Prisma.LikeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: LikePayload<ExtArgs>
          }
          delete: {
            args: Prisma.LikeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LikePayload>
            payload: LikePayload<ExtArgs>
          }
          update: {
            args: Prisma.LikeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LikePayload>
            payload: LikePayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.LikeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: LikePayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.LikeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: LikePayload<ExtArgs>
          }
          upsert: {
            args: Prisma.LikeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LikePayload>
            payload: LikePayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.LikeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLike>
            payload: LikePayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.LikeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LikeGroupByOutputType>[]
            payload: LikePayload<ExtArgs>
          }
          count: {
            args: Prisma.LikeCountArgs<ExtArgs>,
            result: $Utils.Optional<LikeCountAggregateOutputType> | number
            payload: LikePayload<ExtArgs>
          }
        }
      }
      Meal: {
        operations: {
          findUnique: {
            args: Prisma.MealFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MealPayload> | null
            payload: MealPayload<ExtArgs>
          }
          findUniqueOrThrow: {
            args: Prisma.MealFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MealPayload>
            payload: MealPayload<ExtArgs>
          }
          findFirst: {
            args: Prisma.MealFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MealPayload> | null
            payload: MealPayload<ExtArgs>
          }
          findFirstOrThrow: {
            args: Prisma.MealFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MealPayload>
            payload: MealPayload<ExtArgs>
          }
          findMany: {
            args: Prisma.MealFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MealPayload>[]
            payload: MealPayload<ExtArgs>
          }
          create: {
            args: Prisma.MealCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MealPayload>
            payload: MealPayload<ExtArgs>
          }
          createMany: {
            args: Prisma.MealCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: MealPayload<ExtArgs>
          }
          delete: {
            args: Prisma.MealDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MealPayload>
            payload: MealPayload<ExtArgs>
          }
          update: {
            args: Prisma.MealUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MealPayload>
            payload: MealPayload<ExtArgs>
          }
          deleteMany: {
            args: Prisma.MealDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: MealPayload<ExtArgs>
          }
          updateMany: {
            args: Prisma.MealUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
            payload: MealPayload<ExtArgs>
          }
          upsert: {
            args: Prisma.MealUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<MealPayload>
            payload: MealPayload<ExtArgs>
          }
          aggregate: {
            args: Prisma.MealAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMeal>
            payload: MealPayload<ExtArgs>
          }
          groupBy: {
            args: Prisma.MealGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MealGroupByOutputType>[]
            payload: MealPayload<ExtArgs>
          }
          count: {
            args: Prisma.MealCountArgs<ExtArgs>,
            result: $Utils.Optional<MealCountAggregateOutputType> | number
            payload: MealPayload<ExtArgs>
          }
        }
      }
    }
  } & {
    other: {
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
          payload: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
          payload: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    Article: number
    Asked: number
    BoardOrganizations: number
    Comment: number
    Image: number
    Like: number
    ReComment: number
    UserSchoolVerify: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Article?: boolean | UserCountOutputTypeCountArticleArgs
    Asked?: boolean | UserCountOutputTypeCountAskedArgs
    BoardOrganizations?: boolean | UserCountOutputTypeCountBoardOrganizationsArgs
    Comment?: boolean | UserCountOutputTypeCountCommentArgs
    Image?: boolean | UserCountOutputTypeCountImageArgs
    Like?: boolean | UserCountOutputTypeCountLikeArgs
    ReComment?: boolean | UserCountOutputTypeCountReCommentArgs
    UserSchoolVerify?: boolean | UserCountOutputTypeCountUserSchoolVerifyArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArticleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAskedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AskedWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBoardOrganizationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BoardManagerWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountImageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReCommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReCommentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSchoolVerifyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserSchoolVerifyWhereInput
  }



  /**
   * Count Type SchoolCountOutputType
   */


  export type SchoolCountOutputType = {
    UserSchool: number
    Article: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    UserSchool?: boolean | SchoolCountOutputTypeCountUserSchoolArgs
    Article?: boolean | SchoolCountOutputTypeCountArticleArgs
  }

  // Custom InputTypes

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountUserSchoolArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserSchoolWhereInput
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountArticleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }



  /**
   * Count Type ImageCountOutputType
   */


  export type ImageCountOutputType = {
    UserSchoolVerify: number
  }

  export type ImageCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    UserSchoolVerify?: boolean | ImageCountOutputTypeCountUserSchoolVerifyArgs
  }

  // Custom InputTypes

  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ImageCountOutputType
     */
    select?: ImageCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ImageCountOutputType without action
   */
  export type ImageCountOutputTypeCountUserSchoolVerifyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserSchoolVerifyWhereInput
  }



  /**
   * Count Type AskedUserCountOutputType
   */


  export type AskedUserCountOutputType = {
    Asked: number
  }

  export type AskedUserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Asked?: boolean | AskedUserCountOutputTypeCountAskedArgs
  }

  // Custom InputTypes

  /**
   * AskedUserCountOutputType without action
   */
  export type AskedUserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUserCountOutputType
     */
    select?: AskedUserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AskedUserCountOutputType without action
   */
  export type AskedUserCountOutputTypeCountAskedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AskedWhereInput
  }



  /**
   * Count Type BoardCountOutputType
   */


  export type BoardCountOutputType = {
    Article: number
    managers: number
  }

  export type BoardCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Article?: boolean | BoardCountOutputTypeCountArticleArgs
    managers?: boolean | BoardCountOutputTypeCountManagersArgs
  }

  // Custom InputTypes

  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardCountOutputType
     */
    select?: BoardCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountArticleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
  }


  /**
   * BoardCountOutputType without action
   */
  export type BoardCountOutputTypeCountManagersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BoardManagerWhereInput
  }



  /**
   * Count Type ArticleCountOutputType
   */


  export type ArticleCountOutputType = {
    Comment: number
    ReComment: number
  }

  export type ArticleCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Comment?: boolean | ArticleCountOutputTypeCountCommentArgs
    ReComment?: boolean | ArticleCountOutputTypeCountReCommentArgs
  }

  // Custom InputTypes

  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleCountOutputType
     */
    select?: ArticleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * ArticleCountOutputType without action
   */
  export type ArticleCountOutputTypeCountReCommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReCommentWhereInput
  }



  /**
   * Count Type CommentCountOutputType
   */


  export type CommentCountOutputType = {
    recomments: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    recomments?: boolean | CommentCountOutputTypeCountRecommentsArgs
  }

  // Custom InputTypes

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRecommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReCommentWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    profile: string | null
    isVerified: boolean | null
    phone: string | null
    createdAt: Date | null
    provider: UserLoginProviderType | null
    userSchoolId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    profile: string | null
    isVerified: boolean | null
    phone: string | null
    createdAt: Date | null
    provider: UserLoginProviderType | null
    userSchoolId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    profile: number
    isVerified: number
    phone: number
    createdAt: number
    provider: number
    userSchoolId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    profile?: true
    isVerified?: true
    phone?: true
    createdAt?: true
    provider?: true
    userSchoolId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    profile?: true
    isVerified?: true
    phone?: true
    createdAt?: true
    provider?: true
    userSchoolId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    profile?: true
    isVerified?: true
    phone?: true
    createdAt?: true
    provider?: true
    userSchoolId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    email: string | null
    password: string | null
    name: string
    profile: string | null
    isVerified: boolean
    phone: string | null
    createdAt: Date
    provider: UserLoginProviderType
    userSchoolId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    profile?: boolean
    isVerified?: boolean
    phone?: boolean
    createdAt?: boolean
    provider?: boolean
    userSchoolId?: boolean
    Agreement?: boolean | AgreementArgs<ExtArgs>
    Article?: boolean | User$ArticleArgs<ExtArgs>
    Asked?: boolean | User$AskedArgs<ExtArgs>
    AskedUser?: boolean | AskedUserArgs<ExtArgs>
    BoardOrganizations?: boolean | User$BoardOrganizationsArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    Image?: boolean | User$ImageArgs<ExtArgs>
    Like?: boolean | User$LikeArgs<ExtArgs>
    ReComment?: boolean | User$ReCommentArgs<ExtArgs>
    SocialLogin?: boolean | SocialLoginArgs<ExtArgs>
    UserSchool?: boolean | UserSchoolArgs<ExtArgs>
    UserSchoolVerify?: boolean | User$UserSchoolVerifyArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    profile?: boolean
    isVerified?: boolean
    phone?: boolean
    createdAt?: boolean
    provider?: boolean
    userSchoolId?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Agreement?: boolean | AgreementArgs<ExtArgs>
    Article?: boolean | User$ArticleArgs<ExtArgs>
    Asked?: boolean | User$AskedArgs<ExtArgs>
    AskedUser?: boolean | AskedUserArgs<ExtArgs>
    BoardOrganizations?: boolean | User$BoardOrganizationsArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    Image?: boolean | User$ImageArgs<ExtArgs>
    Like?: boolean | User$LikeArgs<ExtArgs>
    ReComment?: boolean | User$ReCommentArgs<ExtArgs>
    SocialLogin?: boolean | SocialLoginArgs<ExtArgs>
    UserSchool?: boolean | UserSchoolArgs<ExtArgs>
    UserSchoolVerify?: boolean | User$UserSchoolVerifyArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Agreement<T extends AgreementArgs<ExtArgs> = {}>(args?: Subset<T, AgreementArgs<ExtArgs>>): Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    Article<T extends User$ArticleArgs<ExtArgs> = {}>(args?: Subset<T, User$ArticleArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findMany', never>| Null>;

    Asked<T extends User$AskedArgs<ExtArgs> = {}>(args?: Subset<T, User$AskedArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AskedPayload<ExtArgs>, T, 'findMany', never>| Null>;

    AskedUser<T extends AskedUserArgs<ExtArgs> = {}>(args?: Subset<T, AskedUserArgs<ExtArgs>>): Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    BoardOrganizations<T extends User$BoardOrganizationsArgs<ExtArgs> = {}>(args?: Subset<T, User$BoardOrganizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    Comment<T extends User$CommentArgs<ExtArgs> = {}>(args?: Subset<T, User$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    Image<T extends User$ImageArgs<ExtArgs> = {}>(args?: Subset<T, User$ImageArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ImagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    Like<T extends User$LikeArgs<ExtArgs> = {}>(args?: Subset<T, User$LikeArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LikePayload<ExtArgs>, T, 'findMany', never>| Null>;

    ReComment<T extends User$ReCommentArgs<ExtArgs> = {}>(args?: Subset<T, User$ReCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    SocialLogin<T extends SocialLoginArgs<ExtArgs> = {}>(args?: Subset<T, SocialLoginArgs<ExtArgs>>): Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    UserSchool<T extends UserSchoolArgs<ExtArgs> = {}>(args?: Subset<T, UserSchoolArgs<ExtArgs>>): Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    UserSchoolVerify<T extends User$UserSchoolVerifyArgs<ExtArgs> = {}>(args?: Subset<T, User$UserSchoolVerifyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.Article
   */
  export type User$ArticleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * User.Asked
   */
  export type User$AskedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    where?: AskedWhereInput
    orderBy?: Enumerable<AskedOrderByWithRelationInput>
    cursor?: AskedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AskedScalarFieldEnum>
  }


  /**
   * User.BoardOrganizations
   */
  export type User$BoardOrganizationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    where?: BoardManagerWhereInput
    orderBy?: Enumerable<BoardManagerOrderByWithRelationInput>
    cursor?: BoardManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoardManagerScalarFieldEnum>
  }


  /**
   * User.Comment
   */
  export type User$CommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * User.Image
   */
  export type User$ImageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: Enumerable<ImageOrderByWithRelationInput>
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * User.Like
   */
  export type User$LikeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    where?: LikeWhereInput
    orderBy?: Enumerable<LikeOrderByWithRelationInput>
    cursor?: LikeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LikeScalarFieldEnum>
  }


  /**
   * User.ReComment
   */
  export type User$ReCommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    where?: ReCommentWhereInput
    orderBy?: Enumerable<ReCommentOrderByWithRelationInput>
    cursor?: ReCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReCommentScalarFieldEnum>
  }


  /**
   * User.UserSchoolVerify
   */
  export type User$UserSchoolVerifyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    where?: UserSchoolVerifyWhereInput
    orderBy?: Enumerable<UserSchoolVerifyOrderByWithRelationInput>
    cursor?: UserSchoolVerifyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserSchoolVerifyScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model School
   */


  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolAvgAggregateOutputType = {
    x: number | null
    y: number | null
  }

  export type SchoolSumAggregateOutputType = {
    x: number | null
    y: number | null
  }

  export type SchoolMinAggregateOutputType = {
    schoolId: string | null
    org: string | null
    x: number | null
    y: number | null
    atptCode: string | null
    defaultName: string | null
    name: string | null
    type: string | null
  }

  export type SchoolMaxAggregateOutputType = {
    schoolId: string | null
    org: string | null
    x: number | null
    y: number | null
    atptCode: string | null
    defaultName: string | null
    name: string | null
    type: string | null
  }

  export type SchoolCountAggregateOutputType = {
    schoolId: number
    org: number
    x: number
    y: number
    atptCode: number
    defaultName: number
    name: number
    type: number
    _all: number
  }


  export type SchoolAvgAggregateInputType = {
    x?: true
    y?: true
  }

  export type SchoolSumAggregateInputType = {
    x?: true
    y?: true
  }

  export type SchoolMinAggregateInputType = {
    schoolId?: true
    org?: true
    x?: true
    y?: true
    atptCode?: true
    defaultName?: true
    name?: true
    type?: true
  }

  export type SchoolMaxAggregateInputType = {
    schoolId?: true
    org?: true
    x?: true
    y?: true
    atptCode?: true
    defaultName?: true
    name?: true
    type?: true
  }

  export type SchoolCountAggregateInputType = {
    schoolId?: true
    org?: true
    x?: true
    y?: true
    atptCode?: true
    defaultName?: true
    name?: true
    type?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which School to aggregate.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: Enumerable<SchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type SchoolGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SchoolWhereInput
    orderBy?: Enumerable<SchoolOrderByWithAggregationInput>
    by: SchoolScalarFieldEnum[]
    having?: SchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _avg?: SchoolAvgAggregateInputType
    _sum?: SchoolSumAggregateInputType
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }


  export type SchoolGroupByOutputType = {
    schoolId: string
    org: string
    x: number
    y: number
    atptCode: string
    defaultName: string
    name: string | null
    type: string
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends SchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type SchoolSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    schoolId?: boolean
    org?: boolean
    x?: boolean
    y?: boolean
    atptCode?: boolean
    defaultName?: boolean
    name?: boolean
    type?: boolean
    UserSchool?: boolean | School$UserSchoolArgs<ExtArgs>
    Article?: boolean | School$ArticleArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type SchoolSelectScalar = {
    schoolId?: boolean
    org?: boolean
    x?: boolean
    y?: boolean
    atptCode?: boolean
    defaultName?: boolean
    name?: boolean
    type?: boolean
  }

  export type SchoolInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    UserSchool?: boolean | School$UserSchoolArgs<ExtArgs>
    Article?: boolean | School$ArticleArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeArgs<ExtArgs>
  }


  type SchoolGetPayload<S extends boolean | null | undefined | SchoolArgs> = $Types.GetResult<SchoolPayload, S>

  type SchoolCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SchoolFindManyArgs, 'select' | 'include'> & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface SchoolDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['School'], meta: { name: 'School' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {SchoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SchoolFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SchoolFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'School'> extends True ? Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one School that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SchoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SchoolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SchoolFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SchoolFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'School'> extends True ? Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first School that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SchoolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `schoolId`
     * const schoolWithSchoolIdOnly = await prisma.school.findMany({ select: { schoolId: true } })
     * 
    **/
    findMany<T extends SchoolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a School.
     * @param {SchoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
    **/
    create<T extends SchoolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolCreateArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Schools.
     *     @param {SchoolCreateManyArgs} args - Arguments to create many Schools.
     *     @example
     *     // Create many Schools
     *     const school = await prisma.school.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SchoolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a School.
     * @param {SchoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
    **/
    delete<T extends SchoolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolDeleteArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one School.
     * @param {SchoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SchoolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolUpdateArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Schools.
     * @param {SchoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SchoolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SchoolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SchoolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School.
     * @param {SchoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
    **/
    upsert<T extends SchoolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SchoolUpsertArgs<ExtArgs>>
    ): Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends SchoolCountArgs>(
      args?: Subset<T, SchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolGroupByArgs['orderBy'] }
        : { orderBy?: SchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for School.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SchoolClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    UserSchool<T extends School$UserSchoolArgs<ExtArgs> = {}>(args?: Subset<T, School$UserSchoolArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'findMany', never>| Null>;

    Article<T extends School$ArticleArgs<ExtArgs> = {}>(args?: Subset<T, School$ArticleArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * School base type for findUnique actions
   */
  export type SchoolFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }

  /**
   * School findUnique
   */
  export interface SchoolFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SchoolFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * School findUniqueOrThrow
   */
  export type SchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School base type for findFirst actions
   */
  export type SchoolFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: Enumerable<SchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: Enumerable<SchoolScalarFieldEnum>
  }

  /**
   * School findFirst
   */
  export interface SchoolFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SchoolFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * School findFirstOrThrow
   */
  export type SchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which School to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: Enumerable<SchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schools.
     */
    distinct?: Enumerable<SchoolScalarFieldEnum>
  }


  /**
   * School findMany
   */
  export type SchoolFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter, which Schools to fetch.
     */
    where?: SchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schools to fetch.
     */
    orderBy?: Enumerable<SchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schools.
     */
    cursor?: SchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schools.
     */
    skip?: number
    distinct?: Enumerable<SchoolScalarFieldEnum>
  }


  /**
   * School create
   */
  export type SchoolCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a School.
     */
    data: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
  }


  /**
   * School createMany
   */
  export type SchoolCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schools.
     */
    data: Enumerable<SchoolCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * School update
   */
  export type SchoolUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a School.
     */
    data: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
    /**
     * Choose, which School to update.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School updateMany
   */
  export type SchoolUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schools.
     */
    data: XOR<SchoolUpdateManyMutationInput, SchoolUncheckedUpdateManyInput>
    /**
     * Filter which Schools to update
     */
    where?: SchoolWhereInput
  }


  /**
   * School upsert
   */
  export type SchoolUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the School to update in case it exists.
     */
    where: SchoolWhereUniqueInput
    /**
     * In case the School found by the `where` argument doesn't exist, create a new School with this data.
     */
    create: XOR<SchoolCreateInput, SchoolUncheckedCreateInput>
    /**
     * In case the School was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolUpdateInput, SchoolUncheckedUpdateInput>
  }


  /**
   * School delete
   */
  export type SchoolDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
    /**
     * Filter which School to delete.
     */
    where: SchoolWhereUniqueInput
  }


  /**
   * School deleteMany
   */
  export type SchoolDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schools to delete
     */
    where?: SchoolWhereInput
  }


  /**
   * School.UserSchool
   */
  export type School$UserSchoolArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
    where?: UserSchoolWhereInput
    orderBy?: Enumerable<UserSchoolOrderByWithRelationInput>
    cursor?: UserSchoolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserSchoolScalarFieldEnum>
  }


  /**
   * School.Article
   */
  export type School$ArticleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * School without action
   */
  export type SchoolArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the School
     */
    select?: SchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SchoolInclude<ExtArgs> | null
  }



  /**
   * Model Image
   */


  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageMinAggregateOutputType = {
    id: string | null
    key: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ImageMaxAggregateOutputType = {
    id: string | null
    key: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ImageCountAggregateOutputType = {
    id: number
    key: number
    userId: number
    createdAt: number
    _all: number
  }


  export type ImageMinAggregateInputType = {
    id?: true
    key?: true
    userId?: true
    createdAt?: true
  }

  export type ImageMaxAggregateInputType = {
    id?: true
    key?: true
    userId?: true
    createdAt?: true
  }

  export type ImageCountAggregateInputType = {
    id?: true
    key?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: Enumerable<ImageOrderByWithAggregationInput>
    by: ImageScalarFieldEnum[]
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }


  export type ImageGroupByOutputType = {
    id: string
    key: string
    userId: string
    createdAt: Date
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    UserSchoolVerify?: boolean | Image$UserSchoolVerifyArgs<ExtArgs>
    _count?: boolean | ImageCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectScalar = {
    id?: boolean
    key?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type ImageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    UserSchoolVerify?: boolean | Image$UserSchoolVerifyArgs<ExtArgs>
    _count?: boolean | ImageCountOutputTypeArgs<ExtArgs>
  }


  type ImageGetPayload<S extends boolean | null | undefined | ImageArgs> = $Types.GetResult<ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ImageFindManyArgs, 'select' | 'include'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ImageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Image'> extends True ? Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Image that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ImageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Image'> extends True ? Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Image that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const imageWithIdOnly = await prisma.image.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ImageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ImagePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
    **/
    create<T extends ImageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ImageCreateArgs<ExtArgs>>
    ): Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Images.
     *     @param {ImageCreateManyArgs} args - Arguments to create many Images.
     *     @example
     *     // Create many Images
     *     const image = await prisma.image.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ImageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
    **/
    delete<T extends ImageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>
    ): Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ImageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>
    ): Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ImageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ImageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
    **/
    upsert<T extends ImageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>
    ): Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    UserSchoolVerify<T extends Image$UserSchoolVerifyArgs<ExtArgs> = {}>(args?: Subset<T, Image$UserSchoolVerifyArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Image base type for findUnique actions
   */
  export type ImageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUnique
   */
  export interface ImageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ImageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image base type for findFirst actions
   */
  export type ImageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: Enumerable<ImageScalarFieldEnum>
  }

  /**
   * Image findFirst
   */
  export interface ImageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ImageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: Enumerable<ImageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: Enumerable<ImageScalarFieldEnum>
  }


  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }


  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: Enumerable<ImageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
  }


  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }


  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }


  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
  }


  /**
   * Image.UserSchoolVerify
   */
  export type Image$UserSchoolVerifyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    where?: UserSchoolVerifyWhereInput
    orderBy?: Enumerable<UserSchoolVerifyOrderByWithRelationInput>
    cursor?: UserSchoolVerifyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserSchoolVerifyScalarFieldEnum>
  }


  /**
   * Image without action
   */
  export type ImageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ImageInclude<ExtArgs> | null
  }



  /**
   * Model PhoneVerifyRequest
   */


  export type AggregatePhoneVerifyRequest = {
    _count: PhoneVerifyRequestCountAggregateOutputType | null
    _min: PhoneVerifyRequestMinAggregateOutputType | null
    _max: PhoneVerifyRequestMaxAggregateOutputType | null
  }

  export type PhoneVerifyRequestMinAggregateOutputType = {
    id: string | null
    phone: string | null
    code: string | null
  }

  export type PhoneVerifyRequestMaxAggregateOutputType = {
    id: string | null
    phone: string | null
    code: string | null
  }

  export type PhoneVerifyRequestCountAggregateOutputType = {
    id: number
    phone: number
    code: number
    _all: number
  }


  export type PhoneVerifyRequestMinAggregateInputType = {
    id?: true
    phone?: true
    code?: true
  }

  export type PhoneVerifyRequestMaxAggregateInputType = {
    id?: true
    phone?: true
    code?: true
  }

  export type PhoneVerifyRequestCountAggregateInputType = {
    id?: true
    phone?: true
    code?: true
    _all?: true
  }

  export type PhoneVerifyRequestAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneVerifyRequest to aggregate.
     */
    where?: PhoneVerifyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerifyRequests to fetch.
     */
    orderBy?: Enumerable<PhoneVerifyRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhoneVerifyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerifyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerifyRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhoneVerifyRequests
    **/
    _count?: true | PhoneVerifyRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhoneVerifyRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhoneVerifyRequestMaxAggregateInputType
  }

  export type GetPhoneVerifyRequestAggregateType<T extends PhoneVerifyRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoneVerifyRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoneVerifyRequest[P]>
      : GetScalarType<T[P], AggregatePhoneVerifyRequest[P]>
  }




  export type PhoneVerifyRequestGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PhoneVerifyRequestWhereInput
    orderBy?: Enumerable<PhoneVerifyRequestOrderByWithAggregationInput>
    by: PhoneVerifyRequestScalarFieldEnum[]
    having?: PhoneVerifyRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhoneVerifyRequestCountAggregateInputType | true
    _min?: PhoneVerifyRequestMinAggregateInputType
    _max?: PhoneVerifyRequestMaxAggregateInputType
  }


  export type PhoneVerifyRequestGroupByOutputType = {
    id: string
    phone: string
    code: string
    _count: PhoneVerifyRequestCountAggregateOutputType | null
    _min: PhoneVerifyRequestMinAggregateOutputType | null
    _max: PhoneVerifyRequestMaxAggregateOutputType | null
  }

  type GetPhoneVerifyRequestGroupByPayload<T extends PhoneVerifyRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PhoneVerifyRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhoneVerifyRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhoneVerifyRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PhoneVerifyRequestGroupByOutputType[P]>
        }
      >
    >


  export type PhoneVerifyRequestSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phone?: boolean
    code?: boolean
  }, ExtArgs["result"]["phoneVerifyRequest"]>

  export type PhoneVerifyRequestSelectScalar = {
    id?: boolean
    phone?: boolean
    code?: boolean
  }


  type PhoneVerifyRequestGetPayload<S extends boolean | null | undefined | PhoneVerifyRequestArgs> = $Types.GetResult<PhoneVerifyRequestPayload, S>

  type PhoneVerifyRequestCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PhoneVerifyRequestFindManyArgs, 'select' | 'include'> & {
      select?: PhoneVerifyRequestCountAggregateInputType | true
    }

  export interface PhoneVerifyRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhoneVerifyRequest'], meta: { name: 'PhoneVerifyRequest' } }
    /**
     * Find zero or one PhoneVerifyRequest that matches the filter.
     * @param {PhoneVerifyRequestFindUniqueArgs} args - Arguments to find a PhoneVerifyRequest
     * @example
     * // Get one PhoneVerifyRequest
     * const phoneVerifyRequest = await prisma.phoneVerifyRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhoneVerifyRequestFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PhoneVerifyRequestFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PhoneVerifyRequest'> extends True ? Prisma__PhoneVerifyRequestClient<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PhoneVerifyRequestClient<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PhoneVerifyRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PhoneVerifyRequestFindUniqueOrThrowArgs} args - Arguments to find a PhoneVerifyRequest
     * @example
     * // Get one PhoneVerifyRequest
     * const phoneVerifyRequest = await prisma.phoneVerifyRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhoneVerifyRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhoneVerifyRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PhoneVerifyRequestClient<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PhoneVerifyRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerifyRequestFindFirstArgs} args - Arguments to find a PhoneVerifyRequest
     * @example
     * // Get one PhoneVerifyRequest
     * const phoneVerifyRequest = await prisma.phoneVerifyRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhoneVerifyRequestFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PhoneVerifyRequestFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PhoneVerifyRequest'> extends True ? Prisma__PhoneVerifyRequestClient<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PhoneVerifyRequestClient<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PhoneVerifyRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerifyRequestFindFirstOrThrowArgs} args - Arguments to find a PhoneVerifyRequest
     * @example
     * // Get one PhoneVerifyRequest
     * const phoneVerifyRequest = await prisma.phoneVerifyRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhoneVerifyRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhoneVerifyRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PhoneVerifyRequestClient<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PhoneVerifyRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerifyRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhoneVerifyRequests
     * const phoneVerifyRequests = await prisma.phoneVerifyRequest.findMany()
     * 
     * // Get first 10 PhoneVerifyRequests
     * const phoneVerifyRequests = await prisma.phoneVerifyRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phoneVerifyRequestWithIdOnly = await prisma.phoneVerifyRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhoneVerifyRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhoneVerifyRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PhoneVerifyRequest.
     * @param {PhoneVerifyRequestCreateArgs} args - Arguments to create a PhoneVerifyRequest.
     * @example
     * // Create one PhoneVerifyRequest
     * const PhoneVerifyRequest = await prisma.phoneVerifyRequest.create({
     *   data: {
     *     // ... data to create a PhoneVerifyRequest
     *   }
     * })
     * 
    **/
    create<T extends PhoneVerifyRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PhoneVerifyRequestCreateArgs<ExtArgs>>
    ): Prisma__PhoneVerifyRequestClient<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PhoneVerifyRequests.
     *     @param {PhoneVerifyRequestCreateManyArgs} args - Arguments to create many PhoneVerifyRequests.
     *     @example
     *     // Create many PhoneVerifyRequests
     *     const phoneVerifyRequest = await prisma.phoneVerifyRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PhoneVerifyRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhoneVerifyRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PhoneVerifyRequest.
     * @param {PhoneVerifyRequestDeleteArgs} args - Arguments to delete one PhoneVerifyRequest.
     * @example
     * // Delete one PhoneVerifyRequest
     * const PhoneVerifyRequest = await prisma.phoneVerifyRequest.delete({
     *   where: {
     *     // ... filter to delete one PhoneVerifyRequest
     *   }
     * })
     * 
    **/
    delete<T extends PhoneVerifyRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PhoneVerifyRequestDeleteArgs<ExtArgs>>
    ): Prisma__PhoneVerifyRequestClient<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PhoneVerifyRequest.
     * @param {PhoneVerifyRequestUpdateArgs} args - Arguments to update one PhoneVerifyRequest.
     * @example
     * // Update one PhoneVerifyRequest
     * const phoneVerifyRequest = await prisma.phoneVerifyRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhoneVerifyRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PhoneVerifyRequestUpdateArgs<ExtArgs>>
    ): Prisma__PhoneVerifyRequestClient<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PhoneVerifyRequests.
     * @param {PhoneVerifyRequestDeleteManyArgs} args - Arguments to filter PhoneVerifyRequests to delete.
     * @example
     * // Delete a few PhoneVerifyRequests
     * const { count } = await prisma.phoneVerifyRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhoneVerifyRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhoneVerifyRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhoneVerifyRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerifyRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhoneVerifyRequests
     * const phoneVerifyRequest = await prisma.phoneVerifyRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhoneVerifyRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PhoneVerifyRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhoneVerifyRequest.
     * @param {PhoneVerifyRequestUpsertArgs} args - Arguments to update or create a PhoneVerifyRequest.
     * @example
     * // Update or create a PhoneVerifyRequest
     * const phoneVerifyRequest = await prisma.phoneVerifyRequest.upsert({
     *   create: {
     *     // ... data to create a PhoneVerifyRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhoneVerifyRequest we want to update
     *   }
     * })
    **/
    upsert<T extends PhoneVerifyRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PhoneVerifyRequestUpsertArgs<ExtArgs>>
    ): Prisma__PhoneVerifyRequestClient<$Types.GetResult<PhoneVerifyRequestPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PhoneVerifyRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerifyRequestCountArgs} args - Arguments to filter PhoneVerifyRequests to count.
     * @example
     * // Count the number of PhoneVerifyRequests
     * const count = await prisma.phoneVerifyRequest.count({
     *   where: {
     *     // ... the filter for the PhoneVerifyRequests we want to count
     *   }
     * })
    **/
    count<T extends PhoneVerifyRequestCountArgs>(
      args?: Subset<T, PhoneVerifyRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhoneVerifyRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhoneVerifyRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerifyRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhoneVerifyRequestAggregateArgs>(args: Subset<T, PhoneVerifyRequestAggregateArgs>): Prisma.PrismaPromise<GetPhoneVerifyRequestAggregateType<T>>

    /**
     * Group by PhoneVerifyRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhoneVerifyRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhoneVerifyRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhoneVerifyRequestGroupByArgs['orderBy'] }
        : { orderBy?: PhoneVerifyRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhoneVerifyRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhoneVerifyRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PhoneVerifyRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PhoneVerifyRequestClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PhoneVerifyRequest base type for findUnique actions
   */
  export type PhoneVerifyRequestFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerifyRequest
     */
    select?: PhoneVerifyRequestSelect<ExtArgs> | null
    /**
     * Filter, which PhoneVerifyRequest to fetch.
     */
    where: PhoneVerifyRequestWhereUniqueInput
  }

  /**
   * PhoneVerifyRequest findUnique
   */
  export interface PhoneVerifyRequestFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PhoneVerifyRequestFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PhoneVerifyRequest findUniqueOrThrow
   */
  export type PhoneVerifyRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerifyRequest
     */
    select?: PhoneVerifyRequestSelect<ExtArgs> | null
    /**
     * Filter, which PhoneVerifyRequest to fetch.
     */
    where: PhoneVerifyRequestWhereUniqueInput
  }


  /**
   * PhoneVerifyRequest base type for findFirst actions
   */
  export type PhoneVerifyRequestFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerifyRequest
     */
    select?: PhoneVerifyRequestSelect<ExtArgs> | null
    /**
     * Filter, which PhoneVerifyRequest to fetch.
     */
    where?: PhoneVerifyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerifyRequests to fetch.
     */
    orderBy?: Enumerable<PhoneVerifyRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneVerifyRequests.
     */
    cursor?: PhoneVerifyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerifyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerifyRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneVerifyRequests.
     */
    distinct?: Enumerable<PhoneVerifyRequestScalarFieldEnum>
  }

  /**
   * PhoneVerifyRequest findFirst
   */
  export interface PhoneVerifyRequestFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PhoneVerifyRequestFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PhoneVerifyRequest findFirstOrThrow
   */
  export type PhoneVerifyRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerifyRequest
     */
    select?: PhoneVerifyRequestSelect<ExtArgs> | null
    /**
     * Filter, which PhoneVerifyRequest to fetch.
     */
    where?: PhoneVerifyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerifyRequests to fetch.
     */
    orderBy?: Enumerable<PhoneVerifyRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhoneVerifyRequests.
     */
    cursor?: PhoneVerifyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerifyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerifyRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhoneVerifyRequests.
     */
    distinct?: Enumerable<PhoneVerifyRequestScalarFieldEnum>
  }


  /**
   * PhoneVerifyRequest findMany
   */
  export type PhoneVerifyRequestFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerifyRequest
     */
    select?: PhoneVerifyRequestSelect<ExtArgs> | null
    /**
     * Filter, which PhoneVerifyRequests to fetch.
     */
    where?: PhoneVerifyRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhoneVerifyRequests to fetch.
     */
    orderBy?: Enumerable<PhoneVerifyRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhoneVerifyRequests.
     */
    cursor?: PhoneVerifyRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhoneVerifyRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhoneVerifyRequests.
     */
    skip?: number
    distinct?: Enumerable<PhoneVerifyRequestScalarFieldEnum>
  }


  /**
   * PhoneVerifyRequest create
   */
  export type PhoneVerifyRequestCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerifyRequest
     */
    select?: PhoneVerifyRequestSelect<ExtArgs> | null
    /**
     * The data needed to create a PhoneVerifyRequest.
     */
    data: XOR<PhoneVerifyRequestCreateInput, PhoneVerifyRequestUncheckedCreateInput>
  }


  /**
   * PhoneVerifyRequest createMany
   */
  export type PhoneVerifyRequestCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhoneVerifyRequests.
     */
    data: Enumerable<PhoneVerifyRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PhoneVerifyRequest update
   */
  export type PhoneVerifyRequestUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerifyRequest
     */
    select?: PhoneVerifyRequestSelect<ExtArgs> | null
    /**
     * The data needed to update a PhoneVerifyRequest.
     */
    data: XOR<PhoneVerifyRequestUpdateInput, PhoneVerifyRequestUncheckedUpdateInput>
    /**
     * Choose, which PhoneVerifyRequest to update.
     */
    where: PhoneVerifyRequestWhereUniqueInput
  }


  /**
   * PhoneVerifyRequest updateMany
   */
  export type PhoneVerifyRequestUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhoneVerifyRequests.
     */
    data: XOR<PhoneVerifyRequestUpdateManyMutationInput, PhoneVerifyRequestUncheckedUpdateManyInput>
    /**
     * Filter which PhoneVerifyRequests to update
     */
    where?: PhoneVerifyRequestWhereInput
  }


  /**
   * PhoneVerifyRequest upsert
   */
  export type PhoneVerifyRequestUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerifyRequest
     */
    select?: PhoneVerifyRequestSelect<ExtArgs> | null
    /**
     * The filter to search for the PhoneVerifyRequest to update in case it exists.
     */
    where: PhoneVerifyRequestWhereUniqueInput
    /**
     * In case the PhoneVerifyRequest found by the `where` argument doesn't exist, create a new PhoneVerifyRequest with this data.
     */
    create: XOR<PhoneVerifyRequestCreateInput, PhoneVerifyRequestUncheckedCreateInput>
    /**
     * In case the PhoneVerifyRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhoneVerifyRequestUpdateInput, PhoneVerifyRequestUncheckedUpdateInput>
  }


  /**
   * PhoneVerifyRequest delete
   */
  export type PhoneVerifyRequestDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerifyRequest
     */
    select?: PhoneVerifyRequestSelect<ExtArgs> | null
    /**
     * Filter which PhoneVerifyRequest to delete.
     */
    where: PhoneVerifyRequestWhereUniqueInput
  }


  /**
   * PhoneVerifyRequest deleteMany
   */
  export type PhoneVerifyRequestDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhoneVerifyRequests to delete
     */
    where?: PhoneVerifyRequestWhereInput
  }


  /**
   * PhoneVerifyRequest without action
   */
  export type PhoneVerifyRequestArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhoneVerifyRequest
     */
    select?: PhoneVerifyRequestSelect<ExtArgs> | null
  }



  /**
   * Model SocialLogin
   */


  export type AggregateSocialLogin = {
    _count: SocialLoginCountAggregateOutputType | null
    _min: SocialLoginMinAggregateOutputType | null
    _max: SocialLoginMaxAggregateOutputType | null
  }

  export type SocialLoginMinAggregateOutputType = {
    accessToken: string | null
    refreshToken: string | null
    userId: string | null
    socialId: string | null
    provider: SocialLoginProviderType | null
  }

  export type SocialLoginMaxAggregateOutputType = {
    accessToken: string | null
    refreshToken: string | null
    userId: string | null
    socialId: string | null
    provider: SocialLoginProviderType | null
  }

  export type SocialLoginCountAggregateOutputType = {
    accessToken: number
    refreshToken: number
    userId: number
    socialId: number
    provider: number
    _all: number
  }


  export type SocialLoginMinAggregateInputType = {
    accessToken?: true
    refreshToken?: true
    userId?: true
    socialId?: true
    provider?: true
  }

  export type SocialLoginMaxAggregateInputType = {
    accessToken?: true
    refreshToken?: true
    userId?: true
    socialId?: true
    provider?: true
  }

  export type SocialLoginCountAggregateInputType = {
    accessToken?: true
    refreshToken?: true
    userId?: true
    socialId?: true
    provider?: true
    _all?: true
  }

  export type SocialLoginAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLogin to aggregate.
     */
    where?: SocialLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLogins to fetch.
     */
    orderBy?: Enumerable<SocialLoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialLogins
    **/
    _count?: true | SocialLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialLoginMaxAggregateInputType
  }

  export type GetSocialLoginAggregateType<T extends SocialLoginAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialLogin[P]>
      : GetScalarType<T[P], AggregateSocialLogin[P]>
  }




  export type SocialLoginGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SocialLoginWhereInput
    orderBy?: Enumerable<SocialLoginOrderByWithAggregationInput>
    by: SocialLoginScalarFieldEnum[]
    having?: SocialLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialLoginCountAggregateInputType | true
    _min?: SocialLoginMinAggregateInputType
    _max?: SocialLoginMaxAggregateInputType
  }


  export type SocialLoginGroupByOutputType = {
    accessToken: string
    refreshToken: string | null
    userId: string
    socialId: string
    provider: SocialLoginProviderType
    _count: SocialLoginCountAggregateOutputType | null
    _min: SocialLoginMinAggregateOutputType | null
    _max: SocialLoginMaxAggregateOutputType | null
  }

  type GetSocialLoginGroupByPayload<T extends SocialLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SocialLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialLoginGroupByOutputType[P]>
            : GetScalarType<T[P], SocialLoginGroupByOutputType[P]>
        }
      >
    >


  export type SocialLoginSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    accessToken?: boolean
    refreshToken?: boolean
    userId?: boolean
    socialId?: boolean
    provider?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["socialLogin"]>

  export type SocialLoginSelectScalar = {
    accessToken?: boolean
    refreshToken?: boolean
    userId?: boolean
    socialId?: boolean
    provider?: boolean
  }

  export type SocialLoginInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type SocialLoginGetPayload<S extends boolean | null | undefined | SocialLoginArgs> = $Types.GetResult<SocialLoginPayload, S>

  type SocialLoginCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SocialLoginFindManyArgs, 'select' | 'include'> & {
      select?: SocialLoginCountAggregateInputType | true
    }

  export interface SocialLoginDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialLogin'], meta: { name: 'SocialLogin' } }
    /**
     * Find zero or one SocialLogin that matches the filter.
     * @param {SocialLoginFindUniqueArgs} args - Arguments to find a SocialLogin
     * @example
     * // Get one SocialLogin
     * const socialLogin = await prisma.socialLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SocialLoginFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SocialLoginFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SocialLogin'> extends True ? Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one SocialLogin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SocialLoginFindUniqueOrThrowArgs} args - Arguments to find a SocialLogin
     * @example
     * // Get one SocialLogin
     * const socialLogin = await prisma.socialLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SocialLoginFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLoginFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first SocialLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLoginFindFirstArgs} args - Arguments to find a SocialLogin
     * @example
     * // Get one SocialLogin
     * const socialLogin = await prisma.socialLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SocialLoginFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SocialLoginFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SocialLogin'> extends True ? Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first SocialLogin that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLoginFindFirstOrThrowArgs} args - Arguments to find a SocialLogin
     * @example
     * // Get one SocialLogin
     * const socialLogin = await prisma.socialLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SocialLoginFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLoginFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more SocialLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLoginFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialLogins
     * const socialLogins = await prisma.socialLogin.findMany()
     * 
     * // Get first 10 SocialLogins
     * const socialLogins = await prisma.socialLogin.findMany({ take: 10 })
     * 
     * // Only select the `accessToken`
     * const socialLoginWithAccessTokenOnly = await prisma.socialLogin.findMany({ select: { accessToken: true } })
     * 
    **/
    findMany<T extends SocialLoginFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLoginFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a SocialLogin.
     * @param {SocialLoginCreateArgs} args - Arguments to create a SocialLogin.
     * @example
     * // Create one SocialLogin
     * const SocialLogin = await prisma.socialLogin.create({
     *   data: {
     *     // ... data to create a SocialLogin
     *   }
     * })
     * 
    **/
    create<T extends SocialLoginCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLoginCreateArgs<ExtArgs>>
    ): Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many SocialLogins.
     *     @param {SocialLoginCreateManyArgs} args - Arguments to create many SocialLogins.
     *     @example
     *     // Create many SocialLogins
     *     const socialLogin = await prisma.socialLogin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SocialLoginCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLoginCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SocialLogin.
     * @param {SocialLoginDeleteArgs} args - Arguments to delete one SocialLogin.
     * @example
     * // Delete one SocialLogin
     * const SocialLogin = await prisma.socialLogin.delete({
     *   where: {
     *     // ... filter to delete one SocialLogin
     *   }
     * })
     * 
    **/
    delete<T extends SocialLoginDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLoginDeleteArgs<ExtArgs>>
    ): Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one SocialLogin.
     * @param {SocialLoginUpdateArgs} args - Arguments to update one SocialLogin.
     * @example
     * // Update one SocialLogin
     * const socialLogin = await prisma.socialLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SocialLoginUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLoginUpdateArgs<ExtArgs>>
    ): Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more SocialLogins.
     * @param {SocialLoginDeleteManyArgs} args - Arguments to filter SocialLogins to delete.
     * @example
     * // Delete a few SocialLogins
     * const { count } = await prisma.socialLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SocialLoginDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SocialLoginDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialLogins
     * const socialLogin = await prisma.socialLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SocialLoginUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLoginUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SocialLogin.
     * @param {SocialLoginUpsertArgs} args - Arguments to update or create a SocialLogin.
     * @example
     * // Update or create a SocialLogin
     * const socialLogin = await prisma.socialLogin.upsert({
     *   create: {
     *     // ... data to create a SocialLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialLogin we want to update
     *   }
     * })
    **/
    upsert<T extends SocialLoginUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SocialLoginUpsertArgs<ExtArgs>>
    ): Prisma__SocialLoginClient<$Types.GetResult<SocialLoginPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of SocialLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLoginCountArgs} args - Arguments to filter SocialLogins to count.
     * @example
     * // Count the number of SocialLogins
     * const count = await prisma.socialLogin.count({
     *   where: {
     *     // ... the filter for the SocialLogins we want to count
     *   }
     * })
    **/
    count<T extends SocialLoginCountArgs>(
      args?: Subset<T, SocialLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialLoginAggregateArgs>(args: Subset<T, SocialLoginAggregateArgs>): Prisma.PrismaPromise<GetSocialLoginAggregateType<T>>

    /**
     * Group by SocialLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialLoginGroupByArgs['orderBy'] }
        : { orderBy?: SocialLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SocialLoginClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * SocialLogin base type for findUnique actions
   */
  export type SocialLoginFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLogin
     */
    select?: SocialLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLoginInclude<ExtArgs> | null
    /**
     * Filter, which SocialLogin to fetch.
     */
    where: SocialLoginWhereUniqueInput
  }

  /**
   * SocialLogin findUnique
   */
  export interface SocialLoginFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SocialLoginFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SocialLogin findUniqueOrThrow
   */
  export type SocialLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLogin
     */
    select?: SocialLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLoginInclude<ExtArgs> | null
    /**
     * Filter, which SocialLogin to fetch.
     */
    where: SocialLoginWhereUniqueInput
  }


  /**
   * SocialLogin base type for findFirst actions
   */
  export type SocialLoginFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLogin
     */
    select?: SocialLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLoginInclude<ExtArgs> | null
    /**
     * Filter, which SocialLogin to fetch.
     */
    where?: SocialLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLogins to fetch.
     */
    orderBy?: Enumerable<SocialLoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLogins.
     */
    cursor?: SocialLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLogins.
     */
    distinct?: Enumerable<SocialLoginScalarFieldEnum>
  }

  /**
   * SocialLogin findFirst
   */
  export interface SocialLoginFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SocialLoginFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * SocialLogin findFirstOrThrow
   */
  export type SocialLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLogin
     */
    select?: SocialLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLoginInclude<ExtArgs> | null
    /**
     * Filter, which SocialLogin to fetch.
     */
    where?: SocialLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLogins to fetch.
     */
    orderBy?: Enumerable<SocialLoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialLogins.
     */
    cursor?: SocialLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialLogins.
     */
    distinct?: Enumerable<SocialLoginScalarFieldEnum>
  }


  /**
   * SocialLogin findMany
   */
  export type SocialLoginFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLogin
     */
    select?: SocialLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLoginInclude<ExtArgs> | null
    /**
     * Filter, which SocialLogins to fetch.
     */
    where?: SocialLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialLogins to fetch.
     */
    orderBy?: Enumerable<SocialLoginOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialLogins.
     */
    cursor?: SocialLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialLogins.
     */
    skip?: number
    distinct?: Enumerable<SocialLoginScalarFieldEnum>
  }


  /**
   * SocialLogin create
   */
  export type SocialLoginCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLogin
     */
    select?: SocialLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLoginInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialLogin.
     */
    data: XOR<SocialLoginCreateInput, SocialLoginUncheckedCreateInput>
  }


  /**
   * SocialLogin createMany
   */
  export type SocialLoginCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialLogins.
     */
    data: Enumerable<SocialLoginCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SocialLogin update
   */
  export type SocialLoginUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLogin
     */
    select?: SocialLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLoginInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialLogin.
     */
    data: XOR<SocialLoginUpdateInput, SocialLoginUncheckedUpdateInput>
    /**
     * Choose, which SocialLogin to update.
     */
    where: SocialLoginWhereUniqueInput
  }


  /**
   * SocialLogin updateMany
   */
  export type SocialLoginUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialLogins.
     */
    data: XOR<SocialLoginUpdateManyMutationInput, SocialLoginUncheckedUpdateManyInput>
    /**
     * Filter which SocialLogins to update
     */
    where?: SocialLoginWhereInput
  }


  /**
   * SocialLogin upsert
   */
  export type SocialLoginUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLogin
     */
    select?: SocialLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLoginInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialLogin to update in case it exists.
     */
    where: SocialLoginWhereUniqueInput
    /**
     * In case the SocialLogin found by the `where` argument doesn't exist, create a new SocialLogin with this data.
     */
    create: XOR<SocialLoginCreateInput, SocialLoginUncheckedCreateInput>
    /**
     * In case the SocialLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialLoginUpdateInput, SocialLoginUncheckedUpdateInput>
  }


  /**
   * SocialLogin delete
   */
  export type SocialLoginDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLogin
     */
    select?: SocialLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLoginInclude<ExtArgs> | null
    /**
     * Filter which SocialLogin to delete.
     */
    where: SocialLoginWhereUniqueInput
  }


  /**
   * SocialLogin deleteMany
   */
  export type SocialLoginDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialLogins to delete
     */
    where?: SocialLoginWhereInput
  }


  /**
   * SocialLogin without action
   */
  export type SocialLoginArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialLogin
     */
    select?: SocialLoginSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SocialLoginInclude<ExtArgs> | null
  }



  /**
   * Model Agreement
   */


  export type AggregateAgreement = {
    _count: AgreementCountAggregateOutputType | null
    _min: AgreementMinAggregateOutputType | null
    _max: AgreementMaxAggregateOutputType | null
  }

  export type AgreementMinAggregateOutputType = {
    updatedAt: Date | null
    userId: string | null
    receive: boolean | null
  }

  export type AgreementMaxAggregateOutputType = {
    updatedAt: Date | null
    userId: string | null
    receive: boolean | null
  }

  export type AgreementCountAggregateOutputType = {
    updatedAt: number
    userId: number
    receive: number
    _all: number
  }


  export type AgreementMinAggregateInputType = {
    updatedAt?: true
    userId?: true
    receive?: true
  }

  export type AgreementMaxAggregateInputType = {
    updatedAt?: true
    userId?: true
    receive?: true
  }

  export type AgreementCountAggregateInputType = {
    updatedAt?: true
    userId?: true
    receive?: true
    _all?: true
  }

  export type AgreementAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agreement to aggregate.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: Enumerable<AgreementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agreements
    **/
    _count?: true | AgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementMaxAggregateInputType
  }

  export type GetAgreementAggregateType<T extends AgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreement[P]>
      : GetScalarType<T[P], AggregateAgreement[P]>
  }




  export type AgreementGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AgreementWhereInput
    orderBy?: Enumerable<AgreementOrderByWithAggregationInput>
    by: AgreementScalarFieldEnum[]
    having?: AgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementCountAggregateInputType | true
    _min?: AgreementMinAggregateInputType
    _max?: AgreementMaxAggregateInputType
  }


  export type AgreementGroupByOutputType = {
    updatedAt: Date
    userId: string
    receive: boolean
    _count: AgreementCountAggregateOutputType | null
    _min: AgreementMinAggregateOutputType | null
    _max: AgreementMaxAggregateOutputType | null
  }

  type GetAgreementGroupByPayload<T extends AgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementGroupByOutputType[P]>
        }
      >
    >


  export type AgreementSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    updatedAt?: boolean
    userId?: boolean
    receive?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["agreement"]>

  export type AgreementSelectScalar = {
    updatedAt?: boolean
    userId?: boolean
    receive?: boolean
  }

  export type AgreementInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type AgreementGetPayload<S extends boolean | null | undefined | AgreementArgs> = $Types.GetResult<AgreementPayload, S>

  type AgreementCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AgreementFindManyArgs, 'select' | 'include'> & {
      select?: AgreementCountAggregateInputType | true
    }

  export interface AgreementDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agreement'], meta: { name: 'Agreement' } }
    /**
     * Find zero or one Agreement that matches the filter.
     * @param {AgreementFindUniqueArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AgreementFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AgreementFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Agreement'> extends True ? Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Agreement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AgreementFindUniqueOrThrowArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AgreementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Agreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindFirstArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AgreementFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AgreementFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Agreement'> extends True ? Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Agreement that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindFirstOrThrowArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AgreementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Agreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agreements
     * const agreements = await prisma.agreement.findMany()
     * 
     * // Get first 10 Agreements
     * const agreements = await prisma.agreement.findMany({ take: 10 })
     * 
     * // Only select the `updatedAt`
     * const agreementWithUpdatedAtOnly = await prisma.agreement.findMany({ select: { updatedAt: true } })
     * 
    **/
    findMany<T extends AgreementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Agreement.
     * @param {AgreementCreateArgs} args - Arguments to create a Agreement.
     * @example
     * // Create one Agreement
     * const Agreement = await prisma.agreement.create({
     *   data: {
     *     // ... data to create a Agreement
     *   }
     * })
     * 
    **/
    create<T extends AgreementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementCreateArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Agreements.
     *     @param {AgreementCreateManyArgs} args - Arguments to create many Agreements.
     *     @example
     *     // Create many Agreements
     *     const agreement = await prisma.agreement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AgreementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agreement.
     * @param {AgreementDeleteArgs} args - Arguments to delete one Agreement.
     * @example
     * // Delete one Agreement
     * const Agreement = await prisma.agreement.delete({
     *   where: {
     *     // ... filter to delete one Agreement
     *   }
     * })
     * 
    **/
    delete<T extends AgreementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementDeleteArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Agreement.
     * @param {AgreementUpdateArgs} args - Arguments to update one Agreement.
     * @example
     * // Update one Agreement
     * const agreement = await prisma.agreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AgreementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementUpdateArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Agreements.
     * @param {AgreementDeleteManyArgs} args - Arguments to filter Agreements to delete.
     * @example
     * // Delete a few Agreements
     * const { count } = await prisma.agreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AgreementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AgreementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agreements
     * const agreement = await prisma.agreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AgreementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agreement.
     * @param {AgreementUpsertArgs} args - Arguments to update or create a Agreement.
     * @example
     * // Update or create a Agreement
     * const agreement = await prisma.agreement.upsert({
     *   create: {
     *     // ... data to create a Agreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agreement we want to update
     *   }
     * })
    **/
    upsert<T extends AgreementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AgreementUpsertArgs<ExtArgs>>
    ): Prisma__AgreementClient<$Types.GetResult<AgreementPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Agreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementCountArgs} args - Arguments to filter Agreements to count.
     * @example
     * // Count the number of Agreements
     * const count = await prisma.agreement.count({
     *   where: {
     *     // ... the filter for the Agreements we want to count
     *   }
     * })
    **/
    count<T extends AgreementCountArgs>(
      args?: Subset<T, AgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementAggregateArgs>(args: Subset<T, AgreementAggregateArgs>): Prisma.PrismaPromise<GetAgreementAggregateType<T>>

    /**
     * Group by Agreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementGroupByArgs['orderBy'] }
        : { orderBy?: AgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Agreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AgreementClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Agreement base type for findUnique actions
   */
  export type AgreementFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement findUnique
   */
  export interface AgreementFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AgreementFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Agreement findUniqueOrThrow
   */
  export type AgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where: AgreementWhereUniqueInput
  }


  /**
   * Agreement base type for findFirst actions
   */
  export type AgreementFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: Enumerable<AgreementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agreements.
     */
    distinct?: Enumerable<AgreementScalarFieldEnum>
  }

  /**
   * Agreement findFirst
   */
  export interface AgreementFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AgreementFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Agreement findFirstOrThrow
   */
  export type AgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: Enumerable<AgreementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agreements.
     */
    distinct?: Enumerable<AgreementScalarFieldEnum>
  }


  /**
   * Agreement findMany
   */
  export type AgreementFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreements to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: Enumerable<AgreementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    distinct?: Enumerable<AgreementScalarFieldEnum>
  }


  /**
   * Agreement create
   */
  export type AgreementCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a Agreement.
     */
    data: XOR<AgreementCreateInput, AgreementUncheckedCreateInput>
  }


  /**
   * Agreement createMany
   */
  export type AgreementCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agreements.
     */
    data: Enumerable<AgreementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Agreement update
   */
  export type AgreementUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a Agreement.
     */
    data: XOR<AgreementUpdateInput, AgreementUncheckedUpdateInput>
    /**
     * Choose, which Agreement to update.
     */
    where: AgreementWhereUniqueInput
  }


  /**
   * Agreement updateMany
   */
  export type AgreementUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agreements.
     */
    data: XOR<AgreementUpdateManyMutationInput, AgreementUncheckedUpdateManyInput>
    /**
     * Filter which Agreements to update
     */
    where?: AgreementWhereInput
  }


  /**
   * Agreement upsert
   */
  export type AgreementUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the Agreement to update in case it exists.
     */
    where: AgreementWhereUniqueInput
    /**
     * In case the Agreement found by the `where` argument doesn't exist, create a new Agreement with this data.
     */
    create: XOR<AgreementCreateInput, AgreementUncheckedCreateInput>
    /**
     * In case the Agreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementUpdateInput, AgreementUncheckedUpdateInput>
  }


  /**
   * Agreement delete
   */
  export type AgreementDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter which Agreement to delete.
     */
    where: AgreementWhereUniqueInput
  }


  /**
   * Agreement deleteMany
   */
  export type AgreementDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agreements to delete
     */
    where?: AgreementWhereInput
  }


  /**
   * Agreement without action
   */
  export type AgreementArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AgreementInclude<ExtArgs> | null
  }



  /**
   * Model UserSchoolVerify
   */


  export type AggregateUserSchoolVerify = {
    _count: UserSchoolVerifyCountAggregateOutputType | null
    _min: UserSchoolVerifyMinAggregateOutputType | null
    _max: UserSchoolVerifyMaxAggregateOutputType | null
  }

  export type UserSchoolVerifyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    imageId: string | null
    schoolId: string | null
    grade: string | null
    class: string | null
    message: string | null
    process: Process | null
    createdAt: Date | null
    schoolName: string | null
    userName: string | null
    dept: string | null
  }

  export type UserSchoolVerifyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    imageId: string | null
    schoolId: string | null
    grade: string | null
    class: string | null
    message: string | null
    process: Process | null
    createdAt: Date | null
    schoolName: string | null
    userName: string | null
    dept: string | null
  }

  export type UserSchoolVerifyCountAggregateOutputType = {
    id: number
    userId: number
    imageId: number
    schoolId: number
    grade: number
    class: number
    message: number
    process: number
    createdAt: number
    schoolName: number
    userName: number
    dept: number
    _all: number
  }


  export type UserSchoolVerifyMinAggregateInputType = {
    id?: true
    userId?: true
    imageId?: true
    schoolId?: true
    grade?: true
    class?: true
    message?: true
    process?: true
    createdAt?: true
    schoolName?: true
    userName?: true
    dept?: true
  }

  export type UserSchoolVerifyMaxAggregateInputType = {
    id?: true
    userId?: true
    imageId?: true
    schoolId?: true
    grade?: true
    class?: true
    message?: true
    process?: true
    createdAt?: true
    schoolName?: true
    userName?: true
    dept?: true
  }

  export type UserSchoolVerifyCountAggregateInputType = {
    id?: true
    userId?: true
    imageId?: true
    schoolId?: true
    grade?: true
    class?: true
    message?: true
    process?: true
    createdAt?: true
    schoolName?: true
    userName?: true
    dept?: true
    _all?: true
  }

  export type UserSchoolVerifyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSchoolVerify to aggregate.
     */
    where?: UserSchoolVerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSchoolVerifies to fetch.
     */
    orderBy?: Enumerable<UserSchoolVerifyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSchoolVerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSchoolVerifies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSchoolVerifies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSchoolVerifies
    **/
    _count?: true | UserSchoolVerifyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSchoolVerifyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSchoolVerifyMaxAggregateInputType
  }

  export type GetUserSchoolVerifyAggregateType<T extends UserSchoolVerifyAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSchoolVerify]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSchoolVerify[P]>
      : GetScalarType<T[P], AggregateUserSchoolVerify[P]>
  }




  export type UserSchoolVerifyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserSchoolVerifyWhereInput
    orderBy?: Enumerable<UserSchoolVerifyOrderByWithAggregationInput>
    by: UserSchoolVerifyScalarFieldEnum[]
    having?: UserSchoolVerifyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSchoolVerifyCountAggregateInputType | true
    _min?: UserSchoolVerifyMinAggregateInputType
    _max?: UserSchoolVerifyMaxAggregateInputType
  }


  export type UserSchoolVerifyGroupByOutputType = {
    id: string
    userId: string
    imageId: string
    schoolId: string
    grade: string
    class: string
    message: string | null
    process: Process
    createdAt: Date
    schoolName: string
    userName: string
    dept: string
    _count: UserSchoolVerifyCountAggregateOutputType | null
    _min: UserSchoolVerifyMinAggregateOutputType | null
    _max: UserSchoolVerifyMaxAggregateOutputType | null
  }

  type GetUserSchoolVerifyGroupByPayload<T extends UserSchoolVerifyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserSchoolVerifyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSchoolVerifyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSchoolVerifyGroupByOutputType[P]>
            : GetScalarType<T[P], UserSchoolVerifyGroupByOutputType[P]>
        }
      >
    >


  export type UserSchoolVerifySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    imageId?: boolean
    schoolId?: boolean
    grade?: boolean
    class?: boolean
    message?: boolean
    process?: boolean
    createdAt?: boolean
    schoolName?: boolean
    userName?: boolean
    dept?: boolean
    image?: boolean | ImageArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["userSchoolVerify"]>

  export type UserSchoolVerifySelectScalar = {
    id?: boolean
    userId?: boolean
    imageId?: boolean
    schoolId?: boolean
    grade?: boolean
    class?: boolean
    message?: boolean
    process?: boolean
    createdAt?: boolean
    schoolName?: boolean
    userName?: boolean
    dept?: boolean
  }

  export type UserSchoolVerifyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    image?: boolean | ImageArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type UserSchoolVerifyGetPayload<S extends boolean | null | undefined | UserSchoolVerifyArgs> = $Types.GetResult<UserSchoolVerifyPayload, S>

  type UserSchoolVerifyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserSchoolVerifyFindManyArgs, 'select' | 'include'> & {
      select?: UserSchoolVerifyCountAggregateInputType | true
    }

  export interface UserSchoolVerifyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSchoolVerify'], meta: { name: 'UserSchoolVerify' } }
    /**
     * Find zero or one UserSchoolVerify that matches the filter.
     * @param {UserSchoolVerifyFindUniqueArgs} args - Arguments to find a UserSchoolVerify
     * @example
     * // Get one UserSchoolVerify
     * const userSchoolVerify = await prisma.userSchoolVerify.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserSchoolVerifyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserSchoolVerifyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserSchoolVerify'> extends True ? Prisma__UserSchoolVerifyClient<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserSchoolVerifyClient<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserSchoolVerify that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserSchoolVerifyFindUniqueOrThrowArgs} args - Arguments to find a UserSchoolVerify
     * @example
     * // Get one UserSchoolVerify
     * const userSchoolVerify = await prisma.userSchoolVerify.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserSchoolVerifyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSchoolVerifyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserSchoolVerifyClient<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserSchoolVerify that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolVerifyFindFirstArgs} args - Arguments to find a UserSchoolVerify
     * @example
     * // Get one UserSchoolVerify
     * const userSchoolVerify = await prisma.userSchoolVerify.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserSchoolVerifyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserSchoolVerifyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserSchoolVerify'> extends True ? Prisma__UserSchoolVerifyClient<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserSchoolVerifyClient<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserSchoolVerify that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolVerifyFindFirstOrThrowArgs} args - Arguments to find a UserSchoolVerify
     * @example
     * // Get one UserSchoolVerify
     * const userSchoolVerify = await prisma.userSchoolVerify.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserSchoolVerifyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSchoolVerifyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserSchoolVerifyClient<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserSchoolVerifies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolVerifyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSchoolVerifies
     * const userSchoolVerifies = await prisma.userSchoolVerify.findMany()
     * 
     * // Get first 10 UserSchoolVerifies
     * const userSchoolVerifies = await prisma.userSchoolVerify.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSchoolVerifyWithIdOnly = await prisma.userSchoolVerify.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserSchoolVerifyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSchoolVerifyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserSchoolVerify.
     * @param {UserSchoolVerifyCreateArgs} args - Arguments to create a UserSchoolVerify.
     * @example
     * // Create one UserSchoolVerify
     * const UserSchoolVerify = await prisma.userSchoolVerify.create({
     *   data: {
     *     // ... data to create a UserSchoolVerify
     *   }
     * })
     * 
    **/
    create<T extends UserSchoolVerifyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserSchoolVerifyCreateArgs<ExtArgs>>
    ): Prisma__UserSchoolVerifyClient<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserSchoolVerifies.
     *     @param {UserSchoolVerifyCreateManyArgs} args - Arguments to create many UserSchoolVerifies.
     *     @example
     *     // Create many UserSchoolVerifies
     *     const userSchoolVerify = await prisma.userSchoolVerify.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserSchoolVerifyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSchoolVerifyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSchoolVerify.
     * @param {UserSchoolVerifyDeleteArgs} args - Arguments to delete one UserSchoolVerify.
     * @example
     * // Delete one UserSchoolVerify
     * const UserSchoolVerify = await prisma.userSchoolVerify.delete({
     *   where: {
     *     // ... filter to delete one UserSchoolVerify
     *   }
     * })
     * 
    **/
    delete<T extends UserSchoolVerifyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserSchoolVerifyDeleteArgs<ExtArgs>>
    ): Prisma__UserSchoolVerifyClient<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserSchoolVerify.
     * @param {UserSchoolVerifyUpdateArgs} args - Arguments to update one UserSchoolVerify.
     * @example
     * // Update one UserSchoolVerify
     * const userSchoolVerify = await prisma.userSchoolVerify.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserSchoolVerifyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserSchoolVerifyUpdateArgs<ExtArgs>>
    ): Prisma__UserSchoolVerifyClient<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserSchoolVerifies.
     * @param {UserSchoolVerifyDeleteManyArgs} args - Arguments to filter UserSchoolVerifies to delete.
     * @example
     * // Delete a few UserSchoolVerifies
     * const { count } = await prisma.userSchoolVerify.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserSchoolVerifyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSchoolVerifyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSchoolVerifies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolVerifyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSchoolVerifies
     * const userSchoolVerify = await prisma.userSchoolVerify.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserSchoolVerifyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserSchoolVerifyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSchoolVerify.
     * @param {UserSchoolVerifyUpsertArgs} args - Arguments to update or create a UserSchoolVerify.
     * @example
     * // Update or create a UserSchoolVerify
     * const userSchoolVerify = await prisma.userSchoolVerify.upsert({
     *   create: {
     *     // ... data to create a UserSchoolVerify
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSchoolVerify we want to update
     *   }
     * })
    **/
    upsert<T extends UserSchoolVerifyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserSchoolVerifyUpsertArgs<ExtArgs>>
    ): Prisma__UserSchoolVerifyClient<$Types.GetResult<UserSchoolVerifyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserSchoolVerifies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolVerifyCountArgs} args - Arguments to filter UserSchoolVerifies to count.
     * @example
     * // Count the number of UserSchoolVerifies
     * const count = await prisma.userSchoolVerify.count({
     *   where: {
     *     // ... the filter for the UserSchoolVerifies we want to count
     *   }
     * })
    **/
    count<T extends UserSchoolVerifyCountArgs>(
      args?: Subset<T, UserSchoolVerifyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSchoolVerifyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSchoolVerify.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolVerifyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSchoolVerifyAggregateArgs>(args: Subset<T, UserSchoolVerifyAggregateArgs>): Prisma.PrismaPromise<GetUserSchoolVerifyAggregateType<T>>

    /**
     * Group by UserSchoolVerify.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolVerifyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSchoolVerifyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSchoolVerifyGroupByArgs['orderBy'] }
        : { orderBy?: UserSchoolVerifyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSchoolVerifyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSchoolVerifyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSchoolVerify.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserSchoolVerifyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    image<T extends ImageArgs<ExtArgs> = {}>(args?: Subset<T, ImageArgs<ExtArgs>>): Prisma__ImageClient<$Types.GetResult<ImagePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserSchoolVerify base type for findUnique actions
   */
  export type UserSchoolVerifyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    /**
     * Filter, which UserSchoolVerify to fetch.
     */
    where: UserSchoolVerifyWhereUniqueInput
  }

  /**
   * UserSchoolVerify findUnique
   */
  export interface UserSchoolVerifyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserSchoolVerifyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserSchoolVerify findUniqueOrThrow
   */
  export type UserSchoolVerifyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    /**
     * Filter, which UserSchoolVerify to fetch.
     */
    where: UserSchoolVerifyWhereUniqueInput
  }


  /**
   * UserSchoolVerify base type for findFirst actions
   */
  export type UserSchoolVerifyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    /**
     * Filter, which UserSchoolVerify to fetch.
     */
    where?: UserSchoolVerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSchoolVerifies to fetch.
     */
    orderBy?: Enumerable<UserSchoolVerifyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSchoolVerifies.
     */
    cursor?: UserSchoolVerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSchoolVerifies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSchoolVerifies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSchoolVerifies.
     */
    distinct?: Enumerable<UserSchoolVerifyScalarFieldEnum>
  }

  /**
   * UserSchoolVerify findFirst
   */
  export interface UserSchoolVerifyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserSchoolVerifyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserSchoolVerify findFirstOrThrow
   */
  export type UserSchoolVerifyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    /**
     * Filter, which UserSchoolVerify to fetch.
     */
    where?: UserSchoolVerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSchoolVerifies to fetch.
     */
    orderBy?: Enumerable<UserSchoolVerifyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSchoolVerifies.
     */
    cursor?: UserSchoolVerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSchoolVerifies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSchoolVerifies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSchoolVerifies.
     */
    distinct?: Enumerable<UserSchoolVerifyScalarFieldEnum>
  }


  /**
   * UserSchoolVerify findMany
   */
  export type UserSchoolVerifyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    /**
     * Filter, which UserSchoolVerifies to fetch.
     */
    where?: UserSchoolVerifyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSchoolVerifies to fetch.
     */
    orderBy?: Enumerable<UserSchoolVerifyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSchoolVerifies.
     */
    cursor?: UserSchoolVerifyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSchoolVerifies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSchoolVerifies.
     */
    skip?: number
    distinct?: Enumerable<UserSchoolVerifyScalarFieldEnum>
  }


  /**
   * UserSchoolVerify create
   */
  export type UserSchoolVerifyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSchoolVerify.
     */
    data: XOR<UserSchoolVerifyCreateInput, UserSchoolVerifyUncheckedCreateInput>
  }


  /**
   * UserSchoolVerify createMany
   */
  export type UserSchoolVerifyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSchoolVerifies.
     */
    data: Enumerable<UserSchoolVerifyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserSchoolVerify update
   */
  export type UserSchoolVerifyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSchoolVerify.
     */
    data: XOR<UserSchoolVerifyUpdateInput, UserSchoolVerifyUncheckedUpdateInput>
    /**
     * Choose, which UserSchoolVerify to update.
     */
    where: UserSchoolVerifyWhereUniqueInput
  }


  /**
   * UserSchoolVerify updateMany
   */
  export type UserSchoolVerifyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSchoolVerifies.
     */
    data: XOR<UserSchoolVerifyUpdateManyMutationInput, UserSchoolVerifyUncheckedUpdateManyInput>
    /**
     * Filter which UserSchoolVerifies to update
     */
    where?: UserSchoolVerifyWhereInput
  }


  /**
   * UserSchoolVerify upsert
   */
  export type UserSchoolVerifyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSchoolVerify to update in case it exists.
     */
    where: UserSchoolVerifyWhereUniqueInput
    /**
     * In case the UserSchoolVerify found by the `where` argument doesn't exist, create a new UserSchoolVerify with this data.
     */
    create: XOR<UserSchoolVerifyCreateInput, UserSchoolVerifyUncheckedCreateInput>
    /**
     * In case the UserSchoolVerify was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSchoolVerifyUpdateInput, UserSchoolVerifyUncheckedUpdateInput>
  }


  /**
   * UserSchoolVerify delete
   */
  export type UserSchoolVerifyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
    /**
     * Filter which UserSchoolVerify to delete.
     */
    where: UserSchoolVerifyWhereUniqueInput
  }


  /**
   * UserSchoolVerify deleteMany
   */
  export type UserSchoolVerifyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSchoolVerifies to delete
     */
    where?: UserSchoolVerifyWhereInput
  }


  /**
   * UserSchoolVerify without action
   */
  export type UserSchoolVerifyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchoolVerify
     */
    select?: UserSchoolVerifySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolVerifyInclude<ExtArgs> | null
  }



  /**
   * Model UserSchool
   */


  export type AggregateUserSchool = {
    _count: UserSchoolCountAggregateOutputType | null
    _min: UserSchoolMinAggregateOutputType | null
    _max: UserSchoolMaxAggregateOutputType | null
  }

  export type UserSchoolMinAggregateOutputType = {
    userId: string | null
    schoolId: string | null
    dept: string | null
    grade: string | null
    class: string | null
  }

  export type UserSchoolMaxAggregateOutputType = {
    userId: string | null
    schoolId: string | null
    dept: string | null
    grade: string | null
    class: string | null
  }

  export type UserSchoolCountAggregateOutputType = {
    userId: number
    schoolId: number
    dept: number
    grade: number
    class: number
    _all: number
  }


  export type UserSchoolMinAggregateInputType = {
    userId?: true
    schoolId?: true
    dept?: true
    grade?: true
    class?: true
  }

  export type UserSchoolMaxAggregateInputType = {
    userId?: true
    schoolId?: true
    dept?: true
    grade?: true
    class?: true
  }

  export type UserSchoolCountAggregateInputType = {
    userId?: true
    schoolId?: true
    dept?: true
    grade?: true
    class?: true
    _all?: true
  }

  export type UserSchoolAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSchool to aggregate.
     */
    where?: UserSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSchools to fetch.
     */
    orderBy?: Enumerable<UserSchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSchools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSchools
    **/
    _count?: true | UserSchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSchoolMaxAggregateInputType
  }

  export type GetUserSchoolAggregateType<T extends UserSchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSchool[P]>
      : GetScalarType<T[P], AggregateUserSchool[P]>
  }




  export type UserSchoolGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserSchoolWhereInput
    orderBy?: Enumerable<UserSchoolOrderByWithAggregationInput>
    by: UserSchoolScalarFieldEnum[]
    having?: UserSchoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSchoolCountAggregateInputType | true
    _min?: UserSchoolMinAggregateInputType
    _max?: UserSchoolMaxAggregateInputType
  }


  export type UserSchoolGroupByOutputType = {
    userId: string
    schoolId: string
    dept: string
    grade: string
    class: string
    _count: UserSchoolCountAggregateOutputType | null
    _min: UserSchoolMinAggregateOutputType | null
    _max: UserSchoolMaxAggregateOutputType | null
  }

  type GetUserSchoolGroupByPayload<T extends UserSchoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserSchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSchoolGroupByOutputType[P]>
            : GetScalarType<T[P], UserSchoolGroupByOutputType[P]>
        }
      >
    >


  export type UserSchoolSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    schoolId?: boolean
    dept?: boolean
    grade?: boolean
    class?: boolean
    school?: boolean | SchoolArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["userSchool"]>

  export type UserSchoolSelectScalar = {
    userId?: boolean
    schoolId?: boolean
    dept?: boolean
    grade?: boolean
    class?: boolean
  }

  export type UserSchoolInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    school?: boolean | SchoolArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type UserSchoolGetPayload<S extends boolean | null | undefined | UserSchoolArgs> = $Types.GetResult<UserSchoolPayload, S>

  type UserSchoolCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserSchoolFindManyArgs, 'select' | 'include'> & {
      select?: UserSchoolCountAggregateInputType | true
    }

  export interface UserSchoolDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSchool'], meta: { name: 'UserSchool' } }
    /**
     * Find zero or one UserSchool that matches the filter.
     * @param {UserSchoolFindUniqueArgs} args - Arguments to find a UserSchool
     * @example
     * // Get one UserSchool
     * const userSchool = await prisma.userSchool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserSchoolFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserSchoolFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserSchool'> extends True ? Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserSchool that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserSchoolFindUniqueOrThrowArgs} args - Arguments to find a UserSchool
     * @example
     * // Get one UserSchool
     * const userSchool = await prisma.userSchool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserSchoolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSchoolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserSchool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolFindFirstArgs} args - Arguments to find a UserSchool
     * @example
     * // Get one UserSchool
     * const userSchool = await prisma.userSchool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserSchoolFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserSchoolFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserSchool'> extends True ? Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserSchool that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolFindFirstOrThrowArgs} args - Arguments to find a UserSchool
     * @example
     * // Get one UserSchool
     * const userSchool = await prisma.userSchool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserSchoolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSchoolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserSchools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSchools
     * const userSchools = await prisma.userSchool.findMany()
     * 
     * // Get first 10 UserSchools
     * const userSchools = await prisma.userSchool.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userSchoolWithUserIdOnly = await prisma.userSchool.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends UserSchoolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSchoolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserSchool.
     * @param {UserSchoolCreateArgs} args - Arguments to create a UserSchool.
     * @example
     * // Create one UserSchool
     * const UserSchool = await prisma.userSchool.create({
     *   data: {
     *     // ... data to create a UserSchool
     *   }
     * })
     * 
    **/
    create<T extends UserSchoolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserSchoolCreateArgs<ExtArgs>>
    ): Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserSchools.
     *     @param {UserSchoolCreateManyArgs} args - Arguments to create many UserSchools.
     *     @example
     *     // Create many UserSchools
     *     const userSchool = await prisma.userSchool.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserSchoolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSchoolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSchool.
     * @param {UserSchoolDeleteArgs} args - Arguments to delete one UserSchool.
     * @example
     * // Delete one UserSchool
     * const UserSchool = await prisma.userSchool.delete({
     *   where: {
     *     // ... filter to delete one UserSchool
     *   }
     * })
     * 
    **/
    delete<T extends UserSchoolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserSchoolDeleteArgs<ExtArgs>>
    ): Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserSchool.
     * @param {UserSchoolUpdateArgs} args - Arguments to update one UserSchool.
     * @example
     * // Update one UserSchool
     * const userSchool = await prisma.userSchool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserSchoolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserSchoolUpdateArgs<ExtArgs>>
    ): Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserSchools.
     * @param {UserSchoolDeleteManyArgs} args - Arguments to filter UserSchools to delete.
     * @example
     * // Delete a few UserSchools
     * const { count } = await prisma.userSchool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserSchoolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserSchoolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSchools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSchools
     * const userSchool = await prisma.userSchool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserSchoolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserSchoolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSchool.
     * @param {UserSchoolUpsertArgs} args - Arguments to update or create a UserSchool.
     * @example
     * // Update or create a UserSchool
     * const userSchool = await prisma.userSchool.upsert({
     *   create: {
     *     // ... data to create a UserSchool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSchool we want to update
     *   }
     * })
    **/
    upsert<T extends UserSchoolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserSchoolUpsertArgs<ExtArgs>>
    ): Prisma__UserSchoolClient<$Types.GetResult<UserSchoolPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserSchools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolCountArgs} args - Arguments to filter UserSchools to count.
     * @example
     * // Count the number of UserSchools
     * const count = await prisma.userSchool.count({
     *   where: {
     *     // ... the filter for the UserSchools we want to count
     *   }
     * })
    **/
    count<T extends UserSchoolCountArgs>(
      args?: Subset<T, UserSchoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSchool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSchoolAggregateArgs>(args: Subset<T, UserSchoolAggregateArgs>): Prisma.PrismaPromise<GetUserSchoolAggregateType<T>>

    /**
     * Group by UserSchool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSchoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSchoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSchoolGroupByArgs['orderBy'] }
        : { orderBy?: UserSchoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSchoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSchool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserSchoolClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    school<T extends SchoolArgs<ExtArgs> = {}>(args?: Subset<T, SchoolArgs<ExtArgs>>): Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserSchool base type for findUnique actions
   */
  export type UserSchoolFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
    /**
     * Filter, which UserSchool to fetch.
     */
    where: UserSchoolWhereUniqueInput
  }

  /**
   * UserSchool findUnique
   */
  export interface UserSchoolFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserSchoolFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserSchool findUniqueOrThrow
   */
  export type UserSchoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
    /**
     * Filter, which UserSchool to fetch.
     */
    where: UserSchoolWhereUniqueInput
  }


  /**
   * UserSchool base type for findFirst actions
   */
  export type UserSchoolFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
    /**
     * Filter, which UserSchool to fetch.
     */
    where?: UserSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSchools to fetch.
     */
    orderBy?: Enumerable<UserSchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSchools.
     */
    cursor?: UserSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSchools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSchools.
     */
    distinct?: Enumerable<UserSchoolScalarFieldEnum>
  }

  /**
   * UserSchool findFirst
   */
  export interface UserSchoolFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserSchoolFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserSchool findFirstOrThrow
   */
  export type UserSchoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
    /**
     * Filter, which UserSchool to fetch.
     */
    where?: UserSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSchools to fetch.
     */
    orderBy?: Enumerable<UserSchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSchools.
     */
    cursor?: UserSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSchools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSchools.
     */
    distinct?: Enumerable<UserSchoolScalarFieldEnum>
  }


  /**
   * UserSchool findMany
   */
  export type UserSchoolFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
    /**
     * Filter, which UserSchools to fetch.
     */
    where?: UserSchoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSchools to fetch.
     */
    orderBy?: Enumerable<UserSchoolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSchools.
     */
    cursor?: UserSchoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSchools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSchools.
     */
    skip?: number
    distinct?: Enumerable<UserSchoolScalarFieldEnum>
  }


  /**
   * UserSchool create
   */
  export type UserSchoolCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSchool.
     */
    data: XOR<UserSchoolCreateInput, UserSchoolUncheckedCreateInput>
  }


  /**
   * UserSchool createMany
   */
  export type UserSchoolCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSchools.
     */
    data: Enumerable<UserSchoolCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserSchool update
   */
  export type UserSchoolUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSchool.
     */
    data: XOR<UserSchoolUpdateInput, UserSchoolUncheckedUpdateInput>
    /**
     * Choose, which UserSchool to update.
     */
    where: UserSchoolWhereUniqueInput
  }


  /**
   * UserSchool updateMany
   */
  export type UserSchoolUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSchools.
     */
    data: XOR<UserSchoolUpdateManyMutationInput, UserSchoolUncheckedUpdateManyInput>
    /**
     * Filter which UserSchools to update
     */
    where?: UserSchoolWhereInput
  }


  /**
   * UserSchool upsert
   */
  export type UserSchoolUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSchool to update in case it exists.
     */
    where: UserSchoolWhereUniqueInput
    /**
     * In case the UserSchool found by the `where` argument doesn't exist, create a new UserSchool with this data.
     */
    create: XOR<UserSchoolCreateInput, UserSchoolUncheckedCreateInput>
    /**
     * In case the UserSchool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSchoolUpdateInput, UserSchoolUncheckedUpdateInput>
  }


  /**
   * UserSchool delete
   */
  export type UserSchoolDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
    /**
     * Filter which UserSchool to delete.
     */
    where: UserSchoolWhereUniqueInput
  }


  /**
   * UserSchool deleteMany
   */
  export type UserSchoolDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSchools to delete
     */
    where?: UserSchoolWhereInput
  }


  /**
   * UserSchool without action
   */
  export type UserSchoolArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSchool
     */
    select?: UserSchoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserSchoolInclude<ExtArgs> | null
  }



  /**
   * Model BusStation
   */


  export type AggregateBusStation = {
    _count: BusStationCountAggregateOutputType | null
    _avg: BusStationAvgAggregateOutputType | null
    _sum: BusStationSumAggregateOutputType | null
    _min: BusStationMinAggregateOutputType | null
    _max: BusStationMaxAggregateOutputType | null
  }

  export type BusStationAvgAggregateOutputType = {
    x: number | null
    y: number | null
  }

  export type BusStationSumAggregateOutputType = {
    x: number | null
    y: number | null
  }

  export type BusStationMinAggregateOutputType = {
    busStationId: string | null
    busStationName: string | null
    address: string | null
    x: number | null
    y: number | null
  }

  export type BusStationMaxAggregateOutputType = {
    busStationId: string | null
    busStationName: string | null
    address: string | null
    x: number | null
    y: number | null
  }

  export type BusStationCountAggregateOutputType = {
    busStationId: number
    busStationName: number
    address: number
    x: number
    y: number
    _all: number
  }


  export type BusStationAvgAggregateInputType = {
    x?: true
    y?: true
  }

  export type BusStationSumAggregateInputType = {
    x?: true
    y?: true
  }

  export type BusStationMinAggregateInputType = {
    busStationId?: true
    busStationName?: true
    address?: true
    x?: true
    y?: true
  }

  export type BusStationMaxAggregateInputType = {
    busStationId?: true
    busStationName?: true
    address?: true
    x?: true
    y?: true
  }

  export type BusStationCountAggregateInputType = {
    busStationId?: true
    busStationName?: true
    address?: true
    x?: true
    y?: true
    _all?: true
  }

  export type BusStationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusStation to aggregate.
     */
    where?: BusStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusStations to fetch.
     */
    orderBy?: Enumerable<BusStationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusStations
    **/
    _count?: true | BusStationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusStationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusStationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusStationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusStationMaxAggregateInputType
  }

  export type GetBusStationAggregateType<T extends BusStationAggregateArgs> = {
        [P in keyof T & keyof AggregateBusStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusStation[P]>
      : GetScalarType<T[P], AggregateBusStation[P]>
  }




  export type BusStationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusStationWhereInput
    orderBy?: Enumerable<BusStationOrderByWithAggregationInput>
    by: BusStationScalarFieldEnum[]
    having?: BusStationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusStationCountAggregateInputType | true
    _avg?: BusStationAvgAggregateInputType
    _sum?: BusStationSumAggregateInputType
    _min?: BusStationMinAggregateInputType
    _max?: BusStationMaxAggregateInputType
  }


  export type BusStationGroupByOutputType = {
    busStationId: string
    busStationName: string
    address: string
    x: number
    y: number
    _count: BusStationCountAggregateOutputType | null
    _avg: BusStationAvgAggregateOutputType | null
    _sum: BusStationSumAggregateOutputType | null
    _min: BusStationMinAggregateOutputType | null
    _max: BusStationMaxAggregateOutputType | null
  }

  type GetBusStationGroupByPayload<T extends BusStationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusStationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusStationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusStationGroupByOutputType[P]>
            : GetScalarType<T[P], BusStationGroupByOutputType[P]>
        }
      >
    >


  export type BusStationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    busStationId?: boolean
    busStationName?: boolean
    address?: boolean
    x?: boolean
    y?: boolean
  }, ExtArgs["result"]["busStation"]>

  export type BusStationSelectScalar = {
    busStationId?: boolean
    busStationName?: boolean
    address?: boolean
    x?: boolean
    y?: boolean
  }


  type BusStationGetPayload<S extends boolean | null | undefined | BusStationArgs> = $Types.GetResult<BusStationPayload, S>

  type BusStationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BusStationFindManyArgs, 'select' | 'include'> & {
      select?: BusStationCountAggregateInputType | true
    }

  export interface BusStationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusStation'], meta: { name: 'BusStation' } }
    /**
     * Find zero or one BusStation that matches the filter.
     * @param {BusStationFindUniqueArgs} args - Arguments to find a BusStation
     * @example
     * // Get one BusStation
     * const busStation = await prisma.busStation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusStationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusStationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusStation'> extends True ? Prisma__BusStationClient<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BusStationClient<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BusStation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusStationFindUniqueOrThrowArgs} args - Arguments to find a BusStation
     * @example
     * // Get one BusStation
     * const busStation = await prisma.busStation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusStationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusStationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BusStationClient<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BusStation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusStationFindFirstArgs} args - Arguments to find a BusStation
     * @example
     * // Get one BusStation
     * const busStation = await prisma.busStation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusStationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusStationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusStation'> extends True ? Prisma__BusStationClient<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BusStationClient<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BusStation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusStationFindFirstOrThrowArgs} args - Arguments to find a BusStation
     * @example
     * // Get one BusStation
     * const busStation = await prisma.busStation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusStationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusStationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BusStationClient<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BusStations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusStationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusStations
     * const busStations = await prisma.busStation.findMany()
     * 
     * // Get first 10 BusStations
     * const busStations = await prisma.busStation.findMany({ take: 10 })
     * 
     * // Only select the `busStationId`
     * const busStationWithBusStationIdOnly = await prisma.busStation.findMany({ select: { busStationId: true } })
     * 
    **/
    findMany<T extends BusStationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusStationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BusStation.
     * @param {BusStationCreateArgs} args - Arguments to create a BusStation.
     * @example
     * // Create one BusStation
     * const BusStation = await prisma.busStation.create({
     *   data: {
     *     // ... data to create a BusStation
     *   }
     * })
     * 
    **/
    create<T extends BusStationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BusStationCreateArgs<ExtArgs>>
    ): Prisma__BusStationClient<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BusStations.
     *     @param {BusStationCreateManyArgs} args - Arguments to create many BusStations.
     *     @example
     *     // Create many BusStations
     *     const busStation = await prisma.busStation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusStationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusStationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusStation.
     * @param {BusStationDeleteArgs} args - Arguments to delete one BusStation.
     * @example
     * // Delete one BusStation
     * const BusStation = await prisma.busStation.delete({
     *   where: {
     *     // ... filter to delete one BusStation
     *   }
     * })
     * 
    **/
    delete<T extends BusStationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BusStationDeleteArgs<ExtArgs>>
    ): Prisma__BusStationClient<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BusStation.
     * @param {BusStationUpdateArgs} args - Arguments to update one BusStation.
     * @example
     * // Update one BusStation
     * const busStation = await prisma.busStation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusStationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BusStationUpdateArgs<ExtArgs>>
    ): Prisma__BusStationClient<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BusStations.
     * @param {BusStationDeleteManyArgs} args - Arguments to filter BusStations to delete.
     * @example
     * // Delete a few BusStations
     * const { count } = await prisma.busStation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusStationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusStationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusStationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusStations
     * const busStation = await prisma.busStation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusStationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BusStationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusStation.
     * @param {BusStationUpsertArgs} args - Arguments to update or create a BusStation.
     * @example
     * // Update or create a BusStation
     * const busStation = await prisma.busStation.upsert({
     *   create: {
     *     // ... data to create a BusStation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusStation we want to update
     *   }
     * })
    **/
    upsert<T extends BusStationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BusStationUpsertArgs<ExtArgs>>
    ): Prisma__BusStationClient<$Types.GetResult<BusStationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BusStations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusStationCountArgs} args - Arguments to filter BusStations to count.
     * @example
     * // Count the number of BusStations
     * const count = await prisma.busStation.count({
     *   where: {
     *     // ... the filter for the BusStations we want to count
     *   }
     * })
    **/
    count<T extends BusStationCountArgs>(
      args?: Subset<T, BusStationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusStationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusStationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusStationAggregateArgs>(args: Subset<T, BusStationAggregateArgs>): Prisma.PrismaPromise<GetBusStationAggregateType<T>>

    /**
     * Group by BusStation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusStationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusStationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusStationGroupByArgs['orderBy'] }
        : { orderBy?: BusStationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusStationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusStation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusStationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusStation base type for findUnique actions
   */
  export type BusStationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusStation
     */
    select?: BusStationSelect<ExtArgs> | null
    /**
     * Filter, which BusStation to fetch.
     */
    where: BusStationWhereUniqueInput
  }

  /**
   * BusStation findUnique
   */
  export interface BusStationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusStationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusStation findUniqueOrThrow
   */
  export type BusStationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusStation
     */
    select?: BusStationSelect<ExtArgs> | null
    /**
     * Filter, which BusStation to fetch.
     */
    where: BusStationWhereUniqueInput
  }


  /**
   * BusStation base type for findFirst actions
   */
  export type BusStationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusStation
     */
    select?: BusStationSelect<ExtArgs> | null
    /**
     * Filter, which BusStation to fetch.
     */
    where?: BusStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusStations to fetch.
     */
    orderBy?: Enumerable<BusStationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusStations.
     */
    cursor?: BusStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusStations.
     */
    distinct?: Enumerable<BusStationScalarFieldEnum>
  }

  /**
   * BusStation findFirst
   */
  export interface BusStationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusStationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusStation findFirstOrThrow
   */
  export type BusStationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusStation
     */
    select?: BusStationSelect<ExtArgs> | null
    /**
     * Filter, which BusStation to fetch.
     */
    where?: BusStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusStations to fetch.
     */
    orderBy?: Enumerable<BusStationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusStations.
     */
    cursor?: BusStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusStations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusStations.
     */
    distinct?: Enumerable<BusStationScalarFieldEnum>
  }


  /**
   * BusStation findMany
   */
  export type BusStationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusStation
     */
    select?: BusStationSelect<ExtArgs> | null
    /**
     * Filter, which BusStations to fetch.
     */
    where?: BusStationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusStations to fetch.
     */
    orderBy?: Enumerable<BusStationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusStations.
     */
    cursor?: BusStationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusStations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusStations.
     */
    skip?: number
    distinct?: Enumerable<BusStationScalarFieldEnum>
  }


  /**
   * BusStation create
   */
  export type BusStationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusStation
     */
    select?: BusStationSelect<ExtArgs> | null
    /**
     * The data needed to create a BusStation.
     */
    data: XOR<BusStationCreateInput, BusStationUncheckedCreateInput>
  }


  /**
   * BusStation createMany
   */
  export type BusStationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusStations.
     */
    data: Enumerable<BusStationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusStation update
   */
  export type BusStationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusStation
     */
    select?: BusStationSelect<ExtArgs> | null
    /**
     * The data needed to update a BusStation.
     */
    data: XOR<BusStationUpdateInput, BusStationUncheckedUpdateInput>
    /**
     * Choose, which BusStation to update.
     */
    where: BusStationWhereUniqueInput
  }


  /**
   * BusStation updateMany
   */
  export type BusStationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusStations.
     */
    data: XOR<BusStationUpdateManyMutationInput, BusStationUncheckedUpdateManyInput>
    /**
     * Filter which BusStations to update
     */
    where?: BusStationWhereInput
  }


  /**
   * BusStation upsert
   */
  export type BusStationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusStation
     */
    select?: BusStationSelect<ExtArgs> | null
    /**
     * The filter to search for the BusStation to update in case it exists.
     */
    where: BusStationWhereUniqueInput
    /**
     * In case the BusStation found by the `where` argument doesn't exist, create a new BusStation with this data.
     */
    create: XOR<BusStationCreateInput, BusStationUncheckedCreateInput>
    /**
     * In case the BusStation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusStationUpdateInput, BusStationUncheckedUpdateInput>
  }


  /**
   * BusStation delete
   */
  export type BusStationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusStation
     */
    select?: BusStationSelect<ExtArgs> | null
    /**
     * Filter which BusStation to delete.
     */
    where: BusStationWhereUniqueInput
  }


  /**
   * BusStation deleteMany
   */
  export type BusStationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusStations to delete
     */
    where?: BusStationWhereInput
  }


  /**
   * BusStation without action
   */
  export type BusStationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusStation
     */
    select?: BusStationSelect<ExtArgs> | null
  }



  /**
   * Model BusRoute
   */


  export type AggregateBusRoute = {
    _count: BusRouteCountAggregateOutputType | null
    _min: BusRouteMinAggregateOutputType | null
    _max: BusRouteMaxAggregateOutputType | null
  }

  export type BusRouteMinAggregateOutputType = {
    busRouteId: string | null
    busRouteNum: string | null
    busRouteTp: string | null
    endNodeName: string | null
    startNodeName: string | null
    endVehicleTime: string | null
    startVehicleTime: string | null
    intervalTime: string | null
    intervalSatTime: string | null
    intervalSunTime: string | null
  }

  export type BusRouteMaxAggregateOutputType = {
    busRouteId: string | null
    busRouteNum: string | null
    busRouteTp: string | null
    endNodeName: string | null
    startNodeName: string | null
    endVehicleTime: string | null
    startVehicleTime: string | null
    intervalTime: string | null
    intervalSatTime: string | null
    intervalSunTime: string | null
  }

  export type BusRouteCountAggregateOutputType = {
    busRouteId: number
    busRouteNum: number
    busRouteTp: number
    endNodeName: number
    startNodeName: number
    endVehicleTime: number
    startVehicleTime: number
    intervalTime: number
    intervalSatTime: number
    intervalSunTime: number
    _all: number
  }


  export type BusRouteMinAggregateInputType = {
    busRouteId?: true
    busRouteNum?: true
    busRouteTp?: true
    endNodeName?: true
    startNodeName?: true
    endVehicleTime?: true
    startVehicleTime?: true
    intervalTime?: true
    intervalSatTime?: true
    intervalSunTime?: true
  }

  export type BusRouteMaxAggregateInputType = {
    busRouteId?: true
    busRouteNum?: true
    busRouteTp?: true
    endNodeName?: true
    startNodeName?: true
    endVehicleTime?: true
    startVehicleTime?: true
    intervalTime?: true
    intervalSatTime?: true
    intervalSunTime?: true
  }

  export type BusRouteCountAggregateInputType = {
    busRouteId?: true
    busRouteNum?: true
    busRouteTp?: true
    endNodeName?: true
    startNodeName?: true
    endVehicleTime?: true
    startVehicleTime?: true
    intervalTime?: true
    intervalSatTime?: true
    intervalSunTime?: true
    _all?: true
  }

  export type BusRouteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusRoute to aggregate.
     */
    where?: BusRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRoutes to fetch.
     */
    orderBy?: Enumerable<BusRouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusRoutes
    **/
    _count?: true | BusRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusRouteMaxAggregateInputType
  }

  export type GetBusRouteAggregateType<T extends BusRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateBusRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusRoute[P]>
      : GetScalarType<T[P], AggregateBusRoute[P]>
  }




  export type BusRouteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusRouteWhereInput
    orderBy?: Enumerable<BusRouteOrderByWithAggregationInput>
    by: BusRouteScalarFieldEnum[]
    having?: BusRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusRouteCountAggregateInputType | true
    _min?: BusRouteMinAggregateInputType
    _max?: BusRouteMaxAggregateInputType
  }


  export type BusRouteGroupByOutputType = {
    busRouteId: string
    busRouteNum: string
    busRouteTp: string
    endNodeName: string
    startNodeName: string
    endVehicleTime: string
    startVehicleTime: string
    intervalTime: string
    intervalSatTime: string
    intervalSunTime: string
    _count: BusRouteCountAggregateOutputType | null
    _min: BusRouteMinAggregateOutputType | null
    _max: BusRouteMaxAggregateOutputType | null
  }

  type GetBusRouteGroupByPayload<T extends BusRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusRouteGroupByOutputType[P]>
            : GetScalarType<T[P], BusRouteGroupByOutputType[P]>
        }
      >
    >


  export type BusRouteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    busRouteId?: boolean
    busRouteNum?: boolean
    busRouteTp?: boolean
    endNodeName?: boolean
    startNodeName?: boolean
    endVehicleTime?: boolean
    startVehicleTime?: boolean
    intervalTime?: boolean
    intervalSatTime?: boolean
    intervalSunTime?: boolean
  }, ExtArgs["result"]["busRoute"]>

  export type BusRouteSelectScalar = {
    busRouteId?: boolean
    busRouteNum?: boolean
    busRouteTp?: boolean
    endNodeName?: boolean
    startNodeName?: boolean
    endVehicleTime?: boolean
    startVehicleTime?: boolean
    intervalTime?: boolean
    intervalSatTime?: boolean
    intervalSunTime?: boolean
  }


  type BusRouteGetPayload<S extends boolean | null | undefined | BusRouteArgs> = $Types.GetResult<BusRoutePayload, S>

  type BusRouteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BusRouteFindManyArgs, 'select' | 'include'> & {
      select?: BusRouteCountAggregateInputType | true
    }

  export interface BusRouteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusRoute'], meta: { name: 'BusRoute' } }
    /**
     * Find zero or one BusRoute that matches the filter.
     * @param {BusRouteFindUniqueArgs} args - Arguments to find a BusRoute
     * @example
     * // Get one BusRoute
     * const busRoute = await prisma.busRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusRouteFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusRouteFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusRoute'> extends True ? Prisma__BusRouteClient<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BusRouteClient<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BusRoute that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusRouteFindUniqueOrThrowArgs} args - Arguments to find a BusRoute
     * @example
     * // Get one BusRoute
     * const busRoute = await prisma.busRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusRouteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusRouteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BusRouteClient<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BusRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteFindFirstArgs} args - Arguments to find a BusRoute
     * @example
     * // Get one BusRoute
     * const busRoute = await prisma.busRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusRouteFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusRouteFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusRoute'> extends True ? Prisma__BusRouteClient<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BusRouteClient<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BusRoute that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteFindFirstOrThrowArgs} args - Arguments to find a BusRoute
     * @example
     * // Get one BusRoute
     * const busRoute = await prisma.busRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusRouteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusRouteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BusRouteClient<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BusRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusRoutes
     * const busRoutes = await prisma.busRoute.findMany()
     * 
     * // Get first 10 BusRoutes
     * const busRoutes = await prisma.busRoute.findMany({ take: 10 })
     * 
     * // Only select the `busRouteId`
     * const busRouteWithBusRouteIdOnly = await prisma.busRoute.findMany({ select: { busRouteId: true } })
     * 
    **/
    findMany<T extends BusRouteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusRouteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BusRoute.
     * @param {BusRouteCreateArgs} args - Arguments to create a BusRoute.
     * @example
     * // Create one BusRoute
     * const BusRoute = await prisma.busRoute.create({
     *   data: {
     *     // ... data to create a BusRoute
     *   }
     * })
     * 
    **/
    create<T extends BusRouteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BusRouteCreateArgs<ExtArgs>>
    ): Prisma__BusRouteClient<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BusRoutes.
     *     @param {BusRouteCreateManyArgs} args - Arguments to create many BusRoutes.
     *     @example
     *     // Create many BusRoutes
     *     const busRoute = await prisma.busRoute.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusRouteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusRouteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusRoute.
     * @param {BusRouteDeleteArgs} args - Arguments to delete one BusRoute.
     * @example
     * // Delete one BusRoute
     * const BusRoute = await prisma.busRoute.delete({
     *   where: {
     *     // ... filter to delete one BusRoute
     *   }
     * })
     * 
    **/
    delete<T extends BusRouteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BusRouteDeleteArgs<ExtArgs>>
    ): Prisma__BusRouteClient<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BusRoute.
     * @param {BusRouteUpdateArgs} args - Arguments to update one BusRoute.
     * @example
     * // Update one BusRoute
     * const busRoute = await prisma.busRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusRouteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BusRouteUpdateArgs<ExtArgs>>
    ): Prisma__BusRouteClient<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BusRoutes.
     * @param {BusRouteDeleteManyArgs} args - Arguments to filter BusRoutes to delete.
     * @example
     * // Delete a few BusRoutes
     * const { count } = await prisma.busRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusRouteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusRouteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusRoutes
     * const busRoute = await prisma.busRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusRouteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BusRouteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusRoute.
     * @param {BusRouteUpsertArgs} args - Arguments to update or create a BusRoute.
     * @example
     * // Update or create a BusRoute
     * const busRoute = await prisma.busRoute.upsert({
     *   create: {
     *     // ... data to create a BusRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusRoute we want to update
     *   }
     * })
    **/
    upsert<T extends BusRouteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BusRouteUpsertArgs<ExtArgs>>
    ): Prisma__BusRouteClient<$Types.GetResult<BusRoutePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BusRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteCountArgs} args - Arguments to filter BusRoutes to count.
     * @example
     * // Count the number of BusRoutes
     * const count = await prisma.busRoute.count({
     *   where: {
     *     // ... the filter for the BusRoutes we want to count
     *   }
     * })
    **/
    count<T extends BusRouteCountArgs>(
      args?: Subset<T, BusRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusRouteAggregateArgs>(args: Subset<T, BusRouteAggregateArgs>): Prisma.PrismaPromise<GetBusRouteAggregateType<T>>

    /**
     * Group by BusRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusRouteGroupByArgs['orderBy'] }
        : { orderBy?: BusRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusRouteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusRoute base type for findUnique actions
   */
  export type BusRouteFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Filter, which BusRoute to fetch.
     */
    where: BusRouteWhereUniqueInput
  }

  /**
   * BusRoute findUnique
   */
  export interface BusRouteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusRouteFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusRoute findUniqueOrThrow
   */
  export type BusRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Filter, which BusRoute to fetch.
     */
    where: BusRouteWhereUniqueInput
  }


  /**
   * BusRoute base type for findFirst actions
   */
  export type BusRouteFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Filter, which BusRoute to fetch.
     */
    where?: BusRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRoutes to fetch.
     */
    orderBy?: Enumerable<BusRouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusRoutes.
     */
    cursor?: BusRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusRoutes.
     */
    distinct?: Enumerable<BusRouteScalarFieldEnum>
  }

  /**
   * BusRoute findFirst
   */
  export interface BusRouteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusRouteFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusRoute findFirstOrThrow
   */
  export type BusRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Filter, which BusRoute to fetch.
     */
    where?: BusRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRoutes to fetch.
     */
    orderBy?: Enumerable<BusRouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusRoutes.
     */
    cursor?: BusRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusRoutes.
     */
    distinct?: Enumerable<BusRouteScalarFieldEnum>
  }


  /**
   * BusRoute findMany
   */
  export type BusRouteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Filter, which BusRoutes to fetch.
     */
    where?: BusRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusRoutes to fetch.
     */
    orderBy?: Enumerable<BusRouteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusRoutes.
     */
    cursor?: BusRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusRoutes.
     */
    skip?: number
    distinct?: Enumerable<BusRouteScalarFieldEnum>
  }


  /**
   * BusRoute create
   */
  export type BusRouteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * The data needed to create a BusRoute.
     */
    data: XOR<BusRouteCreateInput, BusRouteUncheckedCreateInput>
  }


  /**
   * BusRoute createMany
   */
  export type BusRouteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusRoutes.
     */
    data: Enumerable<BusRouteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusRoute update
   */
  export type BusRouteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * The data needed to update a BusRoute.
     */
    data: XOR<BusRouteUpdateInput, BusRouteUncheckedUpdateInput>
    /**
     * Choose, which BusRoute to update.
     */
    where: BusRouteWhereUniqueInput
  }


  /**
   * BusRoute updateMany
   */
  export type BusRouteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusRoutes.
     */
    data: XOR<BusRouteUpdateManyMutationInput, BusRouteUncheckedUpdateManyInput>
    /**
     * Filter which BusRoutes to update
     */
    where?: BusRouteWhereInput
  }


  /**
   * BusRoute upsert
   */
  export type BusRouteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * The filter to search for the BusRoute to update in case it exists.
     */
    where: BusRouteWhereUniqueInput
    /**
     * In case the BusRoute found by the `where` argument doesn't exist, create a new BusRoute with this data.
     */
    create: XOR<BusRouteCreateInput, BusRouteUncheckedCreateInput>
    /**
     * In case the BusRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusRouteUpdateInput, BusRouteUncheckedUpdateInput>
  }


  /**
   * BusRoute delete
   */
  export type BusRouteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
    /**
     * Filter which BusRoute to delete.
     */
    where: BusRouteWhereUniqueInput
  }


  /**
   * BusRoute deleteMany
   */
  export type BusRouteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusRoutes to delete
     */
    where?: BusRouteWhereInput
  }


  /**
   * BusRoute without action
   */
  export type BusRouteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusRoute
     */
    select?: BusRouteSelect<ExtArgs> | null
  }



  /**
   * Model BusArrival
   */


  export type AggregateBusArrival = {
    _count: BusArrivalCountAggregateOutputType | null
    _min: BusArrivalMinAggregateOutputType | null
    _max: BusArrivalMaxAggregateOutputType | null
  }

  export type BusArrivalMinAggregateOutputType = {
    busStationId: string | null
    busStationName: string | null
    busRouteNum: string | null
    busRouteTp: string | null
    arrprevStationCnt: string | null
    arrTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusArrivalMaxAggregateOutputType = {
    busStationId: string | null
    busStationName: string | null
    busRouteNum: string | null
    busRouteTp: string | null
    arrprevStationCnt: string | null
    arrTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusArrivalCountAggregateOutputType = {
    busStationId: number
    busStationName: number
    busRouteNum: number
    busRouteTp: number
    arrprevStationCnt: number
    arrTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusArrivalMinAggregateInputType = {
    busStationId?: true
    busStationName?: true
    busRouteNum?: true
    busRouteTp?: true
    arrprevStationCnt?: true
    arrTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusArrivalMaxAggregateInputType = {
    busStationId?: true
    busStationName?: true
    busRouteNum?: true
    busRouteTp?: true
    arrprevStationCnt?: true
    arrTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusArrivalCountAggregateInputType = {
    busStationId?: true
    busStationName?: true
    busRouteNum?: true
    busRouteTp?: true
    arrprevStationCnt?: true
    arrTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusArrivalAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusArrival to aggregate.
     */
    where?: BusArrivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusArrivals to fetch.
     */
    orderBy?: Enumerable<BusArrivalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusArrivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusArrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusArrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusArrivals
    **/
    _count?: true | BusArrivalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusArrivalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusArrivalMaxAggregateInputType
  }

  export type GetBusArrivalAggregateType<T extends BusArrivalAggregateArgs> = {
        [P in keyof T & keyof AggregateBusArrival]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusArrival[P]>
      : GetScalarType<T[P], AggregateBusArrival[P]>
  }




  export type BusArrivalGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BusArrivalWhereInput
    orderBy?: Enumerable<BusArrivalOrderByWithAggregationInput>
    by: BusArrivalScalarFieldEnum[]
    having?: BusArrivalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusArrivalCountAggregateInputType | true
    _min?: BusArrivalMinAggregateInputType
    _max?: BusArrivalMaxAggregateInputType
  }


  export type BusArrivalGroupByOutputType = {
    busStationId: string
    busStationName: string
    busRouteNum: string
    busRouteTp: string
    arrprevStationCnt: string
    arrTime: string
    createdAt: Date
    updatedAt: Date
    _count: BusArrivalCountAggregateOutputType | null
    _min: BusArrivalMinAggregateOutputType | null
    _max: BusArrivalMaxAggregateOutputType | null
  }

  type GetBusArrivalGroupByPayload<T extends BusArrivalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BusArrivalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusArrivalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusArrivalGroupByOutputType[P]>
            : GetScalarType<T[P], BusArrivalGroupByOutputType[P]>
        }
      >
    >


  export type BusArrivalSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    busStationId?: boolean
    busStationName?: boolean
    busRouteNum?: boolean
    busRouteTp?: boolean
    arrprevStationCnt?: boolean
    arrTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["busArrival"]>

  export type BusArrivalSelectScalar = {
    busStationId?: boolean
    busStationName?: boolean
    busRouteNum?: boolean
    busRouteTp?: boolean
    arrprevStationCnt?: boolean
    arrTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  type BusArrivalGetPayload<S extends boolean | null | undefined | BusArrivalArgs> = $Types.GetResult<BusArrivalPayload, S>

  type BusArrivalCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BusArrivalFindManyArgs, 'select' | 'include'> & {
      select?: BusArrivalCountAggregateInputType | true
    }

  export interface BusArrivalDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusArrival'], meta: { name: 'BusArrival' } }
    /**
     * Find zero or one BusArrival that matches the filter.
     * @param {BusArrivalFindUniqueArgs} args - Arguments to find a BusArrival
     * @example
     * // Get one BusArrival
     * const busArrival = await prisma.busArrival.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BusArrivalFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BusArrivalFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BusArrival'> extends True ? Prisma__BusArrivalClient<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BusArrivalClient<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BusArrival that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BusArrivalFindUniqueOrThrowArgs} args - Arguments to find a BusArrival
     * @example
     * // Get one BusArrival
     * const busArrival = await prisma.busArrival.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BusArrivalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusArrivalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BusArrivalClient<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BusArrival that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusArrivalFindFirstArgs} args - Arguments to find a BusArrival
     * @example
     * // Get one BusArrival
     * const busArrival = await prisma.busArrival.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BusArrivalFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BusArrivalFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BusArrival'> extends True ? Prisma__BusArrivalClient<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BusArrivalClient<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BusArrival that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusArrivalFindFirstOrThrowArgs} args - Arguments to find a BusArrival
     * @example
     * // Get one BusArrival
     * const busArrival = await prisma.busArrival.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BusArrivalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BusArrivalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BusArrivalClient<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BusArrivals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusArrivalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusArrivals
     * const busArrivals = await prisma.busArrival.findMany()
     * 
     * // Get first 10 BusArrivals
     * const busArrivals = await prisma.busArrival.findMany({ take: 10 })
     * 
     * // Only select the `busStationId`
     * const busArrivalWithBusStationIdOnly = await prisma.busArrival.findMany({ select: { busStationId: true } })
     * 
    **/
    findMany<T extends BusArrivalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusArrivalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BusArrival.
     * @param {BusArrivalCreateArgs} args - Arguments to create a BusArrival.
     * @example
     * // Create one BusArrival
     * const BusArrival = await prisma.busArrival.create({
     *   data: {
     *     // ... data to create a BusArrival
     *   }
     * })
     * 
    **/
    create<T extends BusArrivalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BusArrivalCreateArgs<ExtArgs>>
    ): Prisma__BusArrivalClient<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BusArrivals.
     *     @param {BusArrivalCreateManyArgs} args - Arguments to create many BusArrivals.
     *     @example
     *     // Create many BusArrivals
     *     const busArrival = await prisma.busArrival.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BusArrivalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusArrivalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BusArrival.
     * @param {BusArrivalDeleteArgs} args - Arguments to delete one BusArrival.
     * @example
     * // Delete one BusArrival
     * const BusArrival = await prisma.busArrival.delete({
     *   where: {
     *     // ... filter to delete one BusArrival
     *   }
     * })
     * 
    **/
    delete<T extends BusArrivalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BusArrivalDeleteArgs<ExtArgs>>
    ): Prisma__BusArrivalClient<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BusArrival.
     * @param {BusArrivalUpdateArgs} args - Arguments to update one BusArrival.
     * @example
     * // Update one BusArrival
     * const busArrival = await prisma.busArrival.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BusArrivalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BusArrivalUpdateArgs<ExtArgs>>
    ): Prisma__BusArrivalClient<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BusArrivals.
     * @param {BusArrivalDeleteManyArgs} args - Arguments to filter BusArrivals to delete.
     * @example
     * // Delete a few BusArrivals
     * const { count } = await prisma.busArrival.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BusArrivalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BusArrivalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusArrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusArrivalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusArrivals
     * const busArrival = await prisma.busArrival.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BusArrivalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BusArrivalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BusArrival.
     * @param {BusArrivalUpsertArgs} args - Arguments to update or create a BusArrival.
     * @example
     * // Update or create a BusArrival
     * const busArrival = await prisma.busArrival.upsert({
     *   create: {
     *     // ... data to create a BusArrival
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusArrival we want to update
     *   }
     * })
    **/
    upsert<T extends BusArrivalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BusArrivalUpsertArgs<ExtArgs>>
    ): Prisma__BusArrivalClient<$Types.GetResult<BusArrivalPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BusArrivals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusArrivalCountArgs} args - Arguments to filter BusArrivals to count.
     * @example
     * // Count the number of BusArrivals
     * const count = await prisma.busArrival.count({
     *   where: {
     *     // ... the filter for the BusArrivals we want to count
     *   }
     * })
    **/
    count<T extends BusArrivalCountArgs>(
      args?: Subset<T, BusArrivalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusArrivalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusArrival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusArrivalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusArrivalAggregateArgs>(args: Subset<T, BusArrivalAggregateArgs>): Prisma.PrismaPromise<GetBusArrivalAggregateType<T>>

    /**
     * Group by BusArrival.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusArrivalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusArrivalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusArrivalGroupByArgs['orderBy'] }
        : { orderBy?: BusArrivalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusArrivalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusArrivalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BusArrival.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BusArrivalClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BusArrival base type for findUnique actions
   */
  export type BusArrivalFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusArrival
     */
    select?: BusArrivalSelect<ExtArgs> | null
    /**
     * Filter, which BusArrival to fetch.
     */
    where: BusArrivalWhereUniqueInput
  }

  /**
   * BusArrival findUnique
   */
  export interface BusArrivalFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusArrivalFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusArrival findUniqueOrThrow
   */
  export type BusArrivalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusArrival
     */
    select?: BusArrivalSelect<ExtArgs> | null
    /**
     * Filter, which BusArrival to fetch.
     */
    where: BusArrivalWhereUniqueInput
  }


  /**
   * BusArrival base type for findFirst actions
   */
  export type BusArrivalFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusArrival
     */
    select?: BusArrivalSelect<ExtArgs> | null
    /**
     * Filter, which BusArrival to fetch.
     */
    where?: BusArrivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusArrivals to fetch.
     */
    orderBy?: Enumerable<BusArrivalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusArrivals.
     */
    cursor?: BusArrivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusArrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusArrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusArrivals.
     */
    distinct?: Enumerable<BusArrivalScalarFieldEnum>
  }

  /**
   * BusArrival findFirst
   */
  export interface BusArrivalFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BusArrivalFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BusArrival findFirstOrThrow
   */
  export type BusArrivalFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusArrival
     */
    select?: BusArrivalSelect<ExtArgs> | null
    /**
     * Filter, which BusArrival to fetch.
     */
    where?: BusArrivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusArrivals to fetch.
     */
    orderBy?: Enumerable<BusArrivalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusArrivals.
     */
    cursor?: BusArrivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusArrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusArrivals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusArrivals.
     */
    distinct?: Enumerable<BusArrivalScalarFieldEnum>
  }


  /**
   * BusArrival findMany
   */
  export type BusArrivalFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusArrival
     */
    select?: BusArrivalSelect<ExtArgs> | null
    /**
     * Filter, which BusArrivals to fetch.
     */
    where?: BusArrivalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusArrivals to fetch.
     */
    orderBy?: Enumerable<BusArrivalOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusArrivals.
     */
    cursor?: BusArrivalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusArrivals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusArrivals.
     */
    skip?: number
    distinct?: Enumerable<BusArrivalScalarFieldEnum>
  }


  /**
   * BusArrival create
   */
  export type BusArrivalCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusArrival
     */
    select?: BusArrivalSelect<ExtArgs> | null
    /**
     * The data needed to create a BusArrival.
     */
    data: XOR<BusArrivalCreateInput, BusArrivalUncheckedCreateInput>
  }


  /**
   * BusArrival createMany
   */
  export type BusArrivalCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusArrivals.
     */
    data: Enumerable<BusArrivalCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BusArrival update
   */
  export type BusArrivalUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusArrival
     */
    select?: BusArrivalSelect<ExtArgs> | null
    /**
     * The data needed to update a BusArrival.
     */
    data: XOR<BusArrivalUpdateInput, BusArrivalUncheckedUpdateInput>
    /**
     * Choose, which BusArrival to update.
     */
    where: BusArrivalWhereUniqueInput
  }


  /**
   * BusArrival updateMany
   */
  export type BusArrivalUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusArrivals.
     */
    data: XOR<BusArrivalUpdateManyMutationInput, BusArrivalUncheckedUpdateManyInput>
    /**
     * Filter which BusArrivals to update
     */
    where?: BusArrivalWhereInput
  }


  /**
   * BusArrival upsert
   */
  export type BusArrivalUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusArrival
     */
    select?: BusArrivalSelect<ExtArgs> | null
    /**
     * The filter to search for the BusArrival to update in case it exists.
     */
    where: BusArrivalWhereUniqueInput
    /**
     * In case the BusArrival found by the `where` argument doesn't exist, create a new BusArrival with this data.
     */
    create: XOR<BusArrivalCreateInput, BusArrivalUncheckedCreateInput>
    /**
     * In case the BusArrival was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusArrivalUpdateInput, BusArrivalUncheckedUpdateInput>
  }


  /**
   * BusArrival delete
   */
  export type BusArrivalDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusArrival
     */
    select?: BusArrivalSelect<ExtArgs> | null
    /**
     * Filter which BusArrival to delete.
     */
    where: BusArrivalWhereUniqueInput
  }


  /**
   * BusArrival deleteMany
   */
  export type BusArrivalDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusArrivals to delete
     */
    where?: BusArrivalWhereInput
  }


  /**
   * BusArrival without action
   */
  export type BusArrivalArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusArrival
     */
    select?: BusArrivalSelect<ExtArgs> | null
  }



  /**
   * Model AskedUser
   */


  export type AggregateAskedUser = {
    _count: AskedUserCountAggregateOutputType | null
    _min: AskedUserMinAggregateOutputType | null
    _max: AskedUserMaxAggregateOutputType | null
  }

  export type AskedUserMinAggregateOutputType = {
    userId: string | null
    customId: string | null
    statusMessage: string | null
    receiveAnonymous: boolean | null
    receiveOtherSchool: boolean | null
    lastUpdateCustomId: Date | null
  }

  export type AskedUserMaxAggregateOutputType = {
    userId: string | null
    customId: string | null
    statusMessage: string | null
    receiveAnonymous: boolean | null
    receiveOtherSchool: boolean | null
    lastUpdateCustomId: Date | null
  }

  export type AskedUserCountAggregateOutputType = {
    userId: number
    customId: number
    statusMessage: number
    receiveAnonymous: number
    receiveOtherSchool: number
    lastUpdateCustomId: number
    _all: number
  }


  export type AskedUserMinAggregateInputType = {
    userId?: true
    customId?: true
    statusMessage?: true
    receiveAnonymous?: true
    receiveOtherSchool?: true
    lastUpdateCustomId?: true
  }

  export type AskedUserMaxAggregateInputType = {
    userId?: true
    customId?: true
    statusMessage?: true
    receiveAnonymous?: true
    receiveOtherSchool?: true
    lastUpdateCustomId?: true
  }

  export type AskedUserCountAggregateInputType = {
    userId?: true
    customId?: true
    statusMessage?: true
    receiveAnonymous?: true
    receiveOtherSchool?: true
    lastUpdateCustomId?: true
    _all?: true
  }

  export type AskedUserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AskedUser to aggregate.
     */
    where?: AskedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AskedUsers to fetch.
     */
    orderBy?: Enumerable<AskedUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AskedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AskedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AskedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AskedUsers
    **/
    _count?: true | AskedUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AskedUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AskedUserMaxAggregateInputType
  }

  export type GetAskedUserAggregateType<T extends AskedUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAskedUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAskedUser[P]>
      : GetScalarType<T[P], AggregateAskedUser[P]>
  }




  export type AskedUserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AskedUserWhereInput
    orderBy?: Enumerable<AskedUserOrderByWithAggregationInput>
    by: AskedUserScalarFieldEnum[]
    having?: AskedUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AskedUserCountAggregateInputType | true
    _min?: AskedUserMinAggregateInputType
    _max?: AskedUserMaxAggregateInputType
  }


  export type AskedUserGroupByOutputType = {
    userId: string
    customId: string | null
    statusMessage: string | null
    receiveAnonymous: boolean
    receiveOtherSchool: boolean
    lastUpdateCustomId: Date | null
    _count: AskedUserCountAggregateOutputType | null
    _min: AskedUserMinAggregateOutputType | null
    _max: AskedUserMaxAggregateOutputType | null
  }

  type GetAskedUserGroupByPayload<T extends AskedUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AskedUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AskedUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AskedUserGroupByOutputType[P]>
            : GetScalarType<T[P], AskedUserGroupByOutputType[P]>
        }
      >
    >


  export type AskedUserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    customId?: boolean
    statusMessage?: boolean
    receiveAnonymous?: boolean
    receiveOtherSchool?: boolean
    lastUpdateCustomId?: boolean
    Asked?: boolean | AskedUser$AskedArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    _count?: boolean | AskedUserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["askedUser"]>

  export type AskedUserSelectScalar = {
    userId?: boolean
    customId?: boolean
    statusMessage?: boolean
    receiveAnonymous?: boolean
    receiveOtherSchool?: boolean
    lastUpdateCustomId?: boolean
  }

  export type AskedUserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Asked?: boolean | AskedUser$AskedArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    _count?: boolean | AskedUserCountOutputTypeArgs<ExtArgs>
  }


  type AskedUserGetPayload<S extends boolean | null | undefined | AskedUserArgs> = $Types.GetResult<AskedUserPayload, S>

  type AskedUserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AskedUserFindManyArgs, 'select' | 'include'> & {
      select?: AskedUserCountAggregateInputType | true
    }

  export interface AskedUserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AskedUser'], meta: { name: 'AskedUser' } }
    /**
     * Find zero or one AskedUser that matches the filter.
     * @param {AskedUserFindUniqueArgs} args - Arguments to find a AskedUser
     * @example
     * // Get one AskedUser
     * const askedUser = await prisma.askedUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AskedUserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AskedUserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'AskedUser'> extends True ? Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one AskedUser that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AskedUserFindUniqueOrThrowArgs} args - Arguments to find a AskedUser
     * @example
     * // Get one AskedUser
     * const askedUser = await prisma.askedUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AskedUserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AskedUserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first AskedUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedUserFindFirstArgs} args - Arguments to find a AskedUser
     * @example
     * // Get one AskedUser
     * const askedUser = await prisma.askedUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AskedUserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AskedUserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'AskedUser'> extends True ? Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first AskedUser that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedUserFindFirstOrThrowArgs} args - Arguments to find a AskedUser
     * @example
     * // Get one AskedUser
     * const askedUser = await prisma.askedUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AskedUserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AskedUserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more AskedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedUserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AskedUsers
     * const askedUsers = await prisma.askedUser.findMany()
     * 
     * // Get first 10 AskedUsers
     * const askedUsers = await prisma.askedUser.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const askedUserWithUserIdOnly = await prisma.askedUser.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends AskedUserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AskedUserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a AskedUser.
     * @param {AskedUserCreateArgs} args - Arguments to create a AskedUser.
     * @example
     * // Create one AskedUser
     * const AskedUser = await prisma.askedUser.create({
     *   data: {
     *     // ... data to create a AskedUser
     *   }
     * })
     * 
    **/
    create<T extends AskedUserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AskedUserCreateArgs<ExtArgs>>
    ): Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many AskedUsers.
     *     @param {AskedUserCreateManyArgs} args - Arguments to create many AskedUsers.
     *     @example
     *     // Create many AskedUsers
     *     const askedUser = await prisma.askedUser.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AskedUserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AskedUserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AskedUser.
     * @param {AskedUserDeleteArgs} args - Arguments to delete one AskedUser.
     * @example
     * // Delete one AskedUser
     * const AskedUser = await prisma.askedUser.delete({
     *   where: {
     *     // ... filter to delete one AskedUser
     *   }
     * })
     * 
    **/
    delete<T extends AskedUserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AskedUserDeleteArgs<ExtArgs>>
    ): Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one AskedUser.
     * @param {AskedUserUpdateArgs} args - Arguments to update one AskedUser.
     * @example
     * // Update one AskedUser
     * const askedUser = await prisma.askedUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AskedUserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AskedUserUpdateArgs<ExtArgs>>
    ): Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more AskedUsers.
     * @param {AskedUserDeleteManyArgs} args - Arguments to filter AskedUsers to delete.
     * @example
     * // Delete a few AskedUsers
     * const { count } = await prisma.askedUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AskedUserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AskedUserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AskedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AskedUsers
     * const askedUser = await prisma.askedUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AskedUserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AskedUserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AskedUser.
     * @param {AskedUserUpsertArgs} args - Arguments to update or create a AskedUser.
     * @example
     * // Update or create a AskedUser
     * const askedUser = await prisma.askedUser.upsert({
     *   create: {
     *     // ... data to create a AskedUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AskedUser we want to update
     *   }
     * })
    **/
    upsert<T extends AskedUserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AskedUserUpsertArgs<ExtArgs>>
    ): Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of AskedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedUserCountArgs} args - Arguments to filter AskedUsers to count.
     * @example
     * // Count the number of AskedUsers
     * const count = await prisma.askedUser.count({
     *   where: {
     *     // ... the filter for the AskedUsers we want to count
     *   }
     * })
    **/
    count<T extends AskedUserCountArgs>(
      args?: Subset<T, AskedUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AskedUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AskedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AskedUserAggregateArgs>(args: Subset<T, AskedUserAggregateArgs>): Prisma.PrismaPromise<GetAskedUserAggregateType<T>>

    /**
     * Group by AskedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AskedUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AskedUserGroupByArgs['orderBy'] }
        : { orderBy?: AskedUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AskedUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAskedUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for AskedUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AskedUserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Asked<T extends AskedUser$AskedArgs<ExtArgs> = {}>(args?: Subset<T, AskedUser$AskedArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AskedPayload<ExtArgs>, T, 'findMany', never>| Null>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * AskedUser base type for findUnique actions
   */
  export type AskedUserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUser
     */
    select?: AskedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedUserInclude<ExtArgs> | null
    /**
     * Filter, which AskedUser to fetch.
     */
    where: AskedUserWhereUniqueInput
  }

  /**
   * AskedUser findUnique
   */
  export interface AskedUserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AskedUserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AskedUser findUniqueOrThrow
   */
  export type AskedUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUser
     */
    select?: AskedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedUserInclude<ExtArgs> | null
    /**
     * Filter, which AskedUser to fetch.
     */
    where: AskedUserWhereUniqueInput
  }


  /**
   * AskedUser base type for findFirst actions
   */
  export type AskedUserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUser
     */
    select?: AskedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedUserInclude<ExtArgs> | null
    /**
     * Filter, which AskedUser to fetch.
     */
    where?: AskedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AskedUsers to fetch.
     */
    orderBy?: Enumerable<AskedUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AskedUsers.
     */
    cursor?: AskedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AskedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AskedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AskedUsers.
     */
    distinct?: Enumerable<AskedUserScalarFieldEnum>
  }

  /**
   * AskedUser findFirst
   */
  export interface AskedUserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AskedUserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * AskedUser findFirstOrThrow
   */
  export type AskedUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUser
     */
    select?: AskedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedUserInclude<ExtArgs> | null
    /**
     * Filter, which AskedUser to fetch.
     */
    where?: AskedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AskedUsers to fetch.
     */
    orderBy?: Enumerable<AskedUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AskedUsers.
     */
    cursor?: AskedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AskedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AskedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AskedUsers.
     */
    distinct?: Enumerable<AskedUserScalarFieldEnum>
  }


  /**
   * AskedUser findMany
   */
  export type AskedUserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUser
     */
    select?: AskedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedUserInclude<ExtArgs> | null
    /**
     * Filter, which AskedUsers to fetch.
     */
    where?: AskedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AskedUsers to fetch.
     */
    orderBy?: Enumerable<AskedUserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AskedUsers.
     */
    cursor?: AskedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AskedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AskedUsers.
     */
    skip?: number
    distinct?: Enumerable<AskedUserScalarFieldEnum>
  }


  /**
   * AskedUser create
   */
  export type AskedUserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUser
     */
    select?: AskedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AskedUser.
     */
    data: XOR<AskedUserCreateInput, AskedUserUncheckedCreateInput>
  }


  /**
   * AskedUser createMany
   */
  export type AskedUserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AskedUsers.
     */
    data: Enumerable<AskedUserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * AskedUser update
   */
  export type AskedUserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUser
     */
    select?: AskedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AskedUser.
     */
    data: XOR<AskedUserUpdateInput, AskedUserUncheckedUpdateInput>
    /**
     * Choose, which AskedUser to update.
     */
    where: AskedUserWhereUniqueInput
  }


  /**
   * AskedUser updateMany
   */
  export type AskedUserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AskedUsers.
     */
    data: XOR<AskedUserUpdateManyMutationInput, AskedUserUncheckedUpdateManyInput>
    /**
     * Filter which AskedUsers to update
     */
    where?: AskedUserWhereInput
  }


  /**
   * AskedUser upsert
   */
  export type AskedUserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUser
     */
    select?: AskedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AskedUser to update in case it exists.
     */
    where: AskedUserWhereUniqueInput
    /**
     * In case the AskedUser found by the `where` argument doesn't exist, create a new AskedUser with this data.
     */
    create: XOR<AskedUserCreateInput, AskedUserUncheckedCreateInput>
    /**
     * In case the AskedUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AskedUserUpdateInput, AskedUserUncheckedUpdateInput>
  }


  /**
   * AskedUser delete
   */
  export type AskedUserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUser
     */
    select?: AskedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedUserInclude<ExtArgs> | null
    /**
     * Filter which AskedUser to delete.
     */
    where: AskedUserWhereUniqueInput
  }


  /**
   * AskedUser deleteMany
   */
  export type AskedUserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AskedUsers to delete
     */
    where?: AskedUserWhereInput
  }


  /**
   * AskedUser.Asked
   */
  export type AskedUser$AskedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    where?: AskedWhereInput
    orderBy?: Enumerable<AskedOrderByWithRelationInput>
    cursor?: AskedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AskedScalarFieldEnum>
  }


  /**
   * AskedUser without action
   */
  export type AskedUserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AskedUser
     */
    select?: AskedUserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedUserInclude<ExtArgs> | null
  }



  /**
   * Model Asked
   */


  export type AggregateAsked = {
    _count: AskedCountAggregateOutputType | null
    _min: AskedMinAggregateOutputType | null
    _max: AskedMaxAggregateOutputType | null
  }

  export type AskedMinAggregateOutputType = {
    id: string | null
    userId: string | null
    askedUserId: string | null
    process: Process | null
    question: string | null
    answer: string | null
    createdAt: Date | null
    answerTimeAt: Date | null
    isAnonymous: boolean | null
  }

  export type AskedMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    askedUserId: string | null
    process: Process | null
    question: string | null
    answer: string | null
    createdAt: Date | null
    answerTimeAt: Date | null
    isAnonymous: boolean | null
  }

  export type AskedCountAggregateOutputType = {
    id: number
    userId: number
    askedUserId: number
    process: number
    question: number
    answer: number
    createdAt: number
    answerTimeAt: number
    isAnonymous: number
    _all: number
  }


  export type AskedMinAggregateInputType = {
    id?: true
    userId?: true
    askedUserId?: true
    process?: true
    question?: true
    answer?: true
    createdAt?: true
    answerTimeAt?: true
    isAnonymous?: true
  }

  export type AskedMaxAggregateInputType = {
    id?: true
    userId?: true
    askedUserId?: true
    process?: true
    question?: true
    answer?: true
    createdAt?: true
    answerTimeAt?: true
    isAnonymous?: true
  }

  export type AskedCountAggregateInputType = {
    id?: true
    userId?: true
    askedUserId?: true
    process?: true
    question?: true
    answer?: true
    createdAt?: true
    answerTimeAt?: true
    isAnonymous?: true
    _all?: true
  }

  export type AskedAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Asked to aggregate.
     */
    where?: AskedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Askeds to fetch.
     */
    orderBy?: Enumerable<AskedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AskedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Askeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Askeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Askeds
    **/
    _count?: true | AskedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AskedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AskedMaxAggregateInputType
  }

  export type GetAskedAggregateType<T extends AskedAggregateArgs> = {
        [P in keyof T & keyof AggregateAsked]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsked[P]>
      : GetScalarType<T[P], AggregateAsked[P]>
  }




  export type AskedGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AskedWhereInput
    orderBy?: Enumerable<AskedOrderByWithAggregationInput>
    by: AskedScalarFieldEnum[]
    having?: AskedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AskedCountAggregateInputType | true
    _min?: AskedMinAggregateInputType
    _max?: AskedMaxAggregateInputType
  }


  export type AskedGroupByOutputType = {
    id: string
    userId: string
    askedUserId: string
    process: Process
    question: string
    answer: string | null
    createdAt: Date
    answerTimeAt: Date | null
    isAnonymous: boolean
    _count: AskedCountAggregateOutputType | null
    _min: AskedMinAggregateOutputType | null
    _max: AskedMaxAggregateOutputType | null
  }

  type GetAskedGroupByPayload<T extends AskedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AskedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AskedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AskedGroupByOutputType[P]>
            : GetScalarType<T[P], AskedGroupByOutputType[P]>
        }
      >
    >


  export type AskedSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    askedUserId?: boolean
    process?: boolean
    question?: boolean
    answer?: boolean
    createdAt?: boolean
    answerTimeAt?: boolean
    isAnonymous?: boolean
    AskedUser?: boolean | AskedUserArgs<ExtArgs>
    QuestionUser?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["asked"]>

  export type AskedSelectScalar = {
    id?: boolean
    userId?: boolean
    askedUserId?: boolean
    process?: boolean
    question?: boolean
    answer?: boolean
    createdAt?: boolean
    answerTimeAt?: boolean
    isAnonymous?: boolean
  }

  export type AskedInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    AskedUser?: boolean | AskedUserArgs<ExtArgs>
    QuestionUser?: boolean | UserArgs<ExtArgs>
  }


  type AskedGetPayload<S extends boolean | null | undefined | AskedArgs> = $Types.GetResult<AskedPayload, S>

  type AskedCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AskedFindManyArgs, 'select' | 'include'> & {
      select?: AskedCountAggregateInputType | true
    }

  export interface AskedDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Asked'], meta: { name: 'Asked' } }
    /**
     * Find zero or one Asked that matches the filter.
     * @param {AskedFindUniqueArgs} args - Arguments to find a Asked
     * @example
     * // Get one Asked
     * const asked = await prisma.asked.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AskedFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AskedFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Asked'> extends True ? Prisma__AskedClient<$Types.GetResult<AskedPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AskedClient<$Types.GetResult<AskedPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Asked that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AskedFindUniqueOrThrowArgs} args - Arguments to find a Asked
     * @example
     * // Get one Asked
     * const asked = await prisma.asked.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AskedFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AskedFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AskedClient<$Types.GetResult<AskedPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Asked that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedFindFirstArgs} args - Arguments to find a Asked
     * @example
     * // Get one Asked
     * const asked = await prisma.asked.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AskedFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AskedFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Asked'> extends True ? Prisma__AskedClient<$Types.GetResult<AskedPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AskedClient<$Types.GetResult<AskedPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Asked that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedFindFirstOrThrowArgs} args - Arguments to find a Asked
     * @example
     * // Get one Asked
     * const asked = await prisma.asked.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AskedFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AskedFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AskedClient<$Types.GetResult<AskedPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Askeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Askeds
     * const askeds = await prisma.asked.findMany()
     * 
     * // Get first 10 Askeds
     * const askeds = await prisma.asked.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const askedWithIdOnly = await prisma.asked.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AskedFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AskedFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AskedPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Asked.
     * @param {AskedCreateArgs} args - Arguments to create a Asked.
     * @example
     * // Create one Asked
     * const Asked = await prisma.asked.create({
     *   data: {
     *     // ... data to create a Asked
     *   }
     * })
     * 
    **/
    create<T extends AskedCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AskedCreateArgs<ExtArgs>>
    ): Prisma__AskedClient<$Types.GetResult<AskedPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Askeds.
     *     @param {AskedCreateManyArgs} args - Arguments to create many Askeds.
     *     @example
     *     // Create many Askeds
     *     const asked = await prisma.asked.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AskedCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AskedCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Asked.
     * @param {AskedDeleteArgs} args - Arguments to delete one Asked.
     * @example
     * // Delete one Asked
     * const Asked = await prisma.asked.delete({
     *   where: {
     *     // ... filter to delete one Asked
     *   }
     * })
     * 
    **/
    delete<T extends AskedDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AskedDeleteArgs<ExtArgs>>
    ): Prisma__AskedClient<$Types.GetResult<AskedPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Asked.
     * @param {AskedUpdateArgs} args - Arguments to update one Asked.
     * @example
     * // Update one Asked
     * const asked = await prisma.asked.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AskedUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AskedUpdateArgs<ExtArgs>>
    ): Prisma__AskedClient<$Types.GetResult<AskedPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Askeds.
     * @param {AskedDeleteManyArgs} args - Arguments to filter Askeds to delete.
     * @example
     * // Delete a few Askeds
     * const { count } = await prisma.asked.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AskedDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AskedDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Askeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Askeds
     * const asked = await prisma.asked.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AskedUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AskedUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Asked.
     * @param {AskedUpsertArgs} args - Arguments to update or create a Asked.
     * @example
     * // Update or create a Asked
     * const asked = await prisma.asked.upsert({
     *   create: {
     *     // ... data to create a Asked
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Asked we want to update
     *   }
     * })
    **/
    upsert<T extends AskedUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AskedUpsertArgs<ExtArgs>>
    ): Prisma__AskedClient<$Types.GetResult<AskedPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Askeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedCountArgs} args - Arguments to filter Askeds to count.
     * @example
     * // Count the number of Askeds
     * const count = await prisma.asked.count({
     *   where: {
     *     // ... the filter for the Askeds we want to count
     *   }
     * })
    **/
    count<T extends AskedCountArgs>(
      args?: Subset<T, AskedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AskedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Asked.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AskedAggregateArgs>(args: Subset<T, AskedAggregateArgs>): Prisma.PrismaPromise<GetAskedAggregateType<T>>

    /**
     * Group by Asked.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AskedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AskedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AskedGroupByArgs['orderBy'] }
        : { orderBy?: AskedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AskedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAskedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Asked.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AskedClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    AskedUser<T extends AskedUserArgs<ExtArgs> = {}>(args?: Subset<T, AskedUserArgs<ExtArgs>>): Prisma__AskedUserClient<$Types.GetResult<AskedUserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    QuestionUser<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Asked base type for findUnique actions
   */
  export type AskedFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    /**
     * Filter, which Asked to fetch.
     */
    where: AskedWhereUniqueInput
  }

  /**
   * Asked findUnique
   */
  export interface AskedFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AskedFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Asked findUniqueOrThrow
   */
  export type AskedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    /**
     * Filter, which Asked to fetch.
     */
    where: AskedWhereUniqueInput
  }


  /**
   * Asked base type for findFirst actions
   */
  export type AskedFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    /**
     * Filter, which Asked to fetch.
     */
    where?: AskedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Askeds to fetch.
     */
    orderBy?: Enumerable<AskedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Askeds.
     */
    cursor?: AskedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Askeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Askeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Askeds.
     */
    distinct?: Enumerable<AskedScalarFieldEnum>
  }

  /**
   * Asked findFirst
   */
  export interface AskedFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AskedFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Asked findFirstOrThrow
   */
  export type AskedFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    /**
     * Filter, which Asked to fetch.
     */
    where?: AskedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Askeds to fetch.
     */
    orderBy?: Enumerable<AskedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Askeds.
     */
    cursor?: AskedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Askeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Askeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Askeds.
     */
    distinct?: Enumerable<AskedScalarFieldEnum>
  }


  /**
   * Asked findMany
   */
  export type AskedFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    /**
     * Filter, which Askeds to fetch.
     */
    where?: AskedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Askeds to fetch.
     */
    orderBy?: Enumerable<AskedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Askeds.
     */
    cursor?: AskedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Askeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Askeds.
     */
    skip?: number
    distinct?: Enumerable<AskedScalarFieldEnum>
  }


  /**
   * Asked create
   */
  export type AskedCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    /**
     * The data needed to create a Asked.
     */
    data: XOR<AskedCreateInput, AskedUncheckedCreateInput>
  }


  /**
   * Asked createMany
   */
  export type AskedCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Askeds.
     */
    data: Enumerable<AskedCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Asked update
   */
  export type AskedUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    /**
     * The data needed to update a Asked.
     */
    data: XOR<AskedUpdateInput, AskedUncheckedUpdateInput>
    /**
     * Choose, which Asked to update.
     */
    where: AskedWhereUniqueInput
  }


  /**
   * Asked updateMany
   */
  export type AskedUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Askeds.
     */
    data: XOR<AskedUpdateManyMutationInput, AskedUncheckedUpdateManyInput>
    /**
     * Filter which Askeds to update
     */
    where?: AskedWhereInput
  }


  /**
   * Asked upsert
   */
  export type AskedUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    /**
     * The filter to search for the Asked to update in case it exists.
     */
    where: AskedWhereUniqueInput
    /**
     * In case the Asked found by the `where` argument doesn't exist, create a new Asked with this data.
     */
    create: XOR<AskedCreateInput, AskedUncheckedCreateInput>
    /**
     * In case the Asked was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AskedUpdateInput, AskedUncheckedUpdateInput>
  }


  /**
   * Asked delete
   */
  export type AskedDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
    /**
     * Filter which Asked to delete.
     */
    where: AskedWhereUniqueInput
  }


  /**
   * Asked deleteMany
   */
  export type AskedDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Askeds to delete
     */
    where?: AskedWhereInput
  }


  /**
   * Asked without action
   */
  export type AskedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Asked
     */
    select?: AskedSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AskedInclude<ExtArgs> | null
  }



  /**
   * Model Admin
   */


  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminAvgAggregateOutputType = {
    flags: number | null
  }

  export type AdminSumAggregateOutputType = {
    flags: number | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    loginId: string | null
    password: string | null
    flags: number | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    loginId: string | null
    password: string | null
    flags: number | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    loginId: number
    password: number
    flags: number
    _all: number
  }


  export type AdminAvgAggregateInputType = {
    flags?: true
  }

  export type AdminSumAggregateInputType = {
    flags?: true
  }

  export type AdminMinAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
    flags?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
    flags?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    loginId?: true
    password?: true
    flags?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: Enumerable<AdminOrderByWithAggregationInput>
    by: AdminScalarFieldEnum[]
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _avg?: AdminAvgAggregateInputType
    _sum?: AdminSumAggregateInputType
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }


  export type AdminGroupByOutputType = {
    id: string
    loginId: string
    password: string
    flags: number
    _count: AdminCountAggregateOutputType | null
    _avg: AdminAvgAggregateOutputType | null
    _sum: AdminSumAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loginId?: boolean
    password?: boolean
    flags?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    loginId?: boolean
    password?: boolean
    flags?: boolean
  }


  type AdminGetPayload<S extends boolean | null | undefined | AdminArgs> = $Types.GetResult<AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Admin'> extends True ? Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Admin'> extends True ? Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AdminPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminCreateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>
    ): Prisma__AdminClient<$Types.GetResult<AdminPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Admin base type for findUnique actions
   */
  export type AdminFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUnique
   */
  export interface AdminFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AdminFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin base type for findFirst actions
   */
  export type AdminFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: Enumerable<AdminScalarFieldEnum>
  }

  /**
   * Admin findFirst
   */
  export interface AdminFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AdminFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: Enumerable<AdminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: Enumerable<AdminScalarFieldEnum>
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: Enumerable<AdminCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }


  /**
   * Admin without action
   */
  export type AdminArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
  }



  /**
   * Model Board
   */


  export type AggregateBoard = {
    _count: BoardCountAggregateOutputType | null
    _avg: BoardAvgAggregateOutputType | null
    _sum: BoardSumAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  export type BoardAvgAggregateOutputType = {
    id: number | null
    noticeId: number | null
  }

  export type BoardSumAggregateOutputType = {
    id: number | null
    noticeId: number[] | null
  }

  export type BoardMinAggregateOutputType = {
    id: number | null
    schoolId: string | null
    name: string | null
    description: string | null
    default: boolean | null
  }

  export type BoardMaxAggregateOutputType = {
    id: number | null
    schoolId: string | null
    name: string | null
    description: string | null
    default: boolean | null
  }

  export type BoardCountAggregateOutputType = {
    id: number
    schoolId: number
    name: number
    description: number
    default: number
    noticeId: number
    _all: number
  }


  export type BoardAvgAggregateInputType = {
    id?: true
    noticeId?: true
  }

  export type BoardSumAggregateInputType = {
    id?: true
    noticeId?: true
  }

  export type BoardMinAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    default?: true
  }

  export type BoardMaxAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    default?: true
  }

  export type BoardCountAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    description?: true
    default?: true
    noticeId?: true
    _all?: true
  }

  export type BoardAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Board to aggregate.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: Enumerable<BoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Boards
    **/
    _count?: true | BoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardMaxAggregateInputType
  }

  export type GetBoardAggregateType<T extends BoardAggregateArgs> = {
        [P in keyof T & keyof AggregateBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoard[P]>
      : GetScalarType<T[P], AggregateBoard[P]>
  }




  export type BoardGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BoardWhereInput
    orderBy?: Enumerable<BoardOrderByWithAggregationInput>
    by: BoardScalarFieldEnum[]
    having?: BoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardCountAggregateInputType | true
    _avg?: BoardAvgAggregateInputType
    _sum?: BoardSumAggregateInputType
    _min?: BoardMinAggregateInputType
    _max?: BoardMaxAggregateInputType
  }


  export type BoardGroupByOutputType = {
    id: number
    schoolId: string
    name: string
    description: string
    default: boolean
    noticeId: number[]
    _count: BoardCountAggregateOutputType | null
    _avg: BoardAvgAggregateOutputType | null
    _sum: BoardSumAggregateOutputType | null
    _min: BoardMinAggregateOutputType | null
    _max: BoardMaxAggregateOutputType | null
  }

  type GetBoardGroupByPayload<T extends BoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardGroupByOutputType[P]>
            : GetScalarType<T[P], BoardGroupByOutputType[P]>
        }
      >
    >


  export type BoardSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    description?: boolean
    default?: boolean
    noticeId?: boolean
    Article?: boolean | Board$ArticleArgs<ExtArgs>
    managers?: boolean | Board$managersArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["board"]>

  export type BoardSelectScalar = {
    id?: boolean
    schoolId?: boolean
    name?: boolean
    description?: boolean
    default?: boolean
    noticeId?: boolean
  }

  export type BoardInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Article?: boolean | Board$ArticleArgs<ExtArgs>
    managers?: boolean | Board$managersArgs<ExtArgs>
    _count?: boolean | BoardCountOutputTypeArgs<ExtArgs>
  }


  type BoardGetPayload<S extends boolean | null | undefined | BoardArgs> = $Types.GetResult<BoardPayload, S>

  type BoardCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BoardFindManyArgs, 'select' | 'include'> & {
      select?: BoardCountAggregateInputType | true
    }

  export interface BoardDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Board'], meta: { name: 'Board' } }
    /**
     * Find zero or one Board that matches the filter.
     * @param {BoardFindUniqueArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Board'> extends True ? Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Board that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardFindUniqueOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Board that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Board'> extends True ? Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Board that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindFirstOrThrowArgs} args - Arguments to find a Board
     * @example
     * // Get one Board
     * const board = await prisma.board.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Boards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boards
     * const boards = await prisma.board.findMany()
     * 
     * // Get first 10 Boards
     * const boards = await prisma.board.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardWithIdOnly = await prisma.board.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BoardPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Board.
     * @param {BoardCreateArgs} args - Arguments to create a Board.
     * @example
     * // Create one Board
     * const Board = await prisma.board.create({
     *   data: {
     *     // ... data to create a Board
     *   }
     * })
     * 
    **/
    create<T extends BoardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BoardCreateArgs<ExtArgs>>
    ): Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Boards.
     *     @param {BoardCreateManyArgs} args - Arguments to create many Boards.
     *     @example
     *     // Create many Boards
     *     const board = await prisma.board.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Board.
     * @param {BoardDeleteArgs} args - Arguments to delete one Board.
     * @example
     * // Delete one Board
     * const Board = await prisma.board.delete({
     *   where: {
     *     // ... filter to delete one Board
     *   }
     * })
     * 
    **/
    delete<T extends BoardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BoardDeleteArgs<ExtArgs>>
    ): Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Board.
     * @param {BoardUpdateArgs} args - Arguments to update one Board.
     * @example
     * // Update one Board
     * const board = await prisma.board.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BoardUpdateArgs<ExtArgs>>
    ): Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Boards.
     * @param {BoardDeleteManyArgs} args - Arguments to filter Boards to delete.
     * @example
     * // Delete a few Boards
     * const { count } = await prisma.board.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boards
     * const board = await prisma.board.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BoardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Board.
     * @param {BoardUpsertArgs} args - Arguments to update or create a Board.
     * @example
     * // Update or create a Board
     * const board = await prisma.board.upsert({
     *   create: {
     *     // ... data to create a Board
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Board we want to update
     *   }
     * })
    **/
    upsert<T extends BoardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BoardUpsertArgs<ExtArgs>>
    ): Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Boards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardCountArgs} args - Arguments to filter Boards to count.
     * @example
     * // Count the number of Boards
     * const count = await prisma.board.count({
     *   where: {
     *     // ... the filter for the Boards we want to count
     *   }
     * })
    **/
    count<T extends BoardCountArgs>(
      args?: Subset<T, BoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardAggregateArgs>(args: Subset<T, BoardAggregateArgs>): Prisma.PrismaPromise<GetBoardAggregateType<T>>

    /**
     * Group by Board.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardGroupByArgs['orderBy'] }
        : { orderBy?: BoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Board.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Article<T extends Board$ArticleArgs<ExtArgs> = {}>(args?: Subset<T, Board$ArticleArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findMany', never>| Null>;

    managers<T extends Board$managersArgs<ExtArgs> = {}>(args?: Subset<T, Board$managersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Board base type for findUnique actions
   */
  export type BoardFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }

  /**
   * Board findUnique
   */
  export interface BoardFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BoardFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Board findUniqueOrThrow
   */
  export type BoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where: BoardWhereUniqueInput
  }


  /**
   * Board base type for findFirst actions
   */
  export type BoardFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: Enumerable<BoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: Enumerable<BoardScalarFieldEnum>
  }

  /**
   * Board findFirst
   */
  export interface BoardFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BoardFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Board findFirstOrThrow
   */
  export type BoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Board to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: Enumerable<BoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Boards.
     */
    distinct?: Enumerable<BoardScalarFieldEnum>
  }


  /**
   * Board findMany
   */
  export type BoardFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter, which Boards to fetch.
     */
    where?: BoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Boards to fetch.
     */
    orderBy?: Enumerable<BoardOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Boards.
     */
    cursor?: BoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Boards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Boards.
     */
    skip?: number
    distinct?: Enumerable<BoardScalarFieldEnum>
  }


  /**
   * Board create
   */
  export type BoardCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to create a Board.
     */
    data: XOR<BoardCreateInput, BoardUncheckedCreateInput>
  }


  /**
   * Board createMany
   */
  export type BoardCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Boards.
     */
    data: Enumerable<BoardCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Board update
   */
  export type BoardUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The data needed to update a Board.
     */
    data: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
    /**
     * Choose, which Board to update.
     */
    where: BoardWhereUniqueInput
  }


  /**
   * Board updateMany
   */
  export type BoardUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Boards.
     */
    data: XOR<BoardUpdateManyMutationInput, BoardUncheckedUpdateManyInput>
    /**
     * Filter which Boards to update
     */
    where?: BoardWhereInput
  }


  /**
   * Board upsert
   */
  export type BoardUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * The filter to search for the Board to update in case it exists.
     */
    where: BoardWhereUniqueInput
    /**
     * In case the Board found by the `where` argument doesn't exist, create a new Board with this data.
     */
    create: XOR<BoardCreateInput, BoardUncheckedCreateInput>
    /**
     * In case the Board was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardUpdateInput, BoardUncheckedUpdateInput>
  }


  /**
   * Board delete
   */
  export type BoardDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardInclude<ExtArgs> | null
    /**
     * Filter which Board to delete.
     */
    where: BoardWhereUniqueInput
  }


  /**
   * Board deleteMany
   */
  export type BoardDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Boards to delete
     */
    where?: BoardWhereInput
  }


  /**
   * Board.Article
   */
  export type Board$ArticleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    cursor?: ArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * Board.managers
   */
  export type Board$managersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    where?: BoardManagerWhereInput
    orderBy?: Enumerable<BoardManagerOrderByWithRelationInput>
    cursor?: BoardManagerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<BoardManagerScalarFieldEnum>
  }


  /**
   * Board without action
   */
  export type BoardArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Board
     */
    select?: BoardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardInclude<ExtArgs> | null
  }



  /**
   * Model BoardManager
   */


  export type AggregateBoardManager = {
    _count: BoardManagerCountAggregateOutputType | null
    _avg: BoardManagerAvgAggregateOutputType | null
    _sum: BoardManagerSumAggregateOutputType | null
    _min: BoardManagerMinAggregateOutputType | null
    _max: BoardManagerMaxAggregateOutputType | null
  }

  export type BoardManagerAvgAggregateOutputType = {
    boardId: number | null
  }

  export type BoardManagerSumAggregateOutputType = {
    boardId: number | null
  }

  export type BoardManagerMinAggregateOutputType = {
    id: string | null
    boardId: number | null
    name: string | null
    userId: string | null
  }

  export type BoardManagerMaxAggregateOutputType = {
    id: string | null
    boardId: number | null
    name: string | null
    userId: string | null
  }

  export type BoardManagerCountAggregateOutputType = {
    id: number
    boardId: number
    name: number
    userId: number
    _all: number
  }


  export type BoardManagerAvgAggregateInputType = {
    boardId?: true
  }

  export type BoardManagerSumAggregateInputType = {
    boardId?: true
  }

  export type BoardManagerMinAggregateInputType = {
    id?: true
    boardId?: true
    name?: true
    userId?: true
  }

  export type BoardManagerMaxAggregateInputType = {
    id?: true
    boardId?: true
    name?: true
    userId?: true
  }

  export type BoardManagerCountAggregateInputType = {
    id?: true
    boardId?: true
    name?: true
    userId?: true
    _all?: true
  }

  export type BoardManagerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardManager to aggregate.
     */
    where?: BoardManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardManagers to fetch.
     */
    orderBy?: Enumerable<BoardManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardManagers
    **/
    _count?: true | BoardManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoardManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoardManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardManagerMaxAggregateInputType
  }

  export type GetBoardManagerAggregateType<T extends BoardManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardManager[P]>
      : GetScalarType<T[P], AggregateBoardManager[P]>
  }




  export type BoardManagerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BoardManagerWhereInput
    orderBy?: Enumerable<BoardManagerOrderByWithAggregationInput>
    by: BoardManagerScalarFieldEnum[]
    having?: BoardManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardManagerCountAggregateInputType | true
    _avg?: BoardManagerAvgAggregateInputType
    _sum?: BoardManagerSumAggregateInputType
    _min?: BoardManagerMinAggregateInputType
    _max?: BoardManagerMaxAggregateInputType
  }


  export type BoardManagerGroupByOutputType = {
    id: string
    boardId: number
    name: string
    userId: string
    _count: BoardManagerCountAggregateOutputType | null
    _avg: BoardManagerAvgAggregateOutputType | null
    _sum: BoardManagerSumAggregateOutputType | null
    _min: BoardManagerMinAggregateOutputType | null
    _max: BoardManagerMaxAggregateOutputType | null
  }

  type GetBoardManagerGroupByPayload<T extends BoardManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoardManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardManagerGroupByOutputType[P]>
            : GetScalarType<T[P], BoardManagerGroupByOutputType[P]>
        }
      >
    >


  export type BoardManagerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    boardId?: boolean
    name?: boolean
    userId?: boolean
    board?: boolean | BoardArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["boardManager"]>

  export type BoardManagerSelectScalar = {
    id?: boolean
    boardId?: boolean
    name?: boolean
    userId?: boolean
  }

  export type BoardManagerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    board?: boolean | BoardArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
  }


  type BoardManagerGetPayload<S extends boolean | null | undefined | BoardManagerArgs> = $Types.GetResult<BoardManagerPayload, S>

  type BoardManagerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BoardManagerFindManyArgs, 'select' | 'include'> & {
      select?: BoardManagerCountAggregateInputType | true
    }

  export interface BoardManagerDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BoardManager'], meta: { name: 'BoardManager' } }
    /**
     * Find zero or one BoardManager that matches the filter.
     * @param {BoardManagerFindUniqueArgs} args - Arguments to find a BoardManager
     * @example
     * // Get one BoardManager
     * const boardManager = await prisma.boardManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardManagerFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardManagerFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoardManager'> extends True ? Prisma__BoardManagerClient<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BoardManagerClient<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BoardManager that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardManagerFindUniqueOrThrowArgs} args - Arguments to find a BoardManager
     * @example
     * // Get one BoardManager
     * const boardManager = await prisma.boardManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardManagerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardManagerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BoardManagerClient<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BoardManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardManagerFindFirstArgs} args - Arguments to find a BoardManager
     * @example
     * // Get one BoardManager
     * const boardManager = await prisma.boardManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardManagerFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardManagerFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoardManager'> extends True ? Prisma__BoardManagerClient<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BoardManagerClient<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BoardManager that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardManagerFindFirstOrThrowArgs} args - Arguments to find a BoardManager
     * @example
     * // Get one BoardManager
     * const boardManager = await prisma.boardManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardManagerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardManagerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BoardManagerClient<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BoardManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardManagerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardManagers
     * const boardManagers = await prisma.boardManager.findMany()
     * 
     * // Get first 10 BoardManagers
     * const boardManagers = await prisma.boardManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardManagerWithIdOnly = await prisma.boardManager.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardManagerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardManagerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BoardManager.
     * @param {BoardManagerCreateArgs} args - Arguments to create a BoardManager.
     * @example
     * // Create one BoardManager
     * const BoardManager = await prisma.boardManager.create({
     *   data: {
     *     // ... data to create a BoardManager
     *   }
     * })
     * 
    **/
    create<T extends BoardManagerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BoardManagerCreateArgs<ExtArgs>>
    ): Prisma__BoardManagerClient<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BoardManagers.
     *     @param {BoardManagerCreateManyArgs} args - Arguments to create many BoardManagers.
     *     @example
     *     // Create many BoardManagers
     *     const boardManager = await prisma.boardManager.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardManagerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardManagerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoardManager.
     * @param {BoardManagerDeleteArgs} args - Arguments to delete one BoardManager.
     * @example
     * // Delete one BoardManager
     * const BoardManager = await prisma.boardManager.delete({
     *   where: {
     *     // ... filter to delete one BoardManager
     *   }
     * })
     * 
    **/
    delete<T extends BoardManagerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BoardManagerDeleteArgs<ExtArgs>>
    ): Prisma__BoardManagerClient<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BoardManager.
     * @param {BoardManagerUpdateArgs} args - Arguments to update one BoardManager.
     * @example
     * // Update one BoardManager
     * const boardManager = await prisma.boardManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardManagerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BoardManagerUpdateArgs<ExtArgs>>
    ): Prisma__BoardManagerClient<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BoardManagers.
     * @param {BoardManagerDeleteManyArgs} args - Arguments to filter BoardManagers to delete.
     * @example
     * // Delete a few BoardManagers
     * const { count } = await prisma.boardManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardManagerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardManagerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardManagers
     * const boardManager = await prisma.boardManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardManagerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BoardManagerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoardManager.
     * @param {BoardManagerUpsertArgs} args - Arguments to update or create a BoardManager.
     * @example
     * // Update or create a BoardManager
     * const boardManager = await prisma.boardManager.upsert({
     *   create: {
     *     // ... data to create a BoardManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardManager we want to update
     *   }
     * })
    **/
    upsert<T extends BoardManagerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BoardManagerUpsertArgs<ExtArgs>>
    ): Prisma__BoardManagerClient<$Types.GetResult<BoardManagerPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BoardManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardManagerCountArgs} args - Arguments to filter BoardManagers to count.
     * @example
     * // Count the number of BoardManagers
     * const count = await prisma.boardManager.count({
     *   where: {
     *     // ... the filter for the BoardManagers we want to count
     *   }
     * })
    **/
    count<T extends BoardManagerCountArgs>(
      args?: Subset<T, BoardManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardManagerAggregateArgs>(args: Subset<T, BoardManagerAggregateArgs>): Prisma.PrismaPromise<GetBoardManagerAggregateType<T>>

    /**
     * Group by BoardManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardManagerGroupByArgs['orderBy'] }
        : { orderBy?: BoardManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardManagerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    board<T extends BoardArgs<ExtArgs> = {}>(args?: Subset<T, BoardArgs<ExtArgs>>): Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoardManager base type for findUnique actions
   */
  export type BoardManagerFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    /**
     * Filter, which BoardManager to fetch.
     */
    where: BoardManagerWhereUniqueInput
  }

  /**
   * BoardManager findUnique
   */
  export interface BoardManagerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BoardManagerFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardManager findUniqueOrThrow
   */
  export type BoardManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    /**
     * Filter, which BoardManager to fetch.
     */
    where: BoardManagerWhereUniqueInput
  }


  /**
   * BoardManager base type for findFirst actions
   */
  export type BoardManagerFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    /**
     * Filter, which BoardManager to fetch.
     */
    where?: BoardManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardManagers to fetch.
     */
    orderBy?: Enumerable<BoardManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardManagers.
     */
    cursor?: BoardManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardManagers.
     */
    distinct?: Enumerable<BoardManagerScalarFieldEnum>
  }

  /**
   * BoardManager findFirst
   */
  export interface BoardManagerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BoardManagerFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardManager findFirstOrThrow
   */
  export type BoardManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    /**
     * Filter, which BoardManager to fetch.
     */
    where?: BoardManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardManagers to fetch.
     */
    orderBy?: Enumerable<BoardManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardManagers.
     */
    cursor?: BoardManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardManagers.
     */
    distinct?: Enumerable<BoardManagerScalarFieldEnum>
  }


  /**
   * BoardManager findMany
   */
  export type BoardManagerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    /**
     * Filter, which BoardManagers to fetch.
     */
    where?: BoardManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardManagers to fetch.
     */
    orderBy?: Enumerable<BoardManagerOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardManagers.
     */
    cursor?: BoardManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardManagers.
     */
    skip?: number
    distinct?: Enumerable<BoardManagerScalarFieldEnum>
  }


  /**
   * BoardManager create
   */
  export type BoardManagerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a BoardManager.
     */
    data: XOR<BoardManagerCreateInput, BoardManagerUncheckedCreateInput>
  }


  /**
   * BoardManager createMany
   */
  export type BoardManagerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BoardManagers.
     */
    data: Enumerable<BoardManagerCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BoardManager update
   */
  export type BoardManagerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a BoardManager.
     */
    data: XOR<BoardManagerUpdateInput, BoardManagerUncheckedUpdateInput>
    /**
     * Choose, which BoardManager to update.
     */
    where: BoardManagerWhereUniqueInput
  }


  /**
   * BoardManager updateMany
   */
  export type BoardManagerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BoardManagers.
     */
    data: XOR<BoardManagerUpdateManyMutationInput, BoardManagerUncheckedUpdateManyInput>
    /**
     * Filter which BoardManagers to update
     */
    where?: BoardManagerWhereInput
  }


  /**
   * BoardManager upsert
   */
  export type BoardManagerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the BoardManager to update in case it exists.
     */
    where: BoardManagerWhereUniqueInput
    /**
     * In case the BoardManager found by the `where` argument doesn't exist, create a new BoardManager with this data.
     */
    create: XOR<BoardManagerCreateInput, BoardManagerUncheckedCreateInput>
    /**
     * In case the BoardManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardManagerUpdateInput, BoardManagerUncheckedUpdateInput>
  }


  /**
   * BoardManager delete
   */
  export type BoardManagerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
    /**
     * Filter which BoardManager to delete.
     */
    where: BoardManagerWhereUniqueInput
  }


  /**
   * BoardManager deleteMany
   */
  export type BoardManagerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardManagers to delete
     */
    where?: BoardManagerWhereInput
  }


  /**
   * BoardManager without action
   */
  export type BoardManagerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardManager
     */
    select?: BoardManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BoardManagerInclude<ExtArgs> | null
  }



  /**
   * Model Article
   */


  export type AggregateArticle = {
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  export type ArticleAvgAggregateOutputType = {
    id: number | null
    boardId: number | null
  }

  export type ArticleSumAggregateOutputType = {
    id: number | null
    boardId: number | null
  }

  export type ArticleMinAggregateOutputType = {
    id: number | null
    schoolId: string | null
    title: string | null
    content: string | null
    isAnonymous: boolean | null
    userId: string | null
    createdAt: Date | null
    boardId: number | null
  }

  export type ArticleMaxAggregateOutputType = {
    id: number | null
    schoolId: string | null
    title: string | null
    content: string | null
    isAnonymous: boolean | null
    userId: string | null
    createdAt: Date | null
    boardId: number | null
  }

  export type ArticleCountAggregateOutputType = {
    id: number
    schoolId: number
    title: number
    content: number
    images: number
    isAnonymous: number
    userId: number
    createdAt: number
    boardId: number
    _all: number
  }


  export type ArticleAvgAggregateInputType = {
    id?: true
    boardId?: true
  }

  export type ArticleSumAggregateInputType = {
    id?: true
    boardId?: true
  }

  export type ArticleMinAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    content?: true
    isAnonymous?: true
    userId?: true
    createdAt?: true
    boardId?: true
  }

  export type ArticleMaxAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    content?: true
    isAnonymous?: true
    userId?: true
    createdAt?: true
    boardId?: true
  }

  export type ArticleCountAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    content?: true
    images?: true
    isAnonymous?: true
    userId?: true
    createdAt?: true
    boardId?: true
    _all?: true
  }

  export type ArticleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Article to aggregate.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Articles
    **/
    _count?: true | ArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleMaxAggregateInputType
  }

  export type GetArticleAggregateType<T extends ArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticle[P]>
      : GetScalarType<T[P], AggregateArticle[P]>
  }




  export type ArticleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ArticleWhereInput
    orderBy?: Enumerable<ArticleOrderByWithAggregationInput>
    by: ArticleScalarFieldEnum[]
    having?: ArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCountAggregateInputType | true
    _avg?: ArticleAvgAggregateInputType
    _sum?: ArticleSumAggregateInputType
    _min?: ArticleMinAggregateInputType
    _max?: ArticleMaxAggregateInputType
  }


  export type ArticleGroupByOutputType = {
    id: number
    schoolId: string
    title: string
    content: string
    images: string[]
    isAnonymous: boolean
    userId: string
    createdAt: Date
    boardId: number
    _count: ArticleCountAggregateOutputType | null
    _avg: ArticleAvgAggregateOutputType | null
    _sum: ArticleSumAggregateOutputType | null
    _min: ArticleMinAggregateOutputType | null
    _max: ArticleMaxAggregateOutputType | null
  }

  type GetArticleGroupByPayload<T extends ArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleGroupByOutputType[P]>
        }
      >
    >


  export type ArticleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    isAnonymous?: boolean
    userId?: boolean
    createdAt?: boolean
    boardId?: boolean
    Board?: boolean | BoardArgs<ExtArgs>
    User?: boolean | UserArgs<ExtArgs>
    school?: boolean | SchoolArgs<ExtArgs>
    Comment?: boolean | Article$CommentArgs<ExtArgs>
    ReComment?: boolean | Article$ReCommentArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["article"]>

  export type ArticleSelectScalar = {
    id?: boolean
    schoolId?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    isAnonymous?: boolean
    userId?: boolean
    createdAt?: boolean
    boardId?: boolean
  }

  export type ArticleInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Board?: boolean | BoardArgs<ExtArgs>
    User?: boolean | UserArgs<ExtArgs>
    school?: boolean | SchoolArgs<ExtArgs>
    Comment?: boolean | Article$CommentArgs<ExtArgs>
    ReComment?: boolean | Article$ReCommentArgs<ExtArgs>
    _count?: boolean | ArticleCountOutputTypeArgs<ExtArgs>
  }


  type ArticleGetPayload<S extends boolean | null | undefined | ArticleArgs> = $Types.GetResult<ArticlePayload, S>

  type ArticleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ArticleFindManyArgs, 'select' | 'include'> & {
      select?: ArticleCountAggregateInputType | true
    }

  export interface ArticleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Article'], meta: { name: 'Article' } }
    /**
     * Find zero or one Article that matches the filter.
     * @param {ArticleFindUniqueArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ArticleFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ArticleFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Article'> extends True ? Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Article that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ArticleFindUniqueOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ArticleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Article that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ArticleFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ArticleFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Article'> extends True ? Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Article that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindFirstOrThrowArgs} args - Arguments to find a Article
     * @example
     * // Get one Article
     * const article = await prisma.article.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ArticleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Articles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Articles
     * const articles = await prisma.article.findMany()
     * 
     * // Get first 10 Articles
     * const articles = await prisma.article.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleWithIdOnly = await prisma.article.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ArticleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Article.
     * @param {ArticleCreateArgs} args - Arguments to create a Article.
     * @example
     * // Create one Article
     * const Article = await prisma.article.create({
     *   data: {
     *     // ... data to create a Article
     *   }
     * })
     * 
    **/
    create<T extends ArticleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleCreateArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Articles.
     *     @param {ArticleCreateManyArgs} args - Arguments to create many Articles.
     *     @example
     *     // Create many Articles
     *     const article = await prisma.article.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ArticleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Article.
     * @param {ArticleDeleteArgs} args - Arguments to delete one Article.
     * @example
     * // Delete one Article
     * const Article = await prisma.article.delete({
     *   where: {
     *     // ... filter to delete one Article
     *   }
     * })
     * 
    **/
    delete<T extends ArticleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleDeleteArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Article.
     * @param {ArticleUpdateArgs} args - Arguments to update one Article.
     * @example
     * // Update one Article
     * const article = await prisma.article.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ArticleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpdateArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Articles.
     * @param {ArticleDeleteManyArgs} args - Arguments to filter Articles to delete.
     * @example
     * // Delete a few Articles
     * const { count } = await prisma.article.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ArticleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ArticleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Articles
     * const article = await prisma.article.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ArticleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Article.
     * @param {ArticleUpsertArgs} args - Arguments to update or create a Article.
     * @example
     * // Update or create a Article
     * const article = await prisma.article.upsert({
     *   create: {
     *     // ... data to create a Article
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Article we want to update
     *   }
     * })
    **/
    upsert<T extends ArticleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ArticleUpsertArgs<ExtArgs>>
    ): Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Articles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCountArgs} args - Arguments to filter Articles to count.
     * @example
     * // Count the number of Articles
     * const count = await prisma.article.count({
     *   where: {
     *     // ... the filter for the Articles we want to count
     *   }
     * })
    **/
    count<T extends ArticleCountArgs>(
      args?: Subset<T, ArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleAggregateArgs>(args: Subset<T, ArticleAggregateArgs>): Prisma.PrismaPromise<GetArticleAggregateType<T>>

    /**
     * Group by Article.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleGroupByArgs['orderBy'] }
        : { orderBy?: ArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Article.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ArticleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Board<T extends BoardArgs<ExtArgs> = {}>(args?: Subset<T, BoardArgs<ExtArgs>>): Prisma__BoardClient<$Types.GetResult<BoardPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    User<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    school<T extends SchoolArgs<ExtArgs> = {}>(args?: Subset<T, SchoolArgs<ExtArgs>>): Prisma__SchoolClient<$Types.GetResult<SchoolPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    Comment<T extends Article$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Article$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    ReComment<T extends Article$ReCommentArgs<ExtArgs> = {}>(args?: Subset<T, Article$ReCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Article base type for findUnique actions
   */
  export type ArticleFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }

  /**
   * Article findUnique
   */
  export interface ArticleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ArticleFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Article findUniqueOrThrow
   */
  export type ArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article base type for findFirst actions
   */
  export type ArticleFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }

  /**
   * Article findFirst
   */
  export interface ArticleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ArticleFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Article findFirstOrThrow
   */
  export type ArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Article to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Articles.
     */
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * Article findMany
   */
  export type ArticleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter, which Articles to fetch.
     */
    where?: ArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Articles to fetch.
     */
    orderBy?: Enumerable<ArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Articles.
     */
    cursor?: ArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Articles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Articles.
     */
    skip?: number
    distinct?: Enumerable<ArticleScalarFieldEnum>
  }


  /**
   * Article create
   */
  export type ArticleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a Article.
     */
    data: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
  }


  /**
   * Article createMany
   */
  export type ArticleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Articles.
     */
    data: Enumerable<ArticleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Article update
   */
  export type ArticleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a Article.
     */
    data: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
    /**
     * Choose, which Article to update.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article updateMany
   */
  export type ArticleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Articles.
     */
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyInput>
    /**
     * Filter which Articles to update
     */
    where?: ArticleWhereInput
  }


  /**
   * Article upsert
   */
  export type ArticleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the Article to update in case it exists.
     */
    where: ArticleWhereUniqueInput
    /**
     * In case the Article found by the `where` argument doesn't exist, create a new Article with this data.
     */
    create: XOR<ArticleCreateInput, ArticleUncheckedCreateInput>
    /**
     * In case the Article was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleUpdateInput, ArticleUncheckedUpdateInput>
  }


  /**
   * Article delete
   */
  export type ArticleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
    /**
     * Filter which Article to delete.
     */
    where: ArticleWhereUniqueInput
  }


  /**
   * Article deleteMany
   */
  export type ArticleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Articles to delete
     */
    where?: ArticleWhereInput
  }


  /**
   * Article.Comment
   */
  export type Article$CommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Article.ReComment
   */
  export type Article$ReCommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    where?: ReCommentWhereInput
    orderBy?: Enumerable<ReCommentOrderByWithRelationInput>
    cursor?: ReCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReCommentScalarFieldEnum>
  }


  /**
   * Article without action
   */
  export type ArticleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Article
     */
    select?: ArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ArticleInclude<ExtArgs> | null
  }



  /**
   * Model DeletedArticle
   */


  export type AggregateDeletedArticle = {
    _count: DeletedArticleCountAggregateOutputType | null
    _avg: DeletedArticleAvgAggregateOutputType | null
    _sum: DeletedArticleSumAggregateOutputType | null
    _min: DeletedArticleMinAggregateOutputType | null
    _max: DeletedArticleMaxAggregateOutputType | null
  }

  export type DeletedArticleAvgAggregateOutputType = {
    id: number | null
    boardId: number | null
  }

  export type DeletedArticleSumAggregateOutputType = {
    id: number | null
    boardId: number | null
  }

  export type DeletedArticleMinAggregateOutputType = {
    id: number | null
    schoolId: string | null
    title: string | null
    content: string | null
    isAnonymous: boolean | null
    userId: string | null
    createdAt: Date | null
    DeletedAt: Date | null
    boardId: number | null
  }

  export type DeletedArticleMaxAggregateOutputType = {
    id: number | null
    schoolId: string | null
    title: string | null
    content: string | null
    isAnonymous: boolean | null
    userId: string | null
    createdAt: Date | null
    DeletedAt: Date | null
    boardId: number | null
  }

  export type DeletedArticleCountAggregateOutputType = {
    id: number
    schoolId: number
    title: number
    content: number
    images: number
    isAnonymous: number
    userId: number
    createdAt: number
    DeletedAt: number
    boardId: number
    _all: number
  }


  export type DeletedArticleAvgAggregateInputType = {
    id?: true
    boardId?: true
  }

  export type DeletedArticleSumAggregateInputType = {
    id?: true
    boardId?: true
  }

  export type DeletedArticleMinAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    content?: true
    isAnonymous?: true
    userId?: true
    createdAt?: true
    DeletedAt?: true
    boardId?: true
  }

  export type DeletedArticleMaxAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    content?: true
    isAnonymous?: true
    userId?: true
    createdAt?: true
    DeletedAt?: true
    boardId?: true
  }

  export type DeletedArticleCountAggregateInputType = {
    id?: true
    schoolId?: true
    title?: true
    content?: true
    images?: true
    isAnonymous?: true
    userId?: true
    createdAt?: true
    DeletedAt?: true
    boardId?: true
    _all?: true
  }

  export type DeletedArticleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeletedArticle to aggregate.
     */
    where?: DeletedArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedArticles to fetch.
     */
    orderBy?: Enumerable<DeletedArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeletedArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeletedArticles
    **/
    _count?: true | DeletedArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeletedArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeletedArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeletedArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeletedArticleMaxAggregateInputType
  }

  export type GetDeletedArticleAggregateType<T extends DeletedArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateDeletedArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeletedArticle[P]>
      : GetScalarType<T[P], AggregateDeletedArticle[P]>
  }




  export type DeletedArticleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DeletedArticleWhereInput
    orderBy?: Enumerable<DeletedArticleOrderByWithAggregationInput>
    by: DeletedArticleScalarFieldEnum[]
    having?: DeletedArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeletedArticleCountAggregateInputType | true
    _avg?: DeletedArticleAvgAggregateInputType
    _sum?: DeletedArticleSumAggregateInputType
    _min?: DeletedArticleMinAggregateInputType
    _max?: DeletedArticleMaxAggregateInputType
  }


  export type DeletedArticleGroupByOutputType = {
    id: number
    schoolId: string
    title: string
    content: string
    images: string[]
    isAnonymous: boolean
    userId: string
    createdAt: Date
    DeletedAt: Date
    boardId: number
    _count: DeletedArticleCountAggregateOutputType | null
    _avg: DeletedArticleAvgAggregateOutputType | null
    _sum: DeletedArticleSumAggregateOutputType | null
    _min: DeletedArticleMinAggregateOutputType | null
    _max: DeletedArticleMaxAggregateOutputType | null
  }

  type GetDeletedArticleGroupByPayload<T extends DeletedArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DeletedArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeletedArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeletedArticleGroupByOutputType[P]>
            : GetScalarType<T[P], DeletedArticleGroupByOutputType[P]>
        }
      >
    >


  export type DeletedArticleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    isAnonymous?: boolean
    userId?: boolean
    createdAt?: boolean
    DeletedAt?: boolean
    boardId?: boolean
  }, ExtArgs["result"]["deletedArticle"]>

  export type DeletedArticleSelectScalar = {
    id?: boolean
    schoolId?: boolean
    title?: boolean
    content?: boolean
    images?: boolean
    isAnonymous?: boolean
    userId?: boolean
    createdAt?: boolean
    DeletedAt?: boolean
    boardId?: boolean
  }


  type DeletedArticleGetPayload<S extends boolean | null | undefined | DeletedArticleArgs> = $Types.GetResult<DeletedArticlePayload, S>

  type DeletedArticleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DeletedArticleFindManyArgs, 'select' | 'include'> & {
      select?: DeletedArticleCountAggregateInputType | true
    }

  export interface DeletedArticleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeletedArticle'], meta: { name: 'DeletedArticle' } }
    /**
     * Find zero or one DeletedArticle that matches the filter.
     * @param {DeletedArticleFindUniqueArgs} args - Arguments to find a DeletedArticle
     * @example
     * // Get one DeletedArticle
     * const deletedArticle = await prisma.deletedArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DeletedArticleFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DeletedArticleFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DeletedArticle'> extends True ? Prisma__DeletedArticleClient<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DeletedArticleClient<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DeletedArticle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DeletedArticleFindUniqueOrThrowArgs} args - Arguments to find a DeletedArticle
     * @example
     * // Get one DeletedArticle
     * const deletedArticle = await prisma.deletedArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DeletedArticleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeletedArticleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DeletedArticleClient<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DeletedArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedArticleFindFirstArgs} args - Arguments to find a DeletedArticle
     * @example
     * // Get one DeletedArticle
     * const deletedArticle = await prisma.deletedArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DeletedArticleFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DeletedArticleFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DeletedArticle'> extends True ? Prisma__DeletedArticleClient<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DeletedArticleClient<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DeletedArticle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedArticleFindFirstOrThrowArgs} args - Arguments to find a DeletedArticle
     * @example
     * // Get one DeletedArticle
     * const deletedArticle = await prisma.deletedArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DeletedArticleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DeletedArticleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DeletedArticleClient<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DeletedArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedArticleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeletedArticles
     * const deletedArticles = await prisma.deletedArticle.findMany()
     * 
     * // Get first 10 DeletedArticles
     * const deletedArticles = await prisma.deletedArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deletedArticleWithIdOnly = await prisma.deletedArticle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DeletedArticleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeletedArticleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DeletedArticle.
     * @param {DeletedArticleCreateArgs} args - Arguments to create a DeletedArticle.
     * @example
     * // Create one DeletedArticle
     * const DeletedArticle = await prisma.deletedArticle.create({
     *   data: {
     *     // ... data to create a DeletedArticle
     *   }
     * })
     * 
    **/
    create<T extends DeletedArticleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DeletedArticleCreateArgs<ExtArgs>>
    ): Prisma__DeletedArticleClient<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DeletedArticles.
     *     @param {DeletedArticleCreateManyArgs} args - Arguments to create many DeletedArticles.
     *     @example
     *     // Create many DeletedArticles
     *     const deletedArticle = await prisma.deletedArticle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DeletedArticleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeletedArticleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeletedArticle.
     * @param {DeletedArticleDeleteArgs} args - Arguments to delete one DeletedArticle.
     * @example
     * // Delete one DeletedArticle
     * const DeletedArticle = await prisma.deletedArticle.delete({
     *   where: {
     *     // ... filter to delete one DeletedArticle
     *   }
     * })
     * 
    **/
    delete<T extends DeletedArticleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DeletedArticleDeleteArgs<ExtArgs>>
    ): Prisma__DeletedArticleClient<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DeletedArticle.
     * @param {DeletedArticleUpdateArgs} args - Arguments to update one DeletedArticle.
     * @example
     * // Update one DeletedArticle
     * const deletedArticle = await prisma.deletedArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DeletedArticleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DeletedArticleUpdateArgs<ExtArgs>>
    ): Prisma__DeletedArticleClient<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DeletedArticles.
     * @param {DeletedArticleDeleteManyArgs} args - Arguments to filter DeletedArticles to delete.
     * @example
     * // Delete a few DeletedArticles
     * const { count } = await prisma.deletedArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DeletedArticleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DeletedArticleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeletedArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeletedArticles
     * const deletedArticle = await prisma.deletedArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DeletedArticleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DeletedArticleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeletedArticle.
     * @param {DeletedArticleUpsertArgs} args - Arguments to update or create a DeletedArticle.
     * @example
     * // Update or create a DeletedArticle
     * const deletedArticle = await prisma.deletedArticle.upsert({
     *   create: {
     *     // ... data to create a DeletedArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeletedArticle we want to update
     *   }
     * })
    **/
    upsert<T extends DeletedArticleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DeletedArticleUpsertArgs<ExtArgs>>
    ): Prisma__DeletedArticleClient<$Types.GetResult<DeletedArticlePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DeletedArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedArticleCountArgs} args - Arguments to filter DeletedArticles to count.
     * @example
     * // Count the number of DeletedArticles
     * const count = await prisma.deletedArticle.count({
     *   where: {
     *     // ... the filter for the DeletedArticles we want to count
     *   }
     * })
    **/
    count<T extends DeletedArticleCountArgs>(
      args?: Subset<T, DeletedArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeletedArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeletedArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeletedArticleAggregateArgs>(args: Subset<T, DeletedArticleAggregateArgs>): Prisma.PrismaPromise<GetDeletedArticleAggregateType<T>>

    /**
     * Group by DeletedArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeletedArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeletedArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeletedArticleGroupByArgs['orderBy'] }
        : { orderBy?: DeletedArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeletedArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeletedArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DeletedArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DeletedArticleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DeletedArticle base type for findUnique actions
   */
  export type DeletedArticleFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedArticle
     */
    select?: DeletedArticleSelect<ExtArgs> | null
    /**
     * Filter, which DeletedArticle to fetch.
     */
    where: DeletedArticleWhereUniqueInput
  }

  /**
   * DeletedArticle findUnique
   */
  export interface DeletedArticleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DeletedArticleFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeletedArticle findUniqueOrThrow
   */
  export type DeletedArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedArticle
     */
    select?: DeletedArticleSelect<ExtArgs> | null
    /**
     * Filter, which DeletedArticle to fetch.
     */
    where: DeletedArticleWhereUniqueInput
  }


  /**
   * DeletedArticle base type for findFirst actions
   */
  export type DeletedArticleFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedArticle
     */
    select?: DeletedArticleSelect<ExtArgs> | null
    /**
     * Filter, which DeletedArticle to fetch.
     */
    where?: DeletedArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedArticles to fetch.
     */
    orderBy?: Enumerable<DeletedArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletedArticles.
     */
    cursor?: DeletedArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeletedArticles.
     */
    distinct?: Enumerable<DeletedArticleScalarFieldEnum>
  }

  /**
   * DeletedArticle findFirst
   */
  export interface DeletedArticleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DeletedArticleFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DeletedArticle findFirstOrThrow
   */
  export type DeletedArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedArticle
     */
    select?: DeletedArticleSelect<ExtArgs> | null
    /**
     * Filter, which DeletedArticle to fetch.
     */
    where?: DeletedArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedArticles to fetch.
     */
    orderBy?: Enumerable<DeletedArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeletedArticles.
     */
    cursor?: DeletedArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeletedArticles.
     */
    distinct?: Enumerable<DeletedArticleScalarFieldEnum>
  }


  /**
   * DeletedArticle findMany
   */
  export type DeletedArticleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedArticle
     */
    select?: DeletedArticleSelect<ExtArgs> | null
    /**
     * Filter, which DeletedArticles to fetch.
     */
    where?: DeletedArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeletedArticles to fetch.
     */
    orderBy?: Enumerable<DeletedArticleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeletedArticles.
     */
    cursor?: DeletedArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeletedArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeletedArticles.
     */
    skip?: number
    distinct?: Enumerable<DeletedArticleScalarFieldEnum>
  }


  /**
   * DeletedArticle create
   */
  export type DeletedArticleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedArticle
     */
    select?: DeletedArticleSelect<ExtArgs> | null
    /**
     * The data needed to create a DeletedArticle.
     */
    data: XOR<DeletedArticleCreateInput, DeletedArticleUncheckedCreateInput>
  }


  /**
   * DeletedArticle createMany
   */
  export type DeletedArticleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeletedArticles.
     */
    data: Enumerable<DeletedArticleCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DeletedArticle update
   */
  export type DeletedArticleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedArticle
     */
    select?: DeletedArticleSelect<ExtArgs> | null
    /**
     * The data needed to update a DeletedArticle.
     */
    data: XOR<DeletedArticleUpdateInput, DeletedArticleUncheckedUpdateInput>
    /**
     * Choose, which DeletedArticle to update.
     */
    where: DeletedArticleWhereUniqueInput
  }


  /**
   * DeletedArticle updateMany
   */
  export type DeletedArticleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeletedArticles.
     */
    data: XOR<DeletedArticleUpdateManyMutationInput, DeletedArticleUncheckedUpdateManyInput>
    /**
     * Filter which DeletedArticles to update
     */
    where?: DeletedArticleWhereInput
  }


  /**
   * DeletedArticle upsert
   */
  export type DeletedArticleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedArticle
     */
    select?: DeletedArticleSelect<ExtArgs> | null
    /**
     * The filter to search for the DeletedArticle to update in case it exists.
     */
    where: DeletedArticleWhereUniqueInput
    /**
     * In case the DeletedArticle found by the `where` argument doesn't exist, create a new DeletedArticle with this data.
     */
    create: XOR<DeletedArticleCreateInput, DeletedArticleUncheckedCreateInput>
    /**
     * In case the DeletedArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeletedArticleUpdateInput, DeletedArticleUncheckedUpdateInput>
  }


  /**
   * DeletedArticle delete
   */
  export type DeletedArticleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedArticle
     */
    select?: DeletedArticleSelect<ExtArgs> | null
    /**
     * Filter which DeletedArticle to delete.
     */
    where: DeletedArticleWhereUniqueInput
  }


  /**
   * DeletedArticle deleteMany
   */
  export type DeletedArticleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeletedArticles to delete
     */
    where?: DeletedArticleWhereInput
  }


  /**
   * DeletedArticle without action
   */
  export type DeletedArticleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeletedArticle
     */
    select?: DeletedArticleSelect<ExtArgs> | null
  }



  /**
   * Model BoardRequest
   */


  export type AggregateBoardRequest = {
    _count: BoardRequestCountAggregateOutputType | null
    _min: BoardRequestMinAggregateOutputType | null
    _max: BoardRequestMaxAggregateOutputType | null
  }

  export type BoardRequestMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    userId: string | null
    schoolId: string | null
    schoolName: string | null
    process: BoardRequestProcess | null
    message: string | null
  }

  export type BoardRequestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    userId: string | null
    schoolId: string | null
    schoolName: string | null
    process: BoardRequestProcess | null
    message: string | null
  }

  export type BoardRequestCountAggregateOutputType = {
    id: number
    name: number
    description: number
    userId: number
    schoolId: number
    schoolName: number
    process: number
    message: number
    _all: number
  }


  export type BoardRequestMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    schoolId?: true
    schoolName?: true
    process?: true
    message?: true
  }

  export type BoardRequestMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    schoolId?: true
    schoolName?: true
    process?: true
    message?: true
  }

  export type BoardRequestCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    schoolId?: true
    schoolName?: true
    process?: true
    message?: true
    _all?: true
  }

  export type BoardRequestAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardRequest to aggregate.
     */
    where?: BoardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardRequests to fetch.
     */
    orderBy?: Enumerable<BoardRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BoardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BoardRequests
    **/
    _count?: true | BoardRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoardRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoardRequestMaxAggregateInputType
  }

  export type GetBoardRequestAggregateType<T extends BoardRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateBoardRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoardRequest[P]>
      : GetScalarType<T[P], AggregateBoardRequest[P]>
  }




  export type BoardRequestGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: BoardRequestWhereInput
    orderBy?: Enumerable<BoardRequestOrderByWithAggregationInput>
    by: BoardRequestScalarFieldEnum[]
    having?: BoardRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoardRequestCountAggregateInputType | true
    _min?: BoardRequestMinAggregateInputType
    _max?: BoardRequestMaxAggregateInputType
  }


  export type BoardRequestGroupByOutputType = {
    id: string
    name: string
    description: string
    userId: string
    schoolId: string
    schoolName: string
    process: BoardRequestProcess
    message: string | null
    _count: BoardRequestCountAggregateOutputType | null
    _min: BoardRequestMinAggregateOutputType | null
    _max: BoardRequestMaxAggregateOutputType | null
  }

  type GetBoardRequestGroupByPayload<T extends BoardRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<BoardRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoardRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoardRequestGroupByOutputType[P]>
            : GetScalarType<T[P], BoardRequestGroupByOutputType[P]>
        }
      >
    >


  export type BoardRequestSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    schoolId?: boolean
    schoolName?: boolean
    process?: boolean
    message?: boolean
  }, ExtArgs["result"]["boardRequest"]>

  export type BoardRequestSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    schoolId?: boolean
    schoolName?: boolean
    process?: boolean
    message?: boolean
  }


  type BoardRequestGetPayload<S extends boolean | null | undefined | BoardRequestArgs> = $Types.GetResult<BoardRequestPayload, S>

  type BoardRequestCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<BoardRequestFindManyArgs, 'select' | 'include'> & {
      select?: BoardRequestCountAggregateInputType | true
    }

  export interface BoardRequestDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BoardRequest'], meta: { name: 'BoardRequest' } }
    /**
     * Find zero or one BoardRequest that matches the filter.
     * @param {BoardRequestFindUniqueArgs} args - Arguments to find a BoardRequest
     * @example
     * // Get one BoardRequest
     * const boardRequest = await prisma.boardRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BoardRequestFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, BoardRequestFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'BoardRequest'> extends True ? Prisma__BoardRequestClient<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__BoardRequestClient<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one BoardRequest that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BoardRequestFindUniqueOrThrowArgs} args - Arguments to find a BoardRequest
     * @example
     * // Get one BoardRequest
     * const boardRequest = await prisma.boardRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BoardRequestFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardRequestFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BoardRequestClient<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first BoardRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardRequestFindFirstArgs} args - Arguments to find a BoardRequest
     * @example
     * // Get one BoardRequest
     * const boardRequest = await prisma.boardRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BoardRequestFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, BoardRequestFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'BoardRequest'> extends True ? Prisma__BoardRequestClient<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__BoardRequestClient<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first BoardRequest that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardRequestFindFirstOrThrowArgs} args - Arguments to find a BoardRequest
     * @example
     * // Get one BoardRequest
     * const boardRequest = await prisma.boardRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BoardRequestFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardRequestFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BoardRequestClient<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more BoardRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardRequestFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BoardRequests
     * const boardRequests = await prisma.boardRequest.findMany()
     * 
     * // Get first 10 BoardRequests
     * const boardRequests = await prisma.boardRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boardRequestWithIdOnly = await prisma.boardRequest.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BoardRequestFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardRequestFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a BoardRequest.
     * @param {BoardRequestCreateArgs} args - Arguments to create a BoardRequest.
     * @example
     * // Create one BoardRequest
     * const BoardRequest = await prisma.boardRequest.create({
     *   data: {
     *     // ... data to create a BoardRequest
     *   }
     * })
     * 
    **/
    create<T extends BoardRequestCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BoardRequestCreateArgs<ExtArgs>>
    ): Prisma__BoardRequestClient<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many BoardRequests.
     *     @param {BoardRequestCreateManyArgs} args - Arguments to create many BoardRequests.
     *     @example
     *     // Create many BoardRequests
     *     const boardRequest = await prisma.boardRequest.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BoardRequestCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardRequestCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BoardRequest.
     * @param {BoardRequestDeleteArgs} args - Arguments to delete one BoardRequest.
     * @example
     * // Delete one BoardRequest
     * const BoardRequest = await prisma.boardRequest.delete({
     *   where: {
     *     // ... filter to delete one BoardRequest
     *   }
     * })
     * 
    **/
    delete<T extends BoardRequestDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BoardRequestDeleteArgs<ExtArgs>>
    ): Prisma__BoardRequestClient<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one BoardRequest.
     * @param {BoardRequestUpdateArgs} args - Arguments to update one BoardRequest.
     * @example
     * // Update one BoardRequest
     * const boardRequest = await prisma.boardRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BoardRequestUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BoardRequestUpdateArgs<ExtArgs>>
    ): Prisma__BoardRequestClient<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more BoardRequests.
     * @param {BoardRequestDeleteManyArgs} args - Arguments to filter BoardRequests to delete.
     * @example
     * // Delete a few BoardRequests
     * const { count } = await prisma.boardRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BoardRequestDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BoardRequestDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BoardRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BoardRequests
     * const boardRequest = await prisma.boardRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BoardRequestUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BoardRequestUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BoardRequest.
     * @param {BoardRequestUpsertArgs} args - Arguments to update or create a BoardRequest.
     * @example
     * // Update or create a BoardRequest
     * const boardRequest = await prisma.boardRequest.upsert({
     *   create: {
     *     // ... data to create a BoardRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BoardRequest we want to update
     *   }
     * })
    **/
    upsert<T extends BoardRequestUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BoardRequestUpsertArgs<ExtArgs>>
    ): Prisma__BoardRequestClient<$Types.GetResult<BoardRequestPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of BoardRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardRequestCountArgs} args - Arguments to filter BoardRequests to count.
     * @example
     * // Count the number of BoardRequests
     * const count = await prisma.boardRequest.count({
     *   where: {
     *     // ... the filter for the BoardRequests we want to count
     *   }
     * })
    **/
    count<T extends BoardRequestCountArgs>(
      args?: Subset<T, BoardRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoardRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BoardRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoardRequestAggregateArgs>(args: Subset<T, BoardRequestAggregateArgs>): Prisma.PrismaPromise<GetBoardRequestAggregateType<T>>

    /**
     * Group by BoardRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoardRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BoardRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BoardRequestGroupByArgs['orderBy'] }
        : { orderBy?: BoardRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BoardRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoardRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for BoardRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__BoardRequestClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * BoardRequest base type for findUnique actions
   */
  export type BoardRequestFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardRequest
     */
    select?: BoardRequestSelect<ExtArgs> | null
    /**
     * Filter, which BoardRequest to fetch.
     */
    where: BoardRequestWhereUniqueInput
  }

  /**
   * BoardRequest findUnique
   */
  export interface BoardRequestFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BoardRequestFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardRequest findUniqueOrThrow
   */
  export type BoardRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardRequest
     */
    select?: BoardRequestSelect<ExtArgs> | null
    /**
     * Filter, which BoardRequest to fetch.
     */
    where: BoardRequestWhereUniqueInput
  }


  /**
   * BoardRequest base type for findFirst actions
   */
  export type BoardRequestFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardRequest
     */
    select?: BoardRequestSelect<ExtArgs> | null
    /**
     * Filter, which BoardRequest to fetch.
     */
    where?: BoardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardRequests to fetch.
     */
    orderBy?: Enumerable<BoardRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardRequests.
     */
    cursor?: BoardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardRequests.
     */
    distinct?: Enumerable<BoardRequestScalarFieldEnum>
  }

  /**
   * BoardRequest findFirst
   */
  export interface BoardRequestFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends BoardRequestFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * BoardRequest findFirstOrThrow
   */
  export type BoardRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardRequest
     */
    select?: BoardRequestSelect<ExtArgs> | null
    /**
     * Filter, which BoardRequest to fetch.
     */
    where?: BoardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardRequests to fetch.
     */
    orderBy?: Enumerable<BoardRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BoardRequests.
     */
    cursor?: BoardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BoardRequests.
     */
    distinct?: Enumerable<BoardRequestScalarFieldEnum>
  }


  /**
   * BoardRequest findMany
   */
  export type BoardRequestFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardRequest
     */
    select?: BoardRequestSelect<ExtArgs> | null
    /**
     * Filter, which BoardRequests to fetch.
     */
    where?: BoardRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BoardRequests to fetch.
     */
    orderBy?: Enumerable<BoardRequestOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BoardRequests.
     */
    cursor?: BoardRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BoardRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BoardRequests.
     */
    skip?: number
    distinct?: Enumerable<BoardRequestScalarFieldEnum>
  }


  /**
   * BoardRequest create
   */
  export type BoardRequestCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardRequest
     */
    select?: BoardRequestSelect<ExtArgs> | null
    /**
     * The data needed to create a BoardRequest.
     */
    data: XOR<BoardRequestCreateInput, BoardRequestUncheckedCreateInput>
  }


  /**
   * BoardRequest createMany
   */
  export type BoardRequestCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BoardRequests.
     */
    data: Enumerable<BoardRequestCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * BoardRequest update
   */
  export type BoardRequestUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardRequest
     */
    select?: BoardRequestSelect<ExtArgs> | null
    /**
     * The data needed to update a BoardRequest.
     */
    data: XOR<BoardRequestUpdateInput, BoardRequestUncheckedUpdateInput>
    /**
     * Choose, which BoardRequest to update.
     */
    where: BoardRequestWhereUniqueInput
  }


  /**
   * BoardRequest updateMany
   */
  export type BoardRequestUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BoardRequests.
     */
    data: XOR<BoardRequestUpdateManyMutationInput, BoardRequestUncheckedUpdateManyInput>
    /**
     * Filter which BoardRequests to update
     */
    where?: BoardRequestWhereInput
  }


  /**
   * BoardRequest upsert
   */
  export type BoardRequestUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardRequest
     */
    select?: BoardRequestSelect<ExtArgs> | null
    /**
     * The filter to search for the BoardRequest to update in case it exists.
     */
    where: BoardRequestWhereUniqueInput
    /**
     * In case the BoardRequest found by the `where` argument doesn't exist, create a new BoardRequest with this data.
     */
    create: XOR<BoardRequestCreateInput, BoardRequestUncheckedCreateInput>
    /**
     * In case the BoardRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BoardRequestUpdateInput, BoardRequestUncheckedUpdateInput>
  }


  /**
   * BoardRequest delete
   */
  export type BoardRequestDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardRequest
     */
    select?: BoardRequestSelect<ExtArgs> | null
    /**
     * Filter which BoardRequest to delete.
     */
    where: BoardRequestWhereUniqueInput
  }


  /**
   * BoardRequest deleteMany
   */
  export type BoardRequestDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which BoardRequests to delete
     */
    where?: BoardRequestWhereInput
  }


  /**
   * BoardRequest without action
   */
  export type BoardRequestArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoardRequest
     */
    select?: BoardRequestSelect<ExtArgs> | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    articleId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    articleId: number | null
  }

  export type CommentMinAggregateOutputType = {
    userId: string | null
    content: string | null
    isAnonymous: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    id: number | null
    articleId: number | null
  }

  export type CommentMaxAggregateOutputType = {
    userId: string | null
    content: string | null
    isAnonymous: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    id: number | null
    articleId: number | null
  }

  export type CommentCountAggregateOutputType = {
    userId: number
    content: number
    isAnonymous: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    id: number
    articleId: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    articleId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    articleId?: true
  }

  export type CommentMinAggregateInputType = {
    userId?: true
    content?: true
    isAnonymous?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    articleId?: true
  }

  export type CommentMaxAggregateInputType = {
    userId?: true
    content?: true
    isAnonymous?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    articleId?: true
  }

  export type CommentCountAggregateInputType = {
    userId?: true
    content?: true
    isAnonymous?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    articleId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithAggregationInput>
    by: CommentScalarFieldEnum[]
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    id: number
    articleId: number
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    content?: boolean
    isAnonymous?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    articleId?: boolean
    Article?: boolean | ArticleArgs<ExtArgs>
    User?: boolean | UserArgs<ExtArgs>
    recomments?: boolean | Comment$recommentsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    userId?: boolean
    content?: boolean
    isAnonymous?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    articleId?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Article?: boolean | ArticleArgs<ExtArgs>
    User?: boolean | UserArgs<ExtArgs>
    recomments?: boolean | Comment$recommentsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeArgs<ExtArgs>
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentArgs> = $Types.GetResult<CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const commentWithUserIdOnly = await prisma.comment.findMany({ select: { userId: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Article<T extends ArticleArgs<ExtArgs> = {}>(args?: Subset<T, ArticleArgs<ExtArgs>>): Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    User<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    recomments<T extends Comment$recommentsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$recommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Comment base type for findUnique actions
   */
  export type CommentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUnique
   */
  export interface CommentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment base type for findFirst actions
   */
  export type CommentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }

  /**
   * Comment findFirst
   */
  export interface CommentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment.recomments
   */
  export type Comment$recommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    where?: ReCommentWhereInput
    orderBy?: Enumerable<ReCommentOrderByWithRelationInput>
    cursor?: ReCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReCommentScalarFieldEnum>
  }


  /**
   * Comment without action
   */
  export type CommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model ReComment
   */


  export type AggregateReComment = {
    _count: ReCommentCountAggregateOutputType | null
    _avg: ReCommentAvgAggregateOutputType | null
    _sum: ReCommentSumAggregateOutputType | null
    _min: ReCommentMinAggregateOutputType | null
    _max: ReCommentMaxAggregateOutputType | null
  }

  export type ReCommentAvgAggregateOutputType = {
    id: number | null
    articleId: number | null
    commentId: number | null
  }

  export type ReCommentSumAggregateOutputType = {
    id: number | null
    articleId: number | null
    commentId: number | null
  }

  export type ReCommentMinAggregateOutputType = {
    id: number | null
    articleId: number | null
    userId: string | null
    content: string | null
    isAnonymous: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    commentId: number | null
  }

  export type ReCommentMaxAggregateOutputType = {
    id: number | null
    articleId: number | null
    userId: string | null
    content: string | null
    isAnonymous: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    commentId: number | null
  }

  export type ReCommentCountAggregateOutputType = {
    id: number
    articleId: number
    userId: number
    content: number
    isAnonymous: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    commentId: number
    _all: number
  }


  export type ReCommentAvgAggregateInputType = {
    id?: true
    articleId?: true
    commentId?: true
  }

  export type ReCommentSumAggregateInputType = {
    id?: true
    articleId?: true
    commentId?: true
  }

  export type ReCommentMinAggregateInputType = {
    id?: true
    articleId?: true
    userId?: true
    content?: true
    isAnonymous?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    commentId?: true
  }

  export type ReCommentMaxAggregateInputType = {
    id?: true
    articleId?: true
    userId?: true
    content?: true
    isAnonymous?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    commentId?: true
  }

  export type ReCommentCountAggregateInputType = {
    id?: true
    articleId?: true
    userId?: true
    content?: true
    isAnonymous?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    commentId?: true
    _all?: true
  }

  export type ReCommentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReComment to aggregate.
     */
    where?: ReCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReComments to fetch.
     */
    orderBy?: Enumerable<ReCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReComments
    **/
    _count?: true | ReCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReCommentMaxAggregateInputType
  }

  export type GetReCommentAggregateType<T extends ReCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateReComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReComment[P]>
      : GetScalarType<T[P], AggregateReComment[P]>
  }




  export type ReCommentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReCommentWhereInput
    orderBy?: Enumerable<ReCommentOrderByWithAggregationInput>
    by: ReCommentScalarFieldEnum[]
    having?: ReCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReCommentCountAggregateInputType | true
    _avg?: ReCommentAvgAggregateInputType
    _sum?: ReCommentSumAggregateInputType
    _min?: ReCommentMinAggregateInputType
    _max?: ReCommentMaxAggregateInputType
  }


  export type ReCommentGroupByOutputType = {
    id: number
    articleId: number
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    commentId: number | null
    _count: ReCommentCountAggregateOutputType | null
    _avg: ReCommentAvgAggregateOutputType | null
    _sum: ReCommentSumAggregateOutputType | null
    _min: ReCommentMinAggregateOutputType | null
    _max: ReCommentMaxAggregateOutputType | null
  }

  type GetReCommentGroupByPayload<T extends ReCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ReCommentGroupByOutputType[P]>
        }
      >
    >


  export type ReCommentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    articleId?: boolean
    userId?: boolean
    content?: boolean
    isAnonymous?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commentId?: boolean
    Article?: boolean | ArticleArgs<ExtArgs>
    Comment?: boolean | CommentArgs<ExtArgs>
    User?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["reComment"]>

  export type ReCommentSelectScalar = {
    id?: boolean
    articleId?: boolean
    userId?: boolean
    content?: boolean
    isAnonymous?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    commentId?: boolean
  }

  export type ReCommentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Article?: boolean | ArticleArgs<ExtArgs>
    Comment?: boolean | CommentArgs<ExtArgs>
    User?: boolean | UserArgs<ExtArgs>
  }


  type ReCommentGetPayload<S extends boolean | null | undefined | ReCommentArgs> = $Types.GetResult<ReCommentPayload, S>

  type ReCommentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ReCommentFindManyArgs, 'select' | 'include'> & {
      select?: ReCommentCountAggregateInputType | true
    }

  export interface ReCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReComment'], meta: { name: 'ReComment' } }
    /**
     * Find zero or one ReComment that matches the filter.
     * @param {ReCommentFindUniqueArgs} args - Arguments to find a ReComment
     * @example
     * // Get one ReComment
     * const reComment = await prisma.reComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReCommentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReCommentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ReComment'> extends True ? Prisma__ReCommentClient<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ReCommentClient<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ReComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReCommentFindUniqueOrThrowArgs} args - Arguments to find a ReComment
     * @example
     * // Get one ReComment
     * const reComment = await prisma.reComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReCommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReCommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReCommentClient<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ReComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReCommentFindFirstArgs} args - Arguments to find a ReComment
     * @example
     * // Get one ReComment
     * const reComment = await prisma.reComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReCommentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReCommentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ReComment'> extends True ? Prisma__ReCommentClient<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ReCommentClient<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ReComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReCommentFindFirstOrThrowArgs} args - Arguments to find a ReComment
     * @example
     * // Get one ReComment
     * const reComment = await prisma.reComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReCommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReCommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReCommentClient<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ReComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReComments
     * const reComments = await prisma.reComment.findMany()
     * 
     * // Get first 10 ReComments
     * const reComments = await prisma.reComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reCommentWithIdOnly = await prisma.reComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReCommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReCommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ReComment.
     * @param {ReCommentCreateArgs} args - Arguments to create a ReComment.
     * @example
     * // Create one ReComment
     * const ReComment = await prisma.reComment.create({
     *   data: {
     *     // ... data to create a ReComment
     *   }
     * })
     * 
    **/
    create<T extends ReCommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReCommentCreateArgs<ExtArgs>>
    ): Prisma__ReCommentClient<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ReComments.
     *     @param {ReCommentCreateManyArgs} args - Arguments to create many ReComments.
     *     @example
     *     // Create many ReComments
     *     const reComment = await prisma.reComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReCommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReCommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReComment.
     * @param {ReCommentDeleteArgs} args - Arguments to delete one ReComment.
     * @example
     * // Delete one ReComment
     * const ReComment = await prisma.reComment.delete({
     *   where: {
     *     // ... filter to delete one ReComment
     *   }
     * })
     * 
    **/
    delete<T extends ReCommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReCommentDeleteArgs<ExtArgs>>
    ): Prisma__ReCommentClient<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ReComment.
     * @param {ReCommentUpdateArgs} args - Arguments to update one ReComment.
     * @example
     * // Update one ReComment
     * const reComment = await prisma.reComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReCommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReCommentUpdateArgs<ExtArgs>>
    ): Prisma__ReCommentClient<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ReComments.
     * @param {ReCommentDeleteManyArgs} args - Arguments to filter ReComments to delete.
     * @example
     * // Delete a few ReComments
     * const { count } = await prisma.reComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReCommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReCommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReComments
     * const reComment = await prisma.reComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReCommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReCommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReComment.
     * @param {ReCommentUpsertArgs} args - Arguments to update or create a ReComment.
     * @example
     * // Update or create a ReComment
     * const reComment = await prisma.reComment.upsert({
     *   create: {
     *     // ... data to create a ReComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReComment we want to update
     *   }
     * })
    **/
    upsert<T extends ReCommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReCommentUpsertArgs<ExtArgs>>
    ): Prisma__ReCommentClient<$Types.GetResult<ReCommentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ReComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReCommentCountArgs} args - Arguments to filter ReComments to count.
     * @example
     * // Count the number of ReComments
     * const count = await prisma.reComment.count({
     *   where: {
     *     // ... the filter for the ReComments we want to count
     *   }
     * })
    **/
    count<T extends ReCommentCountArgs>(
      args?: Subset<T, ReCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReCommentAggregateArgs>(args: Subset<T, ReCommentAggregateArgs>): Prisma.PrismaPromise<GetReCommentAggregateType<T>>

    /**
     * Group by ReComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReCommentGroupByArgs['orderBy'] }
        : { orderBy?: ReCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ReComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReCommentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Article<T extends ArticleArgs<ExtArgs> = {}>(args?: Subset<T, ArticleArgs<ExtArgs>>): Prisma__ArticleClient<$Types.GetResult<ArticlePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    Comment<T extends CommentArgs<ExtArgs> = {}>(args?: Subset<T, CommentArgs<ExtArgs>>): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    User<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ReComment base type for findUnique actions
   */
  export type ReCommentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReComment to fetch.
     */
    where: ReCommentWhereUniqueInput
  }

  /**
   * ReComment findUnique
   */
  export interface ReCommentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReCommentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReComment findUniqueOrThrow
   */
  export type ReCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReComment to fetch.
     */
    where: ReCommentWhereUniqueInput
  }


  /**
   * ReComment base type for findFirst actions
   */
  export type ReCommentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReComment to fetch.
     */
    where?: ReCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReComments to fetch.
     */
    orderBy?: Enumerable<ReCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReComments.
     */
    cursor?: ReCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReComments.
     */
    distinct?: Enumerable<ReCommentScalarFieldEnum>
  }

  /**
   * ReComment findFirst
   */
  export interface ReCommentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReCommentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ReComment findFirstOrThrow
   */
  export type ReCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReComment to fetch.
     */
    where?: ReCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReComments to fetch.
     */
    orderBy?: Enumerable<ReCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReComments.
     */
    cursor?: ReCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReComments.
     */
    distinct?: Enumerable<ReCommentScalarFieldEnum>
  }


  /**
   * ReComment findMany
   */
  export type ReCommentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReComments to fetch.
     */
    where?: ReCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReComments to fetch.
     */
    orderBy?: Enumerable<ReCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReComments.
     */
    cursor?: ReCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReComments.
     */
    skip?: number
    distinct?: Enumerable<ReCommentScalarFieldEnum>
  }


  /**
   * ReComment create
   */
  export type ReCommentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ReComment.
     */
    data: XOR<ReCommentCreateInput, ReCommentUncheckedCreateInput>
  }


  /**
   * ReComment createMany
   */
  export type ReCommentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReComments.
     */
    data: Enumerable<ReCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ReComment update
   */
  export type ReCommentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ReComment.
     */
    data: XOR<ReCommentUpdateInput, ReCommentUncheckedUpdateInput>
    /**
     * Choose, which ReComment to update.
     */
    where: ReCommentWhereUniqueInput
  }


  /**
   * ReComment updateMany
   */
  export type ReCommentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReComments.
     */
    data: XOR<ReCommentUpdateManyMutationInput, ReCommentUncheckedUpdateManyInput>
    /**
     * Filter which ReComments to update
     */
    where?: ReCommentWhereInput
  }


  /**
   * ReComment upsert
   */
  export type ReCommentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ReComment to update in case it exists.
     */
    where: ReCommentWhereUniqueInput
    /**
     * In case the ReComment found by the `where` argument doesn't exist, create a new ReComment with this data.
     */
    create: XOR<ReCommentCreateInput, ReCommentUncheckedCreateInput>
    /**
     * In case the ReComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReCommentUpdateInput, ReCommentUncheckedUpdateInput>
  }


  /**
   * ReComment delete
   */
  export type ReCommentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
    /**
     * Filter which ReComment to delete.
     */
    where: ReCommentWhereUniqueInput
  }


  /**
   * ReComment deleteMany
   */
  export type ReCommentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReComments to delete
     */
    where?: ReCommentWhereInput
  }


  /**
   * ReComment without action
   */
  export type ReCommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReComment
     */
    select?: ReCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReCommentInclude<ExtArgs> | null
  }



  /**
   * Model Report
   */


  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    reportUserId: string | null
    targetType: ReportTargetType | null
    message: string | null
    targetId: string | null
    reportUserName: string | null
    process: ReportProcess | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    reportUserId: string | null
    targetType: ReportTargetType | null
    message: string | null
    targetId: string | null
    reportUserName: string | null
    process: ReportProcess | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    reportUserId: number
    targetType: number
    message: number
    targetId: number
    reportUserName: number
    process: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    reportUserId?: true
    targetType?: true
    message?: true
    targetId?: true
    reportUserName?: true
    process?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    reportUserId?: true
    targetType?: true
    message?: true
    targetId?: true
    reportUserName?: true
    process?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    reportUserId?: true
    targetType?: true
    message?: true
    targetId?: true
    reportUserName?: true
    process?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: Enumerable<ReportOrderByWithAggregationInput>
    by: ReportScalarFieldEnum[]
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }


  export type ReportGroupByOutputType = {
    id: string
    reportUserId: string
    targetType: ReportTargetType
    message: string
    targetId: string
    reportUserName: string
    process: ReportProcess
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportUserId?: boolean
    targetType?: boolean
    message?: boolean
    targetId?: boolean
    reportUserName?: boolean
    process?: boolean
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    reportUserId?: boolean
    targetType?: boolean
    message?: boolean
    targetId?: boolean
    reportUserName?: boolean
    process?: boolean
  }


  type ReportGetPayload<S extends boolean | null | undefined | ReportArgs> = $Types.GetResult<ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Report'> extends True ? Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Report'> extends True ? Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ReportPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Reports.
     *     @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<$Types.GetResult<ReportPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Report base type for findUnique actions
   */
  export type ReportFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUnique
   */
  export interface ReportFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReportFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report base type for findFirst actions
   */
  export type ReportFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: Enumerable<ReportScalarFieldEnum>
  }

  /**
   * Report findFirst
   */
  export interface ReportFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ReportFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: Enumerable<ReportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }


  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: Enumerable<ReportCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }


  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }


  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }


  /**
   * Report without action
   */
  export type ReportArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
  }



  /**
   * Model Like
   */


  export type AggregateLike = {
    _count: LikeCountAggregateOutputType | null
    _avg: LikeAvgAggregateOutputType | null
    _sum: LikeSumAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  export type LikeAvgAggregateOutputType = {
    targetId: number | null
  }

  export type LikeSumAggregateOutputType = {
    targetId: number | null
  }

  export type LikeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    targetId: number | null
    targetType: LikeTargetType | null
    likeType: LikeType | null
  }

  export type LikeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    targetId: number | null
    targetType: LikeTargetType | null
    likeType: LikeType | null
  }

  export type LikeCountAggregateOutputType = {
    id: number
    userId: number
    targetId: number
    targetType: number
    likeType: number
    _all: number
  }


  export type LikeAvgAggregateInputType = {
    targetId?: true
  }

  export type LikeSumAggregateInputType = {
    targetId?: true
  }

  export type LikeMinAggregateInputType = {
    id?: true
    userId?: true
    targetId?: true
    targetType?: true
    likeType?: true
  }

  export type LikeMaxAggregateInputType = {
    id?: true
    userId?: true
    targetId?: true
    targetType?: true
    likeType?: true
  }

  export type LikeCountAggregateInputType = {
    id?: true
    userId?: true
    targetId?: true
    targetType?: true
    likeType?: true
    _all?: true
  }

  export type LikeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Like to aggregate.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: Enumerable<LikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Likes
    **/
    _count?: true | LikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LikeMaxAggregateInputType
  }

  export type GetLikeAggregateType<T extends LikeAggregateArgs> = {
        [P in keyof T & keyof AggregateLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLike[P]>
      : GetScalarType<T[P], AggregateLike[P]>
  }




  export type LikeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LikeWhereInput
    orderBy?: Enumerable<LikeOrderByWithAggregationInput>
    by: LikeScalarFieldEnum[]
    having?: LikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LikeCountAggregateInputType | true
    _avg?: LikeAvgAggregateInputType
    _sum?: LikeSumAggregateInputType
    _min?: LikeMinAggregateInputType
    _max?: LikeMaxAggregateInputType
  }


  export type LikeGroupByOutputType = {
    id: string
    userId: string
    targetId: number
    targetType: LikeTargetType
    likeType: LikeType
    _count: LikeCountAggregateOutputType | null
    _avg: LikeAvgAggregateOutputType | null
    _sum: LikeSumAggregateOutputType | null
    _min: LikeMinAggregateOutputType | null
    _max: LikeMaxAggregateOutputType | null
  }

  type GetLikeGroupByPayload<T extends LikeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LikeGroupByOutputType[P]>
            : GetScalarType<T[P], LikeGroupByOutputType[P]>
        }
      >
    >


  export type LikeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    targetId?: boolean
    targetType?: boolean
    likeType?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["like"]>

  export type LikeSelectScalar = {
    id?: boolean
    userId?: boolean
    targetId?: boolean
    targetType?: boolean
    likeType?: boolean
  }

  export type LikeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type LikeGetPayload<S extends boolean | null | undefined | LikeArgs> = $Types.GetResult<LikePayload, S>

  type LikeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LikeFindManyArgs, 'select' | 'include'> & {
      select?: LikeCountAggregateInputType | true
    }

  export interface LikeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Like'], meta: { name: 'Like' } }
    /**
     * Find zero or one Like that matches the filter.
     * @param {LikeFindUniqueArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LikeFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LikeFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Like'> extends True ? Prisma__LikeClient<$Types.GetResult<LikePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__LikeClient<$Types.GetResult<LikePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Like that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LikeFindUniqueOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LikeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LikeClient<$Types.GetResult<LikePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LikeFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LikeFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Like'> extends True ? Prisma__LikeClient<$Types.GetResult<LikePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__LikeClient<$Types.GetResult<LikePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Like that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindFirstOrThrowArgs} args - Arguments to find a Like
     * @example
     * // Get one Like
     * const like = await prisma.like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LikeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LikeClient<$Types.GetResult<LikePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Likes
     * const likes = await prisma.like.findMany()
     * 
     * // Get first 10 Likes
     * const likes = await prisma.like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const likeWithIdOnly = await prisma.like.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LikeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LikePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Like.
     * @param {LikeCreateArgs} args - Arguments to create a Like.
     * @example
     * // Create one Like
     * const Like = await prisma.like.create({
     *   data: {
     *     // ... data to create a Like
     *   }
     * })
     * 
    **/
    create<T extends LikeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LikeCreateArgs<ExtArgs>>
    ): Prisma__LikeClient<$Types.GetResult<LikePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Likes.
     *     @param {LikeCreateManyArgs} args - Arguments to create many Likes.
     *     @example
     *     // Create many Likes
     *     const like = await prisma.like.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LikeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Like.
     * @param {LikeDeleteArgs} args - Arguments to delete one Like.
     * @example
     * // Delete one Like
     * const Like = await prisma.like.delete({
     *   where: {
     *     // ... filter to delete one Like
     *   }
     * })
     * 
    **/
    delete<T extends LikeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LikeDeleteArgs<ExtArgs>>
    ): Prisma__LikeClient<$Types.GetResult<LikePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Like.
     * @param {LikeUpdateArgs} args - Arguments to update one Like.
     * @example
     * // Update one Like
     * const like = await prisma.like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LikeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LikeUpdateArgs<ExtArgs>>
    ): Prisma__LikeClient<$Types.GetResult<LikePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Likes.
     * @param {LikeDeleteManyArgs} args - Arguments to filter Likes to delete.
     * @example
     * // Delete a few Likes
     * const { count } = await prisma.like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LikeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LikeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Likes
     * const like = await prisma.like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LikeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LikeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Like.
     * @param {LikeUpsertArgs} args - Arguments to update or create a Like.
     * @example
     * // Update or create a Like
     * const like = await prisma.like.upsert({
     *   create: {
     *     // ... data to create a Like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Like we want to update
     *   }
     * })
    **/
    upsert<T extends LikeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LikeUpsertArgs<ExtArgs>>
    ): Prisma__LikeClient<$Types.GetResult<LikePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeCountArgs} args - Arguments to filter Likes to count.
     * @example
     * // Count the number of Likes
     * const count = await prisma.like.count({
     *   where: {
     *     // ... the filter for the Likes we want to count
     *   }
     * })
    **/
    count<T extends LikeCountArgs>(
      args?: Subset<T, LikeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LikeAggregateArgs>(args: Subset<T, LikeAggregateArgs>): Prisma.PrismaPromise<GetLikeAggregateType<T>>

    /**
     * Group by Like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LikeGroupByArgs['orderBy'] }
        : { orderBy?: LikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLikeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LikeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Like base type for findUnique actions
   */
  export type LikeFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }

  /**
   * Like findUnique
   */
  export interface LikeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LikeFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Like findUniqueOrThrow
   */
  export type LikeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where: LikeWhereUniqueInput
  }


  /**
   * Like base type for findFirst actions
   */
  export type LikeFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: Enumerable<LikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: Enumerable<LikeScalarFieldEnum>
  }

  /**
   * Like findFirst
   */
  export interface LikeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LikeFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Like findFirstOrThrow
   */
  export type LikeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Like to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: Enumerable<LikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Likes.
     */
    distinct?: Enumerable<LikeScalarFieldEnum>
  }


  /**
   * Like findMany
   */
  export type LikeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter, which Likes to fetch.
     */
    where?: LikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Likes to fetch.
     */
    orderBy?: Enumerable<LikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Likes.
     */
    cursor?: LikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Likes.
     */
    skip?: number
    distinct?: Enumerable<LikeScalarFieldEnum>
  }


  /**
   * Like create
   */
  export type LikeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to create a Like.
     */
    data: XOR<LikeCreateInput, LikeUncheckedCreateInput>
  }


  /**
   * Like createMany
   */
  export type LikeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Likes.
     */
    data: Enumerable<LikeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Like update
   */
  export type LikeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The data needed to update a Like.
     */
    data: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
    /**
     * Choose, which Like to update.
     */
    where: LikeWhereUniqueInput
  }


  /**
   * Like updateMany
   */
  export type LikeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Likes.
     */
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyInput>
    /**
     * Filter which Likes to update
     */
    where?: LikeWhereInput
  }


  /**
   * Like upsert
   */
  export type LikeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * The filter to search for the Like to update in case it exists.
     */
    where: LikeWhereUniqueInput
    /**
     * In case the Like found by the `where` argument doesn't exist, create a new Like with this data.
     */
    create: XOR<LikeCreateInput, LikeUncheckedCreateInput>
    /**
     * In case the Like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LikeUpdateInput, LikeUncheckedUpdateInput>
  }


  /**
   * Like delete
   */
  export type LikeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
    /**
     * Filter which Like to delete.
     */
    where: LikeWhereUniqueInput
  }


  /**
   * Like deleteMany
   */
  export type LikeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Likes to delete
     */
    where?: LikeWhereInput
  }


  /**
   * Like without action
   */
  export type LikeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Like
     */
    select?: LikeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LikeInclude<ExtArgs> | null
  }



  /**
   * Model Meal
   */


  export type AggregateMeal = {
    _count: MealCountAggregateOutputType | null
    _avg: MealAvgAggregateOutputType | null
    _sum: MealSumAggregateOutputType | null
    _min: MealMinAggregateOutputType | null
    _max: MealMaxAggregateOutputType | null
  }

  export type MealAvgAggregateOutputType = {
    MLSV_FGR: number | null
  }

  export type MealSumAggregateOutputType = {
    MLSV_FGR: number | null
  }

  export type MealMinAggregateOutputType = {
    id: string | null
    MLSV_FGR: number | null
    DDISH_NM: string | null
    ORPLC_INFO: string | null
    CAL_INFO: string | null
    NTR_INFO: string | null
  }

  export type MealMaxAggregateOutputType = {
    id: string | null
    MLSV_FGR: number | null
    DDISH_NM: string | null
    ORPLC_INFO: string | null
    CAL_INFO: string | null
    NTR_INFO: string | null
  }

  export type MealCountAggregateOutputType = {
    id: number
    MLSV_FGR: number
    DDISH_NM: number
    ORPLC_INFO: number
    CAL_INFO: number
    NTR_INFO: number
    _all: number
  }


  export type MealAvgAggregateInputType = {
    MLSV_FGR?: true
  }

  export type MealSumAggregateInputType = {
    MLSV_FGR?: true
  }

  export type MealMinAggregateInputType = {
    id?: true
    MLSV_FGR?: true
    DDISH_NM?: true
    ORPLC_INFO?: true
    CAL_INFO?: true
    NTR_INFO?: true
  }

  export type MealMaxAggregateInputType = {
    id?: true
    MLSV_FGR?: true
    DDISH_NM?: true
    ORPLC_INFO?: true
    CAL_INFO?: true
    NTR_INFO?: true
  }

  export type MealCountAggregateInputType = {
    id?: true
    MLSV_FGR?: true
    DDISH_NM?: true
    ORPLC_INFO?: true
    CAL_INFO?: true
    NTR_INFO?: true
    _all?: true
  }

  export type MealAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meal to aggregate.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: Enumerable<MealOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meals
    **/
    _count?: true | MealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MealMaxAggregateInputType
  }

  export type GetMealAggregateType<T extends MealAggregateArgs> = {
        [P in keyof T & keyof AggregateMeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeal[P]>
      : GetScalarType<T[P], AggregateMeal[P]>
  }




  export type MealGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MealWhereInput
    orderBy?: Enumerable<MealOrderByWithAggregationInput>
    by: MealScalarFieldEnum[]
    having?: MealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MealCountAggregateInputType | true
    _avg?: MealAvgAggregateInputType
    _sum?: MealSumAggregateInputType
    _min?: MealMinAggregateInputType
    _max?: MealMaxAggregateInputType
  }


  export type MealGroupByOutputType = {
    id: string
    MLSV_FGR: number
    DDISH_NM: string
    ORPLC_INFO: string
    CAL_INFO: string
    NTR_INFO: string
    _count: MealCountAggregateOutputType | null
    _avg: MealAvgAggregateOutputType | null
    _sum: MealSumAggregateOutputType | null
    _min: MealMinAggregateOutputType | null
    _max: MealMaxAggregateOutputType | null
  }

  type GetMealGroupByPayload<T extends MealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MealGroupByOutputType[P]>
            : GetScalarType<T[P], MealGroupByOutputType[P]>
        }
      >
    >


  export type MealSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    MLSV_FGR?: boolean
    DDISH_NM?: boolean
    ORPLC_INFO?: boolean
    CAL_INFO?: boolean
    NTR_INFO?: boolean
  }, ExtArgs["result"]["meal"]>

  export type MealSelectScalar = {
    id?: boolean
    MLSV_FGR?: boolean
    DDISH_NM?: boolean
    ORPLC_INFO?: boolean
    CAL_INFO?: boolean
    NTR_INFO?: boolean
  }


  type MealGetPayload<S extends boolean | null | undefined | MealArgs> = $Types.GetResult<MealPayload, S>

  type MealCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MealFindManyArgs, 'select' | 'include'> & {
      select?: MealCountAggregateInputType | true
    }

  export interface MealDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meal'], meta: { name: 'Meal' } }
    /**
     * Find zero or one Meal that matches the filter.
     * @param {MealFindUniqueArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MealFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MealFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Meal'> extends True ? Prisma__MealClient<$Types.GetResult<MealPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__MealClient<$Types.GetResult<MealPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Meal that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MealFindUniqueOrThrowArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MealFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MealFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MealClient<$Types.GetResult<MealPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Meal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindFirstArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MealFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MealFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Meal'> extends True ? Prisma__MealClient<$Types.GetResult<MealPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__MealClient<$Types.GetResult<MealPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Meal that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindFirstOrThrowArgs} args - Arguments to find a Meal
     * @example
     * // Get one Meal
     * const meal = await prisma.meal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MealFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MealFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MealClient<$Types.GetResult<MealPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Meals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meals
     * const meals = await prisma.meal.findMany()
     * 
     * // Get first 10 Meals
     * const meals = await prisma.meal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mealWithIdOnly = await prisma.meal.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MealFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MealFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<MealPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Meal.
     * @param {MealCreateArgs} args - Arguments to create a Meal.
     * @example
     * // Create one Meal
     * const Meal = await prisma.meal.create({
     *   data: {
     *     // ... data to create a Meal
     *   }
     * })
     * 
    **/
    create<T extends MealCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MealCreateArgs<ExtArgs>>
    ): Prisma__MealClient<$Types.GetResult<MealPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Meals.
     *     @param {MealCreateManyArgs} args - Arguments to create many Meals.
     *     @example
     *     // Create many Meals
     *     const meal = await prisma.meal.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MealCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MealCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Meal.
     * @param {MealDeleteArgs} args - Arguments to delete one Meal.
     * @example
     * // Delete one Meal
     * const Meal = await prisma.meal.delete({
     *   where: {
     *     // ... filter to delete one Meal
     *   }
     * })
     * 
    **/
    delete<T extends MealDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MealDeleteArgs<ExtArgs>>
    ): Prisma__MealClient<$Types.GetResult<MealPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Meal.
     * @param {MealUpdateArgs} args - Arguments to update one Meal.
     * @example
     * // Update one Meal
     * const meal = await prisma.meal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MealUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MealUpdateArgs<ExtArgs>>
    ): Prisma__MealClient<$Types.GetResult<MealPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Meals.
     * @param {MealDeleteManyArgs} args - Arguments to filter Meals to delete.
     * @example
     * // Delete a few Meals
     * const { count } = await prisma.meal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MealDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MealDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meals
     * const meal = await prisma.meal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MealUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MealUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Meal.
     * @param {MealUpsertArgs} args - Arguments to update or create a Meal.
     * @example
     * // Update or create a Meal
     * const meal = await prisma.meal.upsert({
     *   create: {
     *     // ... data to create a Meal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meal we want to update
     *   }
     * })
    **/
    upsert<T extends MealUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MealUpsertArgs<ExtArgs>>
    ): Prisma__MealClient<$Types.GetResult<MealPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Meals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealCountArgs} args - Arguments to filter Meals to count.
     * @example
     * // Count the number of Meals
     * const count = await prisma.meal.count({
     *   where: {
     *     // ... the filter for the Meals we want to count
     *   }
     * })
    **/
    count<T extends MealCountArgs>(
      args?: Subset<T, MealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MealAggregateArgs>(args: Subset<T, MealAggregateArgs>): Prisma.PrismaPromise<GetMealAggregateType<T>>

    /**
     * Group by Meal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MealGroupByArgs['orderBy'] }
        : { orderBy?: MealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Meal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MealClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Meal base type for findUnique actions
   */
  export type MealFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where: MealWhereUniqueInput
  }

  /**
   * Meal findUnique
   */
  export interface MealFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MealFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Meal findUniqueOrThrow
   */
  export type MealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where: MealWhereUniqueInput
  }


  /**
   * Meal base type for findFirst actions
   */
  export type MealFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: Enumerable<MealOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meals.
     */
    distinct?: Enumerable<MealScalarFieldEnum>
  }

  /**
   * Meal findFirst
   */
  export interface MealFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends MealFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Meal findFirstOrThrow
   */
  export type MealFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Filter, which Meal to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: Enumerable<MealOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meals.
     */
    distinct?: Enumerable<MealScalarFieldEnum>
  }


  /**
   * Meal findMany
   */
  export type MealFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Filter, which Meals to fetch.
     */
    where?: MealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meals to fetch.
     */
    orderBy?: Enumerable<MealOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meals.
     */
    cursor?: MealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meals.
     */
    skip?: number
    distinct?: Enumerable<MealScalarFieldEnum>
  }


  /**
   * Meal create
   */
  export type MealCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * The data needed to create a Meal.
     */
    data: XOR<MealCreateInput, MealUncheckedCreateInput>
  }


  /**
   * Meal createMany
   */
  export type MealCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meals.
     */
    data: Enumerable<MealCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Meal update
   */
  export type MealUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * The data needed to update a Meal.
     */
    data: XOR<MealUpdateInput, MealUncheckedUpdateInput>
    /**
     * Choose, which Meal to update.
     */
    where: MealWhereUniqueInput
  }


  /**
   * Meal updateMany
   */
  export type MealUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meals.
     */
    data: XOR<MealUpdateManyMutationInput, MealUncheckedUpdateManyInput>
    /**
     * Filter which Meals to update
     */
    where?: MealWhereInput
  }


  /**
   * Meal upsert
   */
  export type MealUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * The filter to search for the Meal to update in case it exists.
     */
    where: MealWhereUniqueInput
    /**
     * In case the Meal found by the `where` argument doesn't exist, create a new Meal with this data.
     */
    create: XOR<MealCreateInput, MealUncheckedCreateInput>
    /**
     * In case the Meal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MealUpdateInput, MealUncheckedUpdateInput>
  }


  /**
   * Meal delete
   */
  export type MealDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
    /**
     * Filter which Meal to delete.
     */
    where: MealWhereUniqueInput
  }


  /**
   * Meal deleteMany
   */
  export type MealDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meals to delete
     */
    where?: MealWhereInput
  }


  /**
   * Meal without action
   */
  export type MealArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meal
     */
    select?: MealSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    profile: 'profile',
    isVerified: 'isVerified',
    phone: 'phone',
    createdAt: 'createdAt',
    provider: 'provider',
    userSchoolId: 'userSchoolId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    schoolId: 'schoolId',
    org: 'org',
    x: 'x',
    y: 'y',
    atptCode: 'atptCode',
    defaultName: 'defaultName',
    name: 'name',
    type: 'type'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    id: 'id',
    key: 'key',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const PhoneVerifyRequestScalarFieldEnum: {
    id: 'id',
    phone: 'phone',
    code: 'code'
  };

  export type PhoneVerifyRequestScalarFieldEnum = (typeof PhoneVerifyRequestScalarFieldEnum)[keyof typeof PhoneVerifyRequestScalarFieldEnum]


  export const SocialLoginScalarFieldEnum: {
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    userId: 'userId',
    socialId: 'socialId',
    provider: 'provider'
  };

  export type SocialLoginScalarFieldEnum = (typeof SocialLoginScalarFieldEnum)[keyof typeof SocialLoginScalarFieldEnum]


  export const AgreementScalarFieldEnum: {
    updatedAt: 'updatedAt',
    userId: 'userId',
    receive: 'receive'
  };

  export type AgreementScalarFieldEnum = (typeof AgreementScalarFieldEnum)[keyof typeof AgreementScalarFieldEnum]


  export const UserSchoolVerifyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    imageId: 'imageId',
    schoolId: 'schoolId',
    grade: 'grade',
    class: 'class',
    message: 'message',
    process: 'process',
    createdAt: 'createdAt',
    schoolName: 'schoolName',
    userName: 'userName',
    dept: 'dept'
  };

  export type UserSchoolVerifyScalarFieldEnum = (typeof UserSchoolVerifyScalarFieldEnum)[keyof typeof UserSchoolVerifyScalarFieldEnum]


  export const UserSchoolScalarFieldEnum: {
    userId: 'userId',
    schoolId: 'schoolId',
    dept: 'dept',
    grade: 'grade',
    class: 'class'
  };

  export type UserSchoolScalarFieldEnum = (typeof UserSchoolScalarFieldEnum)[keyof typeof UserSchoolScalarFieldEnum]


  export const BusStationScalarFieldEnum: {
    busStationId: 'busStationId',
    busStationName: 'busStationName',
    address: 'address',
    x: 'x',
    y: 'y'
  };

  export type BusStationScalarFieldEnum = (typeof BusStationScalarFieldEnum)[keyof typeof BusStationScalarFieldEnum]


  export const BusRouteScalarFieldEnum: {
    busRouteId: 'busRouteId',
    busRouteNum: 'busRouteNum',
    busRouteTp: 'busRouteTp',
    endNodeName: 'endNodeName',
    startNodeName: 'startNodeName',
    endVehicleTime: 'endVehicleTime',
    startVehicleTime: 'startVehicleTime',
    intervalTime: 'intervalTime',
    intervalSatTime: 'intervalSatTime',
    intervalSunTime: 'intervalSunTime'
  };

  export type BusRouteScalarFieldEnum = (typeof BusRouteScalarFieldEnum)[keyof typeof BusRouteScalarFieldEnum]


  export const BusArrivalScalarFieldEnum: {
    busStationId: 'busStationId',
    busStationName: 'busStationName',
    busRouteNum: 'busRouteNum',
    busRouteTp: 'busRouteTp',
    arrprevStationCnt: 'arrprevStationCnt',
    arrTime: 'arrTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusArrivalScalarFieldEnum = (typeof BusArrivalScalarFieldEnum)[keyof typeof BusArrivalScalarFieldEnum]


  export const AskedUserScalarFieldEnum: {
    userId: 'userId',
    customId: 'customId',
    statusMessage: 'statusMessage',
    receiveAnonymous: 'receiveAnonymous',
    receiveOtherSchool: 'receiveOtherSchool',
    lastUpdateCustomId: 'lastUpdateCustomId'
  };

  export type AskedUserScalarFieldEnum = (typeof AskedUserScalarFieldEnum)[keyof typeof AskedUserScalarFieldEnum]


  export const AskedScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    askedUserId: 'askedUserId',
    process: 'process',
    question: 'question',
    answer: 'answer',
    createdAt: 'createdAt',
    answerTimeAt: 'answerTimeAt',
    isAnonymous: 'isAnonymous'
  };

  export type AskedScalarFieldEnum = (typeof AskedScalarFieldEnum)[keyof typeof AskedScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    loginId: 'loginId',
    password: 'password',
    flags: 'flags'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const BoardScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    description: 'description',
    default: 'default',
    noticeId: 'noticeId'
  };

  export type BoardScalarFieldEnum = (typeof BoardScalarFieldEnum)[keyof typeof BoardScalarFieldEnum]


  export const BoardManagerScalarFieldEnum: {
    id: 'id',
    boardId: 'boardId',
    name: 'name',
    userId: 'userId'
  };

  export type BoardManagerScalarFieldEnum = (typeof BoardManagerScalarFieldEnum)[keyof typeof BoardManagerScalarFieldEnum]


  export const ArticleScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    title: 'title',
    content: 'content',
    images: 'images',
    isAnonymous: 'isAnonymous',
    userId: 'userId',
    createdAt: 'createdAt',
    boardId: 'boardId'
  };

  export type ArticleScalarFieldEnum = (typeof ArticleScalarFieldEnum)[keyof typeof ArticleScalarFieldEnum]


  export const DeletedArticleScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    title: 'title',
    content: 'content',
    images: 'images',
    isAnonymous: 'isAnonymous',
    userId: 'userId',
    createdAt: 'createdAt',
    DeletedAt: 'DeletedAt',
    boardId: 'boardId'
  };

  export type DeletedArticleScalarFieldEnum = (typeof DeletedArticleScalarFieldEnum)[keyof typeof DeletedArticleScalarFieldEnum]


  export const BoardRequestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    userId: 'userId',
    schoolId: 'schoolId',
    schoolName: 'schoolName',
    process: 'process',
    message: 'message'
  };

  export type BoardRequestScalarFieldEnum = (typeof BoardRequestScalarFieldEnum)[keyof typeof BoardRequestScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    userId: 'userId',
    content: 'content',
    isAnonymous: 'isAnonymous',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    articleId: 'articleId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ReCommentScalarFieldEnum: {
    id: 'id',
    articleId: 'articleId',
    userId: 'userId',
    content: 'content',
    isAnonymous: 'isAnonymous',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    commentId: 'commentId'
  };

  export type ReCommentScalarFieldEnum = (typeof ReCommentScalarFieldEnum)[keyof typeof ReCommentScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    reportUserId: 'reportUserId',
    targetType: 'targetType',
    message: 'message',
    targetId: 'targetId',
    reportUserName: 'reportUserName',
    process: 'process'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const LikeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    targetId: 'targetId',
    targetType: 'targetType',
    likeType: 'likeType'
  };

  export type LikeScalarFieldEnum = (typeof LikeScalarFieldEnum)[keyof typeof LikeScalarFieldEnum]


  export const MealScalarFieldEnum: {
    id: 'id',
    MLSV_FGR: 'MLSV_FGR',
    DDISH_NM: 'DDISH_NM',
    ORPLC_INFO: 'ORPLC_INFO',
    CAL_INFO: 'CAL_INFO',
    NTR_INFO: 'NTR_INFO'
  };

  export type MealScalarFieldEnum = (typeof MealScalarFieldEnum)[keyof typeof MealScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: StringFilter | string
    email?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    name?: StringFilter | string
    profile?: StringNullableFilter | string | null
    isVerified?: BoolFilter | boolean
    phone?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    provider?: EnumUserLoginProviderTypeFilter | UserLoginProviderType
    userSchoolId?: StringNullableFilter | string | null
    Agreement?: XOR<AgreementRelationFilter, AgreementWhereInput> | null
    Article?: ArticleListRelationFilter
    Asked?: AskedListRelationFilter
    AskedUser?: XOR<AskedUserRelationFilter, AskedUserWhereInput> | null
    BoardOrganizations?: BoardManagerListRelationFilter
    Comment?: CommentListRelationFilter
    Image?: ImageListRelationFilter
    Like?: LikeListRelationFilter
    ReComment?: ReCommentListRelationFilter
    SocialLogin?: XOR<SocialLoginRelationFilter, SocialLoginWhereInput> | null
    UserSchool?: XOR<UserSchoolRelationFilter, UserSchoolWhereInput> | null
    UserSchoolVerify?: UserSchoolVerifyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrder
    profile?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    provider?: SortOrder
    userSchoolId?: SortOrderInput | SortOrder
    Agreement?: AgreementOrderByWithRelationInput
    Article?: ArticleOrderByRelationAggregateInput
    Asked?: AskedOrderByRelationAggregateInput
    AskedUser?: AskedUserOrderByWithRelationInput
    BoardOrganizations?: BoardManagerOrderByRelationAggregateInput
    Comment?: CommentOrderByRelationAggregateInput
    Image?: ImageOrderByRelationAggregateInput
    Like?: LikeOrderByRelationAggregateInput
    ReComment?: ReCommentOrderByRelationAggregateInput
    SocialLogin?: SocialLoginOrderByWithRelationInput
    UserSchool?: UserSchoolOrderByWithRelationInput
    UserSchoolVerify?: UserSchoolVerifyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    phone?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrder
    profile?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    provider?: SortOrder
    userSchoolId?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
    name?: StringWithAggregatesFilter | string
    profile?: StringNullableWithAggregatesFilter | string | null
    isVerified?: BoolWithAggregatesFilter | boolean
    phone?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    provider?: EnumUserLoginProviderTypeWithAggregatesFilter | UserLoginProviderType
    userSchoolId?: StringNullableWithAggregatesFilter | string | null
  }

  export type SchoolWhereInput = {
    AND?: Enumerable<SchoolWhereInput>
    OR?: Enumerable<SchoolWhereInput>
    NOT?: Enumerable<SchoolWhereInput>
    schoolId?: StringFilter | string
    org?: StringFilter | string
    x?: FloatFilter | number
    y?: FloatFilter | number
    atptCode?: StringFilter | string
    defaultName?: StringFilter | string
    name?: StringNullableFilter | string | null
    type?: StringFilter | string
    UserSchool?: UserSchoolListRelationFilter
    Article?: ArticleListRelationFilter
  }

  export type SchoolOrderByWithRelationInput = {
    schoolId?: SortOrder
    org?: SortOrder
    x?: SortOrder
    y?: SortOrder
    atptCode?: SortOrder
    defaultName?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    UserSchool?: UserSchoolOrderByRelationAggregateInput
    Article?: ArticleOrderByRelationAggregateInput
  }

  export type SchoolWhereUniqueInput = {
    schoolId?: string
  }

  export type SchoolOrderByWithAggregationInput = {
    schoolId?: SortOrder
    org?: SortOrder
    x?: SortOrder
    y?: SortOrder
    atptCode?: SortOrder
    defaultName?: SortOrder
    name?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: SchoolCountOrderByAggregateInput
    _avg?: SchoolAvgOrderByAggregateInput
    _max?: SchoolMaxOrderByAggregateInput
    _min?: SchoolMinOrderByAggregateInput
    _sum?: SchoolSumOrderByAggregateInput
  }

  export type SchoolScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SchoolScalarWhereWithAggregatesInput>
    OR?: Enumerable<SchoolScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SchoolScalarWhereWithAggregatesInput>
    schoolId?: StringWithAggregatesFilter | string
    org?: StringWithAggregatesFilter | string
    x?: FloatWithAggregatesFilter | number
    y?: FloatWithAggregatesFilter | number
    atptCode?: StringWithAggregatesFilter | string
    defaultName?: StringWithAggregatesFilter | string
    name?: StringNullableWithAggregatesFilter | string | null
    type?: StringWithAggregatesFilter | string
  }

  export type ImageWhereInput = {
    AND?: Enumerable<ImageWhereInput>
    OR?: Enumerable<ImageWhereInput>
    NOT?: Enumerable<ImageWhereInput>
    id?: StringFilter | string
    key?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    UserSchoolVerify?: UserSchoolVerifyListRelationFilter
  }

  export type ImageOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    UserSchoolVerify?: UserSchoolVerifyOrderByRelationAggregateInput
  }

  export type ImageWhereUniqueInput = {
    id?: string
  }

  export type ImageOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ImageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ImageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ImageScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    key?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type PhoneVerifyRequestWhereInput = {
    AND?: Enumerable<PhoneVerifyRequestWhereInput>
    OR?: Enumerable<PhoneVerifyRequestWhereInput>
    NOT?: Enumerable<PhoneVerifyRequestWhereInput>
    id?: StringFilter | string
    phone?: StringFilter | string
    code?: StringFilter | string
  }

  export type PhoneVerifyRequestOrderByWithRelationInput = {
    id?: SortOrder
    phone?: SortOrder
    code?: SortOrder
  }

  export type PhoneVerifyRequestWhereUniqueInput = {
    id?: string
  }

  export type PhoneVerifyRequestOrderByWithAggregationInput = {
    id?: SortOrder
    phone?: SortOrder
    code?: SortOrder
    _count?: PhoneVerifyRequestCountOrderByAggregateInput
    _max?: PhoneVerifyRequestMaxOrderByAggregateInput
    _min?: PhoneVerifyRequestMinOrderByAggregateInput
  }

  export type PhoneVerifyRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PhoneVerifyRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<PhoneVerifyRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PhoneVerifyRequestScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
  }

  export type SocialLoginWhereInput = {
    AND?: Enumerable<SocialLoginWhereInput>
    OR?: Enumerable<SocialLoginWhereInput>
    NOT?: Enumerable<SocialLoginWhereInput>
    accessToken?: StringFilter | string
    refreshToken?: StringNullableFilter | string | null
    userId?: StringFilter | string
    socialId?: StringFilter | string
    provider?: EnumSocialLoginProviderTypeFilter | SocialLoginProviderType
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SocialLoginOrderByWithRelationInput = {
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    userId?: SortOrder
    socialId?: SortOrder
    provider?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SocialLoginWhereUniqueInput = {
    userId?: string
    socialId?: string
  }

  export type SocialLoginOrderByWithAggregationInput = {
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    userId?: SortOrder
    socialId?: SortOrder
    provider?: SortOrder
    _count?: SocialLoginCountOrderByAggregateInput
    _max?: SocialLoginMaxOrderByAggregateInput
    _min?: SocialLoginMinOrderByAggregateInput
  }

  export type SocialLoginScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SocialLoginScalarWhereWithAggregatesInput>
    OR?: Enumerable<SocialLoginScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SocialLoginScalarWhereWithAggregatesInput>
    accessToken?: StringWithAggregatesFilter | string
    refreshToken?: StringNullableWithAggregatesFilter | string | null
    userId?: StringWithAggregatesFilter | string
    socialId?: StringWithAggregatesFilter | string
    provider?: EnumSocialLoginProviderTypeWithAggregatesFilter | SocialLoginProviderType
  }

  export type AgreementWhereInput = {
    AND?: Enumerable<AgreementWhereInput>
    OR?: Enumerable<AgreementWhereInput>
    NOT?: Enumerable<AgreementWhereInput>
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    receive?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AgreementOrderByWithRelationInput = {
    updatedAt?: SortOrder
    userId?: SortOrder
    receive?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AgreementWhereUniqueInput = {
    userId?: string
  }

  export type AgreementOrderByWithAggregationInput = {
    updatedAt?: SortOrder
    userId?: SortOrder
    receive?: SortOrder
    _count?: AgreementCountOrderByAggregateInput
    _max?: AgreementMaxOrderByAggregateInput
    _min?: AgreementMinOrderByAggregateInput
  }

  export type AgreementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AgreementScalarWhereWithAggregatesInput>
    OR?: Enumerable<AgreementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AgreementScalarWhereWithAggregatesInput>
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
    receive?: BoolWithAggregatesFilter | boolean
  }

  export type UserSchoolVerifyWhereInput = {
    AND?: Enumerable<UserSchoolVerifyWhereInput>
    OR?: Enumerable<UserSchoolVerifyWhereInput>
    NOT?: Enumerable<UserSchoolVerifyWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    imageId?: StringFilter | string
    schoolId?: StringFilter | string
    grade?: StringFilter | string
    class?: StringFilter | string
    message?: StringNullableFilter | string | null
    process?: EnumProcessFilter | Process
    createdAt?: DateTimeFilter | Date | string
    schoolName?: StringFilter | string
    userName?: StringFilter | string
    dept?: StringFilter | string
    image?: XOR<ImageRelationFilter, ImageWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSchoolVerifyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    imageId?: SortOrder
    schoolId?: SortOrder
    grade?: SortOrder
    class?: SortOrder
    message?: SortOrderInput | SortOrder
    process?: SortOrder
    createdAt?: SortOrder
    schoolName?: SortOrder
    userName?: SortOrder
    dept?: SortOrder
    image?: ImageOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserSchoolVerifyWhereUniqueInput = {
    id?: string
  }

  export type UserSchoolVerifyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    imageId?: SortOrder
    schoolId?: SortOrder
    grade?: SortOrder
    class?: SortOrder
    message?: SortOrderInput | SortOrder
    process?: SortOrder
    createdAt?: SortOrder
    schoolName?: SortOrder
    userName?: SortOrder
    dept?: SortOrder
    _count?: UserSchoolVerifyCountOrderByAggregateInput
    _max?: UserSchoolVerifyMaxOrderByAggregateInput
    _min?: UserSchoolVerifyMinOrderByAggregateInput
  }

  export type UserSchoolVerifyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserSchoolVerifyScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserSchoolVerifyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserSchoolVerifyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    imageId?: StringWithAggregatesFilter | string
    schoolId?: StringWithAggregatesFilter | string
    grade?: StringWithAggregatesFilter | string
    class?: StringWithAggregatesFilter | string
    message?: StringNullableWithAggregatesFilter | string | null
    process?: EnumProcessWithAggregatesFilter | Process
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    schoolName?: StringWithAggregatesFilter | string
    userName?: StringWithAggregatesFilter | string
    dept?: StringWithAggregatesFilter | string
  }

  export type UserSchoolWhereInput = {
    AND?: Enumerable<UserSchoolWhereInput>
    OR?: Enumerable<UserSchoolWhereInput>
    NOT?: Enumerable<UserSchoolWhereInput>
    userId?: StringFilter | string
    schoolId?: StringFilter | string
    dept?: StringFilter | string
    grade?: StringFilter | string
    class?: StringFilter | string
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSchoolOrderByWithRelationInput = {
    userId?: SortOrder
    schoolId?: SortOrder
    dept?: SortOrder
    grade?: SortOrder
    class?: SortOrder
    school?: SchoolOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type UserSchoolWhereUniqueInput = {
    userId?: string
  }

  export type UserSchoolOrderByWithAggregationInput = {
    userId?: SortOrder
    schoolId?: SortOrder
    dept?: SortOrder
    grade?: SortOrder
    class?: SortOrder
    _count?: UserSchoolCountOrderByAggregateInput
    _max?: UserSchoolMaxOrderByAggregateInput
    _min?: UserSchoolMinOrderByAggregateInput
  }

  export type UserSchoolScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserSchoolScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserSchoolScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserSchoolScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    schoolId?: StringWithAggregatesFilter | string
    dept?: StringWithAggregatesFilter | string
    grade?: StringWithAggregatesFilter | string
    class?: StringWithAggregatesFilter | string
  }

  export type BusStationWhereInput = {
    AND?: Enumerable<BusStationWhereInput>
    OR?: Enumerable<BusStationWhereInput>
    NOT?: Enumerable<BusStationWhereInput>
    busStationId?: StringFilter | string
    busStationName?: StringFilter | string
    address?: StringFilter | string
    x?: FloatFilter | number
    y?: FloatFilter | number
  }

  export type BusStationOrderByWithRelationInput = {
    busStationId?: SortOrder
    busStationName?: SortOrder
    address?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type BusStationWhereUniqueInput = {
    busStationId?: string
  }

  export type BusStationOrderByWithAggregationInput = {
    busStationId?: SortOrder
    busStationName?: SortOrder
    address?: SortOrder
    x?: SortOrder
    y?: SortOrder
    _count?: BusStationCountOrderByAggregateInput
    _avg?: BusStationAvgOrderByAggregateInput
    _max?: BusStationMaxOrderByAggregateInput
    _min?: BusStationMinOrderByAggregateInput
    _sum?: BusStationSumOrderByAggregateInput
  }

  export type BusStationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusStationScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusStationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusStationScalarWhereWithAggregatesInput>
    busStationId?: StringWithAggregatesFilter | string
    busStationName?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    x?: FloatWithAggregatesFilter | number
    y?: FloatWithAggregatesFilter | number
  }

  export type BusRouteWhereInput = {
    AND?: Enumerable<BusRouteWhereInput>
    OR?: Enumerable<BusRouteWhereInput>
    NOT?: Enumerable<BusRouteWhereInput>
    busRouteId?: StringFilter | string
    busRouteNum?: StringFilter | string
    busRouteTp?: StringFilter | string
    endNodeName?: StringFilter | string
    startNodeName?: StringFilter | string
    endVehicleTime?: StringFilter | string
    startVehicleTime?: StringFilter | string
    intervalTime?: StringFilter | string
    intervalSatTime?: StringFilter | string
    intervalSunTime?: StringFilter | string
  }

  export type BusRouteOrderByWithRelationInput = {
    busRouteId?: SortOrder
    busRouteNum?: SortOrder
    busRouteTp?: SortOrder
    endNodeName?: SortOrder
    startNodeName?: SortOrder
    endVehicleTime?: SortOrder
    startVehicleTime?: SortOrder
    intervalTime?: SortOrder
    intervalSatTime?: SortOrder
    intervalSunTime?: SortOrder
  }

  export type BusRouteWhereUniqueInput = {
    busRouteId?: string
  }

  export type BusRouteOrderByWithAggregationInput = {
    busRouteId?: SortOrder
    busRouteNum?: SortOrder
    busRouteTp?: SortOrder
    endNodeName?: SortOrder
    startNodeName?: SortOrder
    endVehicleTime?: SortOrder
    startVehicleTime?: SortOrder
    intervalTime?: SortOrder
    intervalSatTime?: SortOrder
    intervalSunTime?: SortOrder
    _count?: BusRouteCountOrderByAggregateInput
    _max?: BusRouteMaxOrderByAggregateInput
    _min?: BusRouteMinOrderByAggregateInput
  }

  export type BusRouteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusRouteScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusRouteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusRouteScalarWhereWithAggregatesInput>
    busRouteId?: StringWithAggregatesFilter | string
    busRouteNum?: StringWithAggregatesFilter | string
    busRouteTp?: StringWithAggregatesFilter | string
    endNodeName?: StringWithAggregatesFilter | string
    startNodeName?: StringWithAggregatesFilter | string
    endVehicleTime?: StringWithAggregatesFilter | string
    startVehicleTime?: StringWithAggregatesFilter | string
    intervalTime?: StringWithAggregatesFilter | string
    intervalSatTime?: StringWithAggregatesFilter | string
    intervalSunTime?: StringWithAggregatesFilter | string
  }

  export type BusArrivalWhereInput = {
    AND?: Enumerable<BusArrivalWhereInput>
    OR?: Enumerable<BusArrivalWhereInput>
    NOT?: Enumerable<BusArrivalWhereInput>
    busStationId?: StringFilter | string
    busStationName?: StringFilter | string
    busRouteNum?: StringFilter | string
    busRouteTp?: StringFilter | string
    arrprevStationCnt?: StringFilter | string
    arrTime?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type BusArrivalOrderByWithRelationInput = {
    busStationId?: SortOrder
    busStationName?: SortOrder
    busRouteNum?: SortOrder
    busRouteTp?: SortOrder
    arrprevStationCnt?: SortOrder
    arrTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusArrivalWhereUniqueInput = {
    busStationId?: string
  }

  export type BusArrivalOrderByWithAggregationInput = {
    busStationId?: SortOrder
    busStationName?: SortOrder
    busRouteNum?: SortOrder
    busRouteTp?: SortOrder
    arrprevStationCnt?: SortOrder
    arrTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusArrivalCountOrderByAggregateInput
    _max?: BusArrivalMaxOrderByAggregateInput
    _min?: BusArrivalMinOrderByAggregateInput
  }

  export type BusArrivalScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BusArrivalScalarWhereWithAggregatesInput>
    OR?: Enumerable<BusArrivalScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BusArrivalScalarWhereWithAggregatesInput>
    busStationId?: StringWithAggregatesFilter | string
    busStationName?: StringWithAggregatesFilter | string
    busRouteNum?: StringWithAggregatesFilter | string
    busRouteTp?: StringWithAggregatesFilter | string
    arrprevStationCnt?: StringWithAggregatesFilter | string
    arrTime?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AskedUserWhereInput = {
    AND?: Enumerable<AskedUserWhereInput>
    OR?: Enumerable<AskedUserWhereInput>
    NOT?: Enumerable<AskedUserWhereInput>
    userId?: StringFilter | string
    customId?: StringNullableFilter | string | null
    statusMessage?: StringNullableFilter | string | null
    receiveAnonymous?: BoolFilter | boolean
    receiveOtherSchool?: BoolFilter | boolean
    lastUpdateCustomId?: DateTimeNullableFilter | Date | string | null
    Asked?: AskedListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AskedUserOrderByWithRelationInput = {
    userId?: SortOrder
    customId?: SortOrderInput | SortOrder
    statusMessage?: SortOrderInput | SortOrder
    receiveAnonymous?: SortOrder
    receiveOtherSchool?: SortOrder
    lastUpdateCustomId?: SortOrderInput | SortOrder
    Asked?: AskedOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
  }

  export type AskedUserWhereUniqueInput = {
    userId?: string
  }

  export type AskedUserOrderByWithAggregationInput = {
    userId?: SortOrder
    customId?: SortOrderInput | SortOrder
    statusMessage?: SortOrderInput | SortOrder
    receiveAnonymous?: SortOrder
    receiveOtherSchool?: SortOrder
    lastUpdateCustomId?: SortOrderInput | SortOrder
    _count?: AskedUserCountOrderByAggregateInput
    _max?: AskedUserMaxOrderByAggregateInput
    _min?: AskedUserMinOrderByAggregateInput
  }

  export type AskedUserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AskedUserScalarWhereWithAggregatesInput>
    OR?: Enumerable<AskedUserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AskedUserScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    customId?: StringNullableWithAggregatesFilter | string | null
    statusMessage?: StringNullableWithAggregatesFilter | string | null
    receiveAnonymous?: BoolWithAggregatesFilter | boolean
    receiveOtherSchool?: BoolWithAggregatesFilter | boolean
    lastUpdateCustomId?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AskedWhereInput = {
    AND?: Enumerable<AskedWhereInput>
    OR?: Enumerable<AskedWhereInput>
    NOT?: Enumerable<AskedWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    askedUserId?: StringFilter | string
    process?: EnumProcessFilter | Process
    question?: StringFilter | string
    answer?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    answerTimeAt?: DateTimeNullableFilter | Date | string | null
    isAnonymous?: BoolFilter | boolean
    AskedUser?: XOR<AskedUserRelationFilter, AskedUserWhereInput>
    QuestionUser?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AskedOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    askedUserId?: SortOrder
    process?: SortOrder
    question?: SortOrder
    answer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    answerTimeAt?: SortOrderInput | SortOrder
    isAnonymous?: SortOrder
    AskedUser?: AskedUserOrderByWithRelationInput
    QuestionUser?: UserOrderByWithRelationInput
  }

  export type AskedWhereUniqueInput = {
    id?: string
  }

  export type AskedOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    askedUserId?: SortOrder
    process?: SortOrder
    question?: SortOrder
    answer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    answerTimeAt?: SortOrderInput | SortOrder
    isAnonymous?: SortOrder
    _count?: AskedCountOrderByAggregateInput
    _max?: AskedMaxOrderByAggregateInput
    _min?: AskedMinOrderByAggregateInput
  }

  export type AskedScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AskedScalarWhereWithAggregatesInput>
    OR?: Enumerable<AskedScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AskedScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    askedUserId?: StringWithAggregatesFilter | string
    process?: EnumProcessWithAggregatesFilter | Process
    question?: StringWithAggregatesFilter | string
    answer?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    answerTimeAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isAnonymous?: BoolWithAggregatesFilter | boolean
  }

  export type AdminWhereInput = {
    AND?: Enumerable<AdminWhereInput>
    OR?: Enumerable<AdminWhereInput>
    NOT?: Enumerable<AdminWhereInput>
    id?: StringFilter | string
    loginId?: StringFilter | string
    password?: StringFilter | string
    flags?: IntFilter | number
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    flags?: SortOrder
  }

  export type AdminWhereUniqueInput = {
    id?: string
    loginId?: string
  }

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    flags?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _avg?: AdminAvgOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
    _sum?: AdminSumOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AdminScalarWhereWithAggregatesInput>
    OR?: Enumerable<AdminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AdminScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    loginId?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    flags?: IntWithAggregatesFilter | number
  }

  export type BoardWhereInput = {
    AND?: Enumerable<BoardWhereInput>
    OR?: Enumerable<BoardWhereInput>
    NOT?: Enumerable<BoardWhereInput>
    id?: IntFilter | number
    schoolId?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    default?: BoolFilter | boolean
    noticeId?: IntNullableListFilter
    Article?: ArticleListRelationFilter
    managers?: BoardManagerListRelationFilter
  }

  export type BoardOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    default?: SortOrder
    noticeId?: SortOrder
    Article?: ArticleOrderByRelationAggregateInput
    managers?: BoardManagerOrderByRelationAggregateInput
  }

  export type BoardWhereUniqueInput = {
    id?: number
  }

  export type BoardOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    default?: SortOrder
    noticeId?: SortOrder
    _count?: BoardCountOrderByAggregateInput
    _avg?: BoardAvgOrderByAggregateInput
    _max?: BoardMaxOrderByAggregateInput
    _min?: BoardMinOrderByAggregateInput
    _sum?: BoardSumOrderByAggregateInput
  }

  export type BoardScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    schoolId?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    default?: BoolWithAggregatesFilter | boolean
    noticeId?: IntNullableListFilter
  }

  export type BoardManagerWhereInput = {
    AND?: Enumerable<BoardManagerWhereInput>
    OR?: Enumerable<BoardManagerWhereInput>
    NOT?: Enumerable<BoardManagerWhereInput>
    id?: StringFilter | string
    boardId?: IntFilter | number
    name?: StringFilter | string
    userId?: StringFilter | string
    board?: XOR<BoardRelationFilter, BoardWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type BoardManagerOrderByWithRelationInput = {
    id?: SortOrder
    boardId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    board?: BoardOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type BoardManagerWhereUniqueInput = {
    id?: string
  }

  export type BoardManagerOrderByWithAggregationInput = {
    id?: SortOrder
    boardId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    _count?: BoardManagerCountOrderByAggregateInput
    _avg?: BoardManagerAvgOrderByAggregateInput
    _max?: BoardManagerMaxOrderByAggregateInput
    _min?: BoardManagerMinOrderByAggregateInput
    _sum?: BoardManagerSumOrderByAggregateInput
  }

  export type BoardManagerScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardManagerScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardManagerScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardManagerScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    boardId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
  }

  export type ArticleWhereInput = {
    AND?: Enumerable<ArticleWhereInput>
    OR?: Enumerable<ArticleWhereInput>
    NOT?: Enumerable<ArticleWhereInput>
    id?: IntFilter | number
    schoolId?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    images?: StringNullableListFilter
    isAnonymous?: BoolFilter | boolean
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    boardId?: IntFilter | number
    Board?: XOR<BoardRelationFilter, BoardWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
    school?: XOR<SchoolRelationFilter, SchoolWhereInput>
    Comment?: CommentListRelationFilter
    ReComment?: ReCommentListRelationFilter
  }

  export type ArticleOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    isAnonymous?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    boardId?: SortOrder
    Board?: BoardOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    school?: SchoolOrderByWithRelationInput
    Comment?: CommentOrderByRelationAggregateInput
    ReComment?: ReCommentOrderByRelationAggregateInput
  }

  export type ArticleWhereUniqueInput = {
    id?: number
  }

  export type ArticleOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    isAnonymous?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    boardId?: SortOrder
    _count?: ArticleCountOrderByAggregateInput
    _avg?: ArticleAvgOrderByAggregateInput
    _max?: ArticleMaxOrderByAggregateInput
    _min?: ArticleMinOrderByAggregateInput
    _sum?: ArticleSumOrderByAggregateInput
  }

  export type ArticleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ArticleScalarWhereWithAggregatesInput>
    OR?: Enumerable<ArticleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ArticleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    schoolId?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    images?: StringNullableListFilter
    isAnonymous?: BoolWithAggregatesFilter | boolean
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    boardId?: IntWithAggregatesFilter | number
  }

  export type DeletedArticleWhereInput = {
    AND?: Enumerable<DeletedArticleWhereInput>
    OR?: Enumerable<DeletedArticleWhereInput>
    NOT?: Enumerable<DeletedArticleWhereInput>
    id?: IntFilter | number
    schoolId?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    images?: StringNullableListFilter
    isAnonymous?: BoolFilter | boolean
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    DeletedAt?: DateTimeFilter | Date | string
    boardId?: IntFilter | number
  }

  export type DeletedArticleOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    isAnonymous?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    DeletedAt?: SortOrder
    boardId?: SortOrder
  }

  export type DeletedArticleWhereUniqueInput = {
    id?: number
  }

  export type DeletedArticleOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    isAnonymous?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    DeletedAt?: SortOrder
    boardId?: SortOrder
    _count?: DeletedArticleCountOrderByAggregateInput
    _avg?: DeletedArticleAvgOrderByAggregateInput
    _max?: DeletedArticleMaxOrderByAggregateInput
    _min?: DeletedArticleMinOrderByAggregateInput
    _sum?: DeletedArticleSumOrderByAggregateInput
  }

  export type DeletedArticleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DeletedArticleScalarWhereWithAggregatesInput>
    OR?: Enumerable<DeletedArticleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DeletedArticleScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    schoolId?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    images?: StringNullableListFilter
    isAnonymous?: BoolWithAggregatesFilter | boolean
    userId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    DeletedAt?: DateTimeWithAggregatesFilter | Date | string
    boardId?: IntWithAggregatesFilter | number
  }

  export type BoardRequestWhereInput = {
    AND?: Enumerable<BoardRequestWhereInput>
    OR?: Enumerable<BoardRequestWhereInput>
    NOT?: Enumerable<BoardRequestWhereInput>
    id?: StringFilter | string
    name?: StringFilter | string
    description?: StringFilter | string
    userId?: StringFilter | string
    schoolId?: StringFilter | string
    schoolName?: StringFilter | string
    process?: EnumBoardRequestProcessFilter | BoardRequestProcess
    message?: StringNullableFilter | string | null
  }

  export type BoardRequestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    schoolName?: SortOrder
    process?: SortOrder
    message?: SortOrderInput | SortOrder
  }

  export type BoardRequestWhereUniqueInput = {
    id?: string
  }

  export type BoardRequestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    schoolName?: SortOrder
    process?: SortOrder
    message?: SortOrderInput | SortOrder
    _count?: BoardRequestCountOrderByAggregateInput
    _max?: BoardRequestMaxOrderByAggregateInput
    _min?: BoardRequestMinOrderByAggregateInput
  }

  export type BoardRequestScalarWhereWithAggregatesInput = {
    AND?: Enumerable<BoardRequestScalarWhereWithAggregatesInput>
    OR?: Enumerable<BoardRequestScalarWhereWithAggregatesInput>
    NOT?: Enumerable<BoardRequestScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    schoolId?: StringWithAggregatesFilter | string
    schoolName?: StringWithAggregatesFilter | string
    process?: EnumBoardRequestProcessWithAggregatesFilter | BoardRequestProcess
    message?: StringNullableWithAggregatesFilter | string | null
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    userId?: StringFilter | string
    content?: StringFilter | string
    isAnonymous?: BoolFilter | boolean
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    id?: IntFilter | number
    articleId?: IntFilter | number
    Article?: XOR<ArticleRelationFilter, ArticleWhereInput>
    User?: XOR<UserRelationFilter, UserWhereInput>
    recomments?: ReCommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    userId?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    articleId?: SortOrder
    Article?: ArticleOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    recomments?: ReCommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = {
    id?: number
  }

  export type CommentOrderByWithAggregationInput = {
    userId?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    articleId?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    userId?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    isAnonymous?: BoolWithAggregatesFilter | boolean
    isDeleted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    id?: IntWithAggregatesFilter | number
    articleId?: IntWithAggregatesFilter | number
  }

  export type ReCommentWhereInput = {
    AND?: Enumerable<ReCommentWhereInput>
    OR?: Enumerable<ReCommentWhereInput>
    NOT?: Enumerable<ReCommentWhereInput>
    id?: IntFilter | number
    articleId?: IntFilter | number
    userId?: StringFilter | string
    content?: StringFilter | string
    isAnonymous?: BoolFilter | boolean
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    commentId?: IntNullableFilter | number | null
    Article?: XOR<ArticleRelationFilter, ArticleWhereInput>
    Comment?: XOR<CommentRelationFilter, CommentWhereInput> | null
    User?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReCommentOrderByWithRelationInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commentId?: SortOrderInput | SortOrder
    Article?: ArticleOrderByWithRelationInput
    Comment?: CommentOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type ReCommentWhereUniqueInput = {
    id?: number
  }

  export type ReCommentOrderByWithAggregationInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commentId?: SortOrderInput | SortOrder
    _count?: ReCommentCountOrderByAggregateInput
    _avg?: ReCommentAvgOrderByAggregateInput
    _max?: ReCommentMaxOrderByAggregateInput
    _min?: ReCommentMinOrderByAggregateInput
    _sum?: ReCommentSumOrderByAggregateInput
  }

  export type ReCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    articleId?: IntWithAggregatesFilter | number
    userId?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    isAnonymous?: BoolWithAggregatesFilter | boolean
    isDeleted?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    commentId?: IntNullableWithAggregatesFilter | number | null
  }

  export type ReportWhereInput = {
    AND?: Enumerable<ReportWhereInput>
    OR?: Enumerable<ReportWhereInput>
    NOT?: Enumerable<ReportWhereInput>
    id?: StringFilter | string
    reportUserId?: StringFilter | string
    targetType?: EnumReportTargetTypeFilter | ReportTargetType
    message?: StringFilter | string
    targetId?: StringFilter | string
    reportUserName?: StringFilter | string
    process?: EnumReportProcessFilter | ReportProcess
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    reportUserId?: SortOrder
    targetType?: SortOrder
    message?: SortOrder
    targetId?: SortOrder
    reportUserName?: SortOrder
    process?: SortOrder
  }

  export type ReportWhereUniqueInput = {
    id?: string
  }

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    reportUserId?: SortOrder
    targetType?: SortOrder
    message?: SortOrder
    targetId?: SortOrder
    reportUserName?: SortOrder
    process?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ReportScalarWhereWithAggregatesInput>
    OR?: Enumerable<ReportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ReportScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    reportUserId?: StringWithAggregatesFilter | string
    targetType?: EnumReportTargetTypeWithAggregatesFilter | ReportTargetType
    message?: StringWithAggregatesFilter | string
    targetId?: StringWithAggregatesFilter | string
    reportUserName?: StringWithAggregatesFilter | string
    process?: EnumReportProcessWithAggregatesFilter | ReportProcess
  }

  export type LikeWhereInput = {
    AND?: Enumerable<LikeWhereInput>
    OR?: Enumerable<LikeWhereInput>
    NOT?: Enumerable<LikeWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    targetId?: IntFilter | number
    targetType?: EnumLikeTargetTypeFilter | LikeTargetType
    likeType?: EnumLikeTypeFilter | LikeType
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LikeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    likeType?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LikeWhereUniqueInput = {
    id?: string
  }

  export type LikeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    likeType?: SortOrder
    _count?: LikeCountOrderByAggregateInput
    _avg?: LikeAvgOrderByAggregateInput
    _max?: LikeMaxOrderByAggregateInput
    _min?: LikeMinOrderByAggregateInput
    _sum?: LikeSumOrderByAggregateInput
  }

  export type LikeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LikeScalarWhereWithAggregatesInput>
    OR?: Enumerable<LikeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LikeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    targetId?: IntWithAggregatesFilter | number
    targetType?: EnumLikeTargetTypeWithAggregatesFilter | LikeTargetType
    likeType?: EnumLikeTypeWithAggregatesFilter | LikeType
  }

  export type MealWhereInput = {
    AND?: Enumerable<MealWhereInput>
    OR?: Enumerable<MealWhereInput>
    NOT?: Enumerable<MealWhereInput>
    id?: StringFilter | string
    MLSV_FGR?: IntFilter | number
    DDISH_NM?: StringFilter | string
    ORPLC_INFO?: StringFilter | string
    CAL_INFO?: StringFilter | string
    NTR_INFO?: StringFilter | string
  }

  export type MealOrderByWithRelationInput = {
    id?: SortOrder
    MLSV_FGR?: SortOrder
    DDISH_NM?: SortOrder
    ORPLC_INFO?: SortOrder
    CAL_INFO?: SortOrder
    NTR_INFO?: SortOrder
  }

  export type MealWhereUniqueInput = {
    id?: string
  }

  export type MealOrderByWithAggregationInput = {
    id?: SortOrder
    MLSV_FGR?: SortOrder
    DDISH_NM?: SortOrder
    ORPLC_INFO?: SortOrder
    CAL_INFO?: SortOrder
    NTR_INFO?: SortOrder
    _count?: MealCountOrderByAggregateInput
    _avg?: MealAvgOrderByAggregateInput
    _max?: MealMaxOrderByAggregateInput
    _min?: MealMinOrderByAggregateInput
    _sum?: MealSumOrderByAggregateInput
  }

  export type MealScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MealScalarWhereWithAggregatesInput>
    OR?: Enumerable<MealScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MealScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    MLSV_FGR?: IntWithAggregatesFilter | number
    DDISH_NM?: StringWithAggregatesFilter | string
    ORPLC_INFO?: StringWithAggregatesFilter | string
    CAL_INFO?: StringWithAggregatesFilter | string
    NTR_INFO?: StringWithAggregatesFilter | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SchoolCreateInput = {
    schoolId: string
    org: string
    x: number
    y: number
    atptCode: string
    defaultName: string
    name?: string | null
    type: string
    UserSchool?: UserSchoolCreateNestedManyWithoutSchoolInput
    Article?: ArticleCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateInput = {
    schoolId: string
    org: string
    x: number
    y: number
    atptCode: string
    defaultName: string
    name?: string | null
    type: string
    UserSchool?: UserSchoolUncheckedCreateNestedManyWithoutSchoolInput
    Article?: ArticleUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUpdateInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    org?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    atptCode?: StringFieldUpdateOperationsInput | string
    defaultName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    UserSchool?: UserSchoolUpdateManyWithoutSchoolNestedInput
    Article?: ArticleUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    org?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    atptCode?: StringFieldUpdateOperationsInput | string
    defaultName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    UserSchool?: UserSchoolUncheckedUpdateManyWithoutSchoolNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolCreateManyInput = {
    schoolId: string
    org: string
    x: number
    y: number
    atptCode: string
    defaultName: string
    name?: string | null
    type: string
  }

  export type SchoolUpdateManyMutationInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    org?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    atptCode?: StringFieldUpdateOperationsInput | string
    defaultName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolUncheckedUpdateManyInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    org?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    atptCode?: StringFieldUpdateOperationsInput | string
    defaultName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateInput = {
    id?: string
    key: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutImageInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateInput = {
    id?: string
    key: string
    userId: string
    createdAt?: Date | string
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutImageNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageCreateManyInput = {
    id?: string
    key: string
    userId: string
    createdAt?: Date | string
  }

  export type ImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhoneVerifyRequestCreateInput = {
    id?: string
    phone: string
    code: string
  }

  export type PhoneVerifyRequestUncheckedCreateInput = {
    id?: string
    phone: string
    code: string
  }

  export type PhoneVerifyRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneVerifyRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneVerifyRequestCreateManyInput = {
    id?: string
    phone: string
    code: string
  }

  export type PhoneVerifyRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type PhoneVerifyRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type SocialLoginCreateInput = {
    accessToken: string
    refreshToken?: string | null
    socialId: string
    provider: SocialLoginProviderType
    user?: UserCreateNestedOneWithoutSocialLoginInput
  }

  export type SocialLoginUncheckedCreateInput = {
    accessToken: string
    refreshToken?: string | null
    userId?: string
    socialId: string
    provider: SocialLoginProviderType
  }

  export type SocialLoginUpdateInput = {
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: StringFieldUpdateOperationsInput | string
    provider?: EnumSocialLoginProviderTypeFieldUpdateOperationsInput | SocialLoginProviderType
    user?: UserUpdateOneRequiredWithoutSocialLoginNestedInput
  }

  export type SocialLoginUncheckedUpdateInput = {
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    socialId?: StringFieldUpdateOperationsInput | string
    provider?: EnumSocialLoginProviderTypeFieldUpdateOperationsInput | SocialLoginProviderType
  }

  export type SocialLoginCreateManyInput = {
    accessToken: string
    refreshToken?: string | null
    userId?: string
    socialId: string
    provider: SocialLoginProviderType
  }

  export type SocialLoginUpdateManyMutationInput = {
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: StringFieldUpdateOperationsInput | string
    provider?: EnumSocialLoginProviderTypeFieldUpdateOperationsInput | SocialLoginProviderType
  }

  export type SocialLoginUncheckedUpdateManyInput = {
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    socialId?: StringFieldUpdateOperationsInput | string
    provider?: EnumSocialLoginProviderTypeFieldUpdateOperationsInput | SocialLoginProviderType
  }

  export type AgreementCreateInput = {
    updatedAt?: Date | string
    receive?: boolean
    user?: UserCreateNestedOneWithoutAgreementInput
  }

  export type AgreementUncheckedCreateInput = {
    updatedAt?: Date | string
    userId?: string
    receive?: boolean
  }

  export type AgreementUpdateInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutAgreementNestedInput
  }

  export type AgreementUncheckedUpdateInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    receive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AgreementCreateManyInput = {
    updatedAt?: Date | string
    userId?: string
    receive?: boolean
  }

  export type AgreementUpdateManyMutationInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AgreementUncheckedUpdateManyInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    receive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSchoolVerifyCreateInput = {
    id?: string
    schoolId: string
    grade: string
    class: string
    message?: string | null
    process?: Process
    createdAt?: Date | string
    schoolName: string
    userName: string
    dept: string
    image: ImageCreateNestedOneWithoutUserSchoolVerifyInput
    user: UserCreateNestedOneWithoutUserSchoolVerifyInput
  }

  export type UserSchoolVerifyUncheckedCreateInput = {
    id?: string
    userId: string
    imageId: string
    schoolId: string
    grade: string
    class: string
    message?: string | null
    process?: Process
    createdAt?: Date | string
    schoolName: string
    userName: string
    dept: string
  }

  export type UserSchoolVerifyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    process?: EnumProcessFieldUpdateOperationsInput | Process
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
    image?: ImageUpdateOneRequiredWithoutUserSchoolVerifyNestedInput
    user?: UserUpdateOneRequiredWithoutUserSchoolVerifyNestedInput
  }

  export type UserSchoolVerifyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    imageId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    process?: EnumProcessFieldUpdateOperationsInput | Process
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
  }

  export type UserSchoolVerifyCreateManyInput = {
    id?: string
    userId: string
    imageId: string
    schoolId: string
    grade: string
    class: string
    message?: string | null
    process?: Process
    createdAt?: Date | string
    schoolName: string
    userName: string
    dept: string
  }

  export type UserSchoolVerifyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    process?: EnumProcessFieldUpdateOperationsInput | Process
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
  }

  export type UserSchoolVerifyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    imageId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    process?: EnumProcessFieldUpdateOperationsInput | Process
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
  }

  export type UserSchoolCreateInput = {
    dept: string
    grade: string
    class: string
    school: SchoolCreateNestedOneWithoutUserSchoolInput
    user: UserCreateNestedOneWithoutUserSchoolInput
  }

  export type UserSchoolUncheckedCreateInput = {
    userId: string
    schoolId: string
    dept: string
    grade: string
    class: string
  }

  export type UserSchoolUpdateInput = {
    dept?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutUserSchoolNestedInput
    user?: UserUpdateOneRequiredWithoutUserSchoolNestedInput
  }

  export type UserSchoolUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
  }

  export type UserSchoolCreateManyInput = {
    userId: string
    schoolId: string
    dept: string
    grade: string
    class: string
  }

  export type UserSchoolUpdateManyMutationInput = {
    dept?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
  }

  export type UserSchoolUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
  }

  export type BusStationCreateInput = {
    busStationId: string
    busStationName: string
    address: string
    x: number
    y: number
  }

  export type BusStationUncheckedCreateInput = {
    busStationId: string
    busStationName: string
    address: string
    x: number
    y: number
  }

  export type BusStationUpdateInput = {
    busStationId?: StringFieldUpdateOperationsInput | string
    busStationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
  }

  export type BusStationUncheckedUpdateInput = {
    busStationId?: StringFieldUpdateOperationsInput | string
    busStationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
  }

  export type BusStationCreateManyInput = {
    busStationId: string
    busStationName: string
    address: string
    x: number
    y: number
  }

  export type BusStationUpdateManyMutationInput = {
    busStationId?: StringFieldUpdateOperationsInput | string
    busStationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
  }

  export type BusStationUncheckedUpdateManyInput = {
    busStationId?: StringFieldUpdateOperationsInput | string
    busStationName?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
  }

  export type BusRouteCreateInput = {
    busRouteId: string
    busRouteNum: string
    busRouteTp: string
    endNodeName: string
    startNodeName: string
    endVehicleTime: string
    startVehicleTime: string
    intervalTime: string
    intervalSatTime: string
    intervalSunTime: string
  }

  export type BusRouteUncheckedCreateInput = {
    busRouteId: string
    busRouteNum: string
    busRouteTp: string
    endNodeName: string
    startNodeName: string
    endVehicleTime: string
    startVehicleTime: string
    intervalTime: string
    intervalSatTime: string
    intervalSunTime: string
  }

  export type BusRouteUpdateInput = {
    busRouteId?: StringFieldUpdateOperationsInput | string
    busRouteNum?: StringFieldUpdateOperationsInput | string
    busRouteTp?: StringFieldUpdateOperationsInput | string
    endNodeName?: StringFieldUpdateOperationsInput | string
    startNodeName?: StringFieldUpdateOperationsInput | string
    endVehicleTime?: StringFieldUpdateOperationsInput | string
    startVehicleTime?: StringFieldUpdateOperationsInput | string
    intervalTime?: StringFieldUpdateOperationsInput | string
    intervalSatTime?: StringFieldUpdateOperationsInput | string
    intervalSunTime?: StringFieldUpdateOperationsInput | string
  }

  export type BusRouteUncheckedUpdateInput = {
    busRouteId?: StringFieldUpdateOperationsInput | string
    busRouteNum?: StringFieldUpdateOperationsInput | string
    busRouteTp?: StringFieldUpdateOperationsInput | string
    endNodeName?: StringFieldUpdateOperationsInput | string
    startNodeName?: StringFieldUpdateOperationsInput | string
    endVehicleTime?: StringFieldUpdateOperationsInput | string
    startVehicleTime?: StringFieldUpdateOperationsInput | string
    intervalTime?: StringFieldUpdateOperationsInput | string
    intervalSatTime?: StringFieldUpdateOperationsInput | string
    intervalSunTime?: StringFieldUpdateOperationsInput | string
  }

  export type BusRouteCreateManyInput = {
    busRouteId: string
    busRouteNum: string
    busRouteTp: string
    endNodeName: string
    startNodeName: string
    endVehicleTime: string
    startVehicleTime: string
    intervalTime: string
    intervalSatTime: string
    intervalSunTime: string
  }

  export type BusRouteUpdateManyMutationInput = {
    busRouteId?: StringFieldUpdateOperationsInput | string
    busRouteNum?: StringFieldUpdateOperationsInput | string
    busRouteTp?: StringFieldUpdateOperationsInput | string
    endNodeName?: StringFieldUpdateOperationsInput | string
    startNodeName?: StringFieldUpdateOperationsInput | string
    endVehicleTime?: StringFieldUpdateOperationsInput | string
    startVehicleTime?: StringFieldUpdateOperationsInput | string
    intervalTime?: StringFieldUpdateOperationsInput | string
    intervalSatTime?: StringFieldUpdateOperationsInput | string
    intervalSunTime?: StringFieldUpdateOperationsInput | string
  }

  export type BusRouteUncheckedUpdateManyInput = {
    busRouteId?: StringFieldUpdateOperationsInput | string
    busRouteNum?: StringFieldUpdateOperationsInput | string
    busRouteTp?: StringFieldUpdateOperationsInput | string
    endNodeName?: StringFieldUpdateOperationsInput | string
    startNodeName?: StringFieldUpdateOperationsInput | string
    endVehicleTime?: StringFieldUpdateOperationsInput | string
    startVehicleTime?: StringFieldUpdateOperationsInput | string
    intervalTime?: StringFieldUpdateOperationsInput | string
    intervalSatTime?: StringFieldUpdateOperationsInput | string
    intervalSunTime?: StringFieldUpdateOperationsInput | string
  }

  export type BusArrivalCreateInput = {
    busStationId: string
    busStationName: string
    busRouteNum: string
    busRouteTp: string
    arrprevStationCnt: string
    arrTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusArrivalUncheckedCreateInput = {
    busStationId: string
    busStationName: string
    busRouteNum: string
    busRouteTp: string
    arrprevStationCnt: string
    arrTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusArrivalUpdateInput = {
    busStationId?: StringFieldUpdateOperationsInput | string
    busStationName?: StringFieldUpdateOperationsInput | string
    busRouteNum?: StringFieldUpdateOperationsInput | string
    busRouteTp?: StringFieldUpdateOperationsInput | string
    arrprevStationCnt?: StringFieldUpdateOperationsInput | string
    arrTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusArrivalUncheckedUpdateInput = {
    busStationId?: StringFieldUpdateOperationsInput | string
    busStationName?: StringFieldUpdateOperationsInput | string
    busRouteNum?: StringFieldUpdateOperationsInput | string
    busRouteTp?: StringFieldUpdateOperationsInput | string
    arrprevStationCnt?: StringFieldUpdateOperationsInput | string
    arrTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusArrivalCreateManyInput = {
    busStationId: string
    busStationName: string
    busRouteNum: string
    busRouteTp: string
    arrprevStationCnt: string
    arrTime: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusArrivalUpdateManyMutationInput = {
    busStationId?: StringFieldUpdateOperationsInput | string
    busStationName?: StringFieldUpdateOperationsInput | string
    busRouteNum?: StringFieldUpdateOperationsInput | string
    busRouteTp?: StringFieldUpdateOperationsInput | string
    arrprevStationCnt?: StringFieldUpdateOperationsInput | string
    arrTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusArrivalUncheckedUpdateManyInput = {
    busStationId?: StringFieldUpdateOperationsInput | string
    busStationName?: StringFieldUpdateOperationsInput | string
    busRouteNum?: StringFieldUpdateOperationsInput | string
    busRouteTp?: StringFieldUpdateOperationsInput | string
    arrprevStationCnt?: StringFieldUpdateOperationsInput | string
    arrTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AskedUserCreateInput = {
    customId?: string | null
    statusMessage?: string | null
    receiveAnonymous?: boolean
    receiveOtherSchool?: boolean
    lastUpdateCustomId?: Date | string | null
    Asked?: AskedCreateNestedManyWithoutAskedUserInput
    user: UserCreateNestedOneWithoutAskedUserInput
  }

  export type AskedUserUncheckedCreateInput = {
    userId: string
    customId?: string | null
    statusMessage?: string | null
    receiveAnonymous?: boolean
    receiveOtherSchool?: boolean
    lastUpdateCustomId?: Date | string | null
    Asked?: AskedUncheckedCreateNestedManyWithoutAskedUserInput
  }

  export type AskedUserUpdateInput = {
    customId?: NullableStringFieldUpdateOperationsInput | string | null
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    receiveAnonymous?: BoolFieldUpdateOperationsInput | boolean
    receiveOtherSchool?: BoolFieldUpdateOperationsInput | boolean
    lastUpdateCustomId?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Asked?: AskedUpdateManyWithoutAskedUserNestedInput
    user?: UserUpdateOneRequiredWithoutAskedUserNestedInput
  }

  export type AskedUserUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    customId?: NullableStringFieldUpdateOperationsInput | string | null
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    receiveAnonymous?: BoolFieldUpdateOperationsInput | boolean
    receiveOtherSchool?: BoolFieldUpdateOperationsInput | boolean
    lastUpdateCustomId?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Asked?: AskedUncheckedUpdateManyWithoutAskedUserNestedInput
  }

  export type AskedUserCreateManyInput = {
    userId: string
    customId?: string | null
    statusMessage?: string | null
    receiveAnonymous?: boolean
    receiveOtherSchool?: boolean
    lastUpdateCustomId?: Date | string | null
  }

  export type AskedUserUpdateManyMutationInput = {
    customId?: NullableStringFieldUpdateOperationsInput | string | null
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    receiveAnonymous?: BoolFieldUpdateOperationsInput | boolean
    receiveOtherSchool?: BoolFieldUpdateOperationsInput | boolean
    lastUpdateCustomId?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AskedUserUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    customId?: NullableStringFieldUpdateOperationsInput | string | null
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    receiveAnonymous?: BoolFieldUpdateOperationsInput | boolean
    receiveOtherSchool?: BoolFieldUpdateOperationsInput | boolean
    lastUpdateCustomId?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AskedCreateInput = {
    id?: string
    process?: Process
    question: string
    answer?: string | null
    createdAt?: Date | string
    answerTimeAt?: Date | string | null
    isAnonymous: boolean
    AskedUser: AskedUserCreateNestedOneWithoutAskedInput
    QuestionUser: UserCreateNestedOneWithoutAskedInput
  }

  export type AskedUncheckedCreateInput = {
    id?: string
    userId: string
    askedUserId: string
    process?: Process
    question: string
    answer?: string | null
    createdAt?: Date | string
    answerTimeAt?: Date | string | null
    isAnonymous: boolean
  }

  export type AskedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    process?: EnumProcessFieldUpdateOperationsInput | Process
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answerTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    AskedUser?: AskedUserUpdateOneRequiredWithoutAskedNestedInput
    QuestionUser?: UserUpdateOneRequiredWithoutAskedNestedInput
  }

  export type AskedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    askedUserId?: StringFieldUpdateOperationsInput | string
    process?: EnumProcessFieldUpdateOperationsInput | Process
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answerTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AskedCreateManyInput = {
    id?: string
    userId: string
    askedUserId: string
    process?: Process
    question: string
    answer?: string | null
    createdAt?: Date | string
    answerTimeAt?: Date | string | null
    isAnonymous: boolean
  }

  export type AskedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    process?: EnumProcessFieldUpdateOperationsInput | Process
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answerTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AskedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    askedUserId?: StringFieldUpdateOperationsInput | string
    process?: EnumProcessFieldUpdateOperationsInput | Process
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answerTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdminCreateInput = {
    id?: string
    loginId: string
    password: string
    flags: number
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    loginId: string
    password: string
    flags: number
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    flags?: IntFieldUpdateOperationsInput | number
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    flags?: IntFieldUpdateOperationsInput | number
  }

  export type AdminCreateManyInput = {
    id?: string
    loginId: string
    password: string
    flags: number
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    flags?: IntFieldUpdateOperationsInput | number
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginId?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    flags?: IntFieldUpdateOperationsInput | number
  }

  export type BoardCreateInput = {
    schoolId: string
    name: string
    description: string
    default?: boolean
    noticeId?: BoardCreatenoticeIdInput | Enumerable<number>
    Article?: ArticleCreateNestedManyWithoutBoardInput
    managers?: BoardManagerCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateInput = {
    id?: number
    schoolId: string
    name: string
    description: string
    default?: boolean
    noticeId?: BoardCreatenoticeIdInput | Enumerable<number>
    Article?: ArticleUncheckedCreateNestedManyWithoutBoardInput
    managers?: BoardManagerUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardUpdateInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    noticeId?: BoardUpdatenoticeIdInput | Enumerable<number>
    Article?: ArticleUpdateManyWithoutBoardNestedInput
    managers?: BoardManagerUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    noticeId?: BoardUpdatenoticeIdInput | Enumerable<number>
    Article?: ArticleUncheckedUpdateManyWithoutBoardNestedInput
    managers?: BoardManagerUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type BoardCreateManyInput = {
    id?: number
    schoolId: string
    name: string
    description: string
    default?: boolean
    noticeId?: BoardCreatenoticeIdInput | Enumerable<number>
  }

  export type BoardUpdateManyMutationInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    noticeId?: BoardUpdatenoticeIdInput | Enumerable<number>
  }

  export type BoardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    noticeId?: BoardUpdatenoticeIdInput | Enumerable<number>
  }

  export type BoardManagerCreateInput = {
    id?: string
    name: string
    board: BoardCreateNestedOneWithoutManagersInput
    user: UserCreateNestedOneWithoutBoardOrganizationsInput
  }

  export type BoardManagerUncheckedCreateInput = {
    id?: string
    boardId: number
    name: string
    userId: string
  }

  export type BoardManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    board?: BoardUpdateOneRequiredWithoutManagersNestedInput
    user?: UserUpdateOneRequiredWithoutBoardOrganizationsNestedInput
  }

  export type BoardManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type BoardManagerCreateManyInput = {
    id?: string
    boardId: number
    name: string
    userId: string
  }

  export type BoardManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BoardManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCreateInput = {
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    createdAt?: Date | string
    Board: BoardCreateNestedOneWithoutArticleInput
    User: UserCreateNestedOneWithoutArticleInput
    school: SchoolCreateNestedOneWithoutArticleInput
    Comment?: CommentCreateNestedManyWithoutArticleInput
    ReComment?: ReCommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateInput = {
    id?: number
    schoolId: string
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt?: Date | string
    boardId: number
    Comment?: CommentUncheckedCreateNestedManyWithoutArticleInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Board?: BoardUpdateOneRequiredWithoutArticleNestedInput
    User?: UserUpdateOneRequiredWithoutArticleNestedInput
    school?: SchoolUpdateOneRequiredWithoutArticleNestedInput
    Comment?: CommentUpdateManyWithoutArticleNestedInput
    ReComment?: ReCommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
    Comment?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleCreateManyInput = {
    id?: number
    schoolId: string
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt?: Date | string
    boardId: number
  }

  export type ArticleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type DeletedArticleCreateInput = {
    id: number
    schoolId: string
    title: string
    content: string
    images?: DeletedArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt: Date | string
    DeletedAt?: Date | string
    boardId: number
  }

  export type DeletedArticleUncheckedCreateInput = {
    id: number
    schoolId: string
    title: string
    content: string
    images?: DeletedArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt: Date | string
    DeletedAt?: Date | string
    boardId: number
  }

  export type DeletedArticleUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: DeletedArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DeletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type DeletedArticleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: DeletedArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DeletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type DeletedArticleCreateManyInput = {
    id: number
    schoolId: string
    title: string
    content: string
    images?: DeletedArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt: Date | string
    DeletedAt?: Date | string
    boardId: number
  }

  export type DeletedArticleUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: DeletedArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DeletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type DeletedArticleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: DeletedArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DeletedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type BoardRequestCreateInput = {
    id?: string
    name: string
    description: string
    userId: string
    schoolId: string
    schoolName: string
    process?: BoardRequestProcess
    message?: string | null
  }

  export type BoardRequestUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    userId: string
    schoolId: string
    schoolName: string
    process?: BoardRequestProcess
    message?: string | null
  }

  export type BoardRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    schoolName?: StringFieldUpdateOperationsInput | string
    process?: EnumBoardRequestProcessFieldUpdateOperationsInput | BoardRequestProcess
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BoardRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    schoolName?: StringFieldUpdateOperationsInput | string
    process?: EnumBoardRequestProcessFieldUpdateOperationsInput | BoardRequestProcess
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BoardRequestCreateManyInput = {
    id?: string
    name: string
    description: string
    userId: string
    schoolId: string
    schoolName: string
    process?: BoardRequestProcess
    message?: string | null
  }

  export type BoardRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    schoolName?: StringFieldUpdateOperationsInput | string
    process?: EnumBoardRequestProcessFieldUpdateOperationsInput | BoardRequestProcess
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BoardRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    schoolName?: StringFieldUpdateOperationsInput | string
    process?: EnumBoardRequestProcessFieldUpdateOperationsInput | BoardRequestProcess
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Article: ArticleCreateNestedOneWithoutCommentInput
    User: UserCreateNestedOneWithoutCommentInput
    recomments?: ReCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    articleId: number
    recomments?: ReCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Article?: ArticleUpdateOneRequiredWithoutCommentNestedInput
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    recomments?: ReCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    recomments?: ReCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    articleId: number
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type ReCommentCreateInput = {
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Article: ArticleCreateNestedOneWithoutReCommentInput
    Comment?: CommentCreateNestedOneWithoutRecommentsInput
    User: UserCreateNestedOneWithoutReCommentInput
  }

  export type ReCommentUncheckedCreateInput = {
    id?: number
    articleId: number
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commentId?: number | null
  }

  export type ReCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Article?: ArticleUpdateOneRequiredWithoutReCommentNestedInput
    Comment?: CommentUpdateOneWithoutRecommentsNestedInput
    User?: UserUpdateOneRequiredWithoutReCommentNestedInput
  }

  export type ReCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReCommentCreateManyInput = {
    id?: number
    articleId: number
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commentId?: number | null
  }

  export type ReCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportCreateInput = {
    id?: string
    reportUserId: string
    targetType: ReportTargetType
    message: string
    targetId: string
    reportUserName: string
    process?: ReportProcess
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    reportUserId: string
    targetType: ReportTargetType
    message: string
    targetId: string
    reportUserName: string
    process?: ReportProcess
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportUserId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumReportTargetTypeFieldUpdateOperationsInput | ReportTargetType
    message?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    reportUserName?: StringFieldUpdateOperationsInput | string
    process?: EnumReportProcessFieldUpdateOperationsInput | ReportProcess
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportUserId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumReportTargetTypeFieldUpdateOperationsInput | ReportTargetType
    message?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    reportUserName?: StringFieldUpdateOperationsInput | string
    process?: EnumReportProcessFieldUpdateOperationsInput | ReportProcess
  }

  export type ReportCreateManyInput = {
    id?: string
    reportUserId: string
    targetType: ReportTargetType
    message: string
    targetId: string
    reportUserName: string
    process?: ReportProcess
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportUserId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumReportTargetTypeFieldUpdateOperationsInput | ReportTargetType
    message?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    reportUserName?: StringFieldUpdateOperationsInput | string
    process?: EnumReportProcessFieldUpdateOperationsInput | ReportProcess
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportUserId?: StringFieldUpdateOperationsInput | string
    targetType?: EnumReportTargetTypeFieldUpdateOperationsInput | ReportTargetType
    message?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    reportUserName?: StringFieldUpdateOperationsInput | string
    process?: EnumReportProcessFieldUpdateOperationsInput | ReportProcess
  }

  export type LikeCreateInput = {
    id?: string
    targetId: number
    targetType: LikeTargetType
    likeType: LikeType
    user: UserCreateNestedOneWithoutLikeInput
  }

  export type LikeUncheckedCreateInput = {
    id?: string
    userId: string
    targetId: number
    targetType: LikeTargetType
    likeType: LikeType
  }

  export type LikeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumLikeTargetTypeFieldUpdateOperationsInput | LikeTargetType
    likeType?: EnumLikeTypeFieldUpdateOperationsInput | LikeType
    user?: UserUpdateOneRequiredWithoutLikeNestedInput
  }

  export type LikeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumLikeTargetTypeFieldUpdateOperationsInput | LikeTargetType
    likeType?: EnumLikeTypeFieldUpdateOperationsInput | LikeType
  }

  export type LikeCreateManyInput = {
    id?: string
    userId: string
    targetId: number
    targetType: LikeTargetType
    likeType: LikeType
  }

  export type LikeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumLikeTargetTypeFieldUpdateOperationsInput | LikeTargetType
    likeType?: EnumLikeTypeFieldUpdateOperationsInput | LikeType
  }

  export type LikeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumLikeTargetTypeFieldUpdateOperationsInput | LikeTargetType
    likeType?: EnumLikeTypeFieldUpdateOperationsInput | LikeType
  }

  export type MealCreateInput = {
    id: string
    MLSV_FGR: number
    DDISH_NM: string
    ORPLC_INFO: string
    CAL_INFO: string
    NTR_INFO: string
  }

  export type MealUncheckedCreateInput = {
    id: string
    MLSV_FGR: number
    DDISH_NM: string
    ORPLC_INFO: string
    CAL_INFO: string
    NTR_INFO: string
  }

  export type MealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    MLSV_FGR?: IntFieldUpdateOperationsInput | number
    DDISH_NM?: StringFieldUpdateOperationsInput | string
    ORPLC_INFO?: StringFieldUpdateOperationsInput | string
    CAL_INFO?: StringFieldUpdateOperationsInput | string
    NTR_INFO?: StringFieldUpdateOperationsInput | string
  }

  export type MealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    MLSV_FGR?: IntFieldUpdateOperationsInput | number
    DDISH_NM?: StringFieldUpdateOperationsInput | string
    ORPLC_INFO?: StringFieldUpdateOperationsInput | string
    CAL_INFO?: StringFieldUpdateOperationsInput | string
    NTR_INFO?: StringFieldUpdateOperationsInput | string
  }

  export type MealCreateManyInput = {
    id: string
    MLSV_FGR: number
    DDISH_NM: string
    ORPLC_INFO: string
    CAL_INFO: string
    NTR_INFO: string
  }

  export type MealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    MLSV_FGR?: IntFieldUpdateOperationsInput | number
    DDISH_NM?: StringFieldUpdateOperationsInput | string
    ORPLC_INFO?: StringFieldUpdateOperationsInput | string
    CAL_INFO?: StringFieldUpdateOperationsInput | string
    NTR_INFO?: StringFieldUpdateOperationsInput | string
  }

  export type MealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    MLSV_FGR?: IntFieldUpdateOperationsInput | number
    DDISH_NM?: StringFieldUpdateOperationsInput | string
    ORPLC_INFO?: StringFieldUpdateOperationsInput | string
    CAL_INFO?: StringFieldUpdateOperationsInput | string
    NTR_INFO?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type EnumUserLoginProviderTypeFilter = {
    equals?: UserLoginProviderType
    in?: Enumerable<UserLoginProviderType>
    notIn?: Enumerable<UserLoginProviderType>
    not?: NestedEnumUserLoginProviderTypeFilter | UserLoginProviderType
  }

  export type AgreementRelationFilter = {
    is?: AgreementWhereInput | null
    isNot?: AgreementWhereInput | null
  }

  export type ArticleListRelationFilter = {
    every?: ArticleWhereInput
    some?: ArticleWhereInput
    none?: ArticleWhereInput
  }

  export type AskedListRelationFilter = {
    every?: AskedWhereInput
    some?: AskedWhereInput
    none?: AskedWhereInput
  }

  export type AskedUserRelationFilter = {
    is?: AskedUserWhereInput | null
    isNot?: AskedUserWhereInput | null
  }

  export type BoardManagerListRelationFilter = {
    every?: BoardManagerWhereInput
    some?: BoardManagerWhereInput
    none?: BoardManagerWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type LikeListRelationFilter = {
    every?: LikeWhereInput
    some?: LikeWhereInput
    none?: LikeWhereInput
  }

  export type ReCommentListRelationFilter = {
    every?: ReCommentWhereInput
    some?: ReCommentWhereInput
    none?: ReCommentWhereInput
  }

  export type SocialLoginRelationFilter = {
    is?: SocialLoginWhereInput | null
    isNot?: SocialLoginWhereInput | null
  }

  export type UserSchoolRelationFilter = {
    is?: UserSchoolWhereInput | null
    isNot?: UserSchoolWhereInput | null
  }

  export type UserSchoolVerifyListRelationFilter = {
    every?: UserSchoolVerifyWhereInput
    some?: UserSchoolVerifyWhereInput
    none?: UserSchoolVerifyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AskedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BoardManagerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSchoolVerifyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    profile?: SortOrder
    isVerified?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    provider?: SortOrder
    userSchoolId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    profile?: SortOrder
    isVerified?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    provider?: SortOrder
    userSchoolId?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    profile?: SortOrder
    isVerified?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    provider?: SortOrder
    userSchoolId?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type EnumUserLoginProviderTypeWithAggregatesFilter = {
    equals?: UserLoginProviderType
    in?: Enumerable<UserLoginProviderType>
    notIn?: Enumerable<UserLoginProviderType>
    not?: NestedEnumUserLoginProviderTypeWithAggregatesFilter | UserLoginProviderType
    _count?: NestedIntFilter
    _min?: NestedEnumUserLoginProviderTypeFilter
    _max?: NestedEnumUserLoginProviderTypeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type UserSchoolListRelationFilter = {
    every?: UserSchoolWhereInput
    some?: UserSchoolWhereInput
    none?: UserSchoolWhereInput
  }

  export type UserSchoolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolCountOrderByAggregateInput = {
    schoolId?: SortOrder
    org?: SortOrder
    x?: SortOrder
    y?: SortOrder
    atptCode?: SortOrder
    defaultName?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type SchoolAvgOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
  }

  export type SchoolMaxOrderByAggregateInput = {
    schoolId?: SortOrder
    org?: SortOrder
    x?: SortOrder
    y?: SortOrder
    atptCode?: SortOrder
    defaultName?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type SchoolMinOrderByAggregateInput = {
    schoolId?: SortOrder
    org?: SortOrder
    x?: SortOrder
    y?: SortOrder
    atptCode?: SortOrder
    defaultName?: SortOrder
    name?: SortOrder
    type?: SortOrder
  }

  export type SchoolSumOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ImageCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type PhoneVerifyRequestCountOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    code?: SortOrder
  }

  export type PhoneVerifyRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    code?: SortOrder
  }

  export type PhoneVerifyRequestMinOrderByAggregateInput = {
    id?: SortOrder
    phone?: SortOrder
    code?: SortOrder
  }

  export type EnumSocialLoginProviderTypeFilter = {
    equals?: SocialLoginProviderType
    in?: Enumerable<SocialLoginProviderType>
    notIn?: Enumerable<SocialLoginProviderType>
    not?: NestedEnumSocialLoginProviderTypeFilter | SocialLoginProviderType
  }

  export type SocialLoginCountOrderByAggregateInput = {
    accessToken?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    socialId?: SortOrder
    provider?: SortOrder
  }

  export type SocialLoginMaxOrderByAggregateInput = {
    accessToken?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    socialId?: SortOrder
    provider?: SortOrder
  }

  export type SocialLoginMinOrderByAggregateInput = {
    accessToken?: SortOrder
    refreshToken?: SortOrder
    userId?: SortOrder
    socialId?: SortOrder
    provider?: SortOrder
  }

  export type EnumSocialLoginProviderTypeWithAggregatesFilter = {
    equals?: SocialLoginProviderType
    in?: Enumerable<SocialLoginProviderType>
    notIn?: Enumerable<SocialLoginProviderType>
    not?: NestedEnumSocialLoginProviderTypeWithAggregatesFilter | SocialLoginProviderType
    _count?: NestedIntFilter
    _min?: NestedEnumSocialLoginProviderTypeFilter
    _max?: NestedEnumSocialLoginProviderTypeFilter
  }

  export type AgreementCountOrderByAggregateInput = {
    updatedAt?: SortOrder
    userId?: SortOrder
    receive?: SortOrder
  }

  export type AgreementMaxOrderByAggregateInput = {
    updatedAt?: SortOrder
    userId?: SortOrder
    receive?: SortOrder
  }

  export type AgreementMinOrderByAggregateInput = {
    updatedAt?: SortOrder
    userId?: SortOrder
    receive?: SortOrder
  }

  export type EnumProcessFilter = {
    equals?: Process
    in?: Enumerable<Process>
    notIn?: Enumerable<Process>
    not?: NestedEnumProcessFilter | Process
  }

  export type ImageRelationFilter = {
    is?: ImageWhereInput | null
    isNot?: ImageWhereInput | null
  }

  export type UserSchoolVerifyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageId?: SortOrder
    schoolId?: SortOrder
    grade?: SortOrder
    class?: SortOrder
    message?: SortOrder
    process?: SortOrder
    createdAt?: SortOrder
    schoolName?: SortOrder
    userName?: SortOrder
    dept?: SortOrder
  }

  export type UserSchoolVerifyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageId?: SortOrder
    schoolId?: SortOrder
    grade?: SortOrder
    class?: SortOrder
    message?: SortOrder
    process?: SortOrder
    createdAt?: SortOrder
    schoolName?: SortOrder
    userName?: SortOrder
    dept?: SortOrder
  }

  export type UserSchoolVerifyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    imageId?: SortOrder
    schoolId?: SortOrder
    grade?: SortOrder
    class?: SortOrder
    message?: SortOrder
    process?: SortOrder
    createdAt?: SortOrder
    schoolName?: SortOrder
    userName?: SortOrder
    dept?: SortOrder
  }

  export type EnumProcessWithAggregatesFilter = {
    equals?: Process
    in?: Enumerable<Process>
    notIn?: Enumerable<Process>
    not?: NestedEnumProcessWithAggregatesFilter | Process
    _count?: NestedIntFilter
    _min?: NestedEnumProcessFilter
    _max?: NestedEnumProcessFilter
  }

  export type SchoolRelationFilter = {
    is?: SchoolWhereInput | null
    isNot?: SchoolWhereInput | null
  }

  export type UserSchoolCountOrderByAggregateInput = {
    userId?: SortOrder
    schoolId?: SortOrder
    dept?: SortOrder
    grade?: SortOrder
    class?: SortOrder
  }

  export type UserSchoolMaxOrderByAggregateInput = {
    userId?: SortOrder
    schoolId?: SortOrder
    dept?: SortOrder
    grade?: SortOrder
    class?: SortOrder
  }

  export type UserSchoolMinOrderByAggregateInput = {
    userId?: SortOrder
    schoolId?: SortOrder
    dept?: SortOrder
    grade?: SortOrder
    class?: SortOrder
  }

  export type BusStationCountOrderByAggregateInput = {
    busStationId?: SortOrder
    busStationName?: SortOrder
    address?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type BusStationAvgOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
  }

  export type BusStationMaxOrderByAggregateInput = {
    busStationId?: SortOrder
    busStationName?: SortOrder
    address?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type BusStationMinOrderByAggregateInput = {
    busStationId?: SortOrder
    busStationName?: SortOrder
    address?: SortOrder
    x?: SortOrder
    y?: SortOrder
  }

  export type BusStationSumOrderByAggregateInput = {
    x?: SortOrder
    y?: SortOrder
  }

  export type BusRouteCountOrderByAggregateInput = {
    busRouteId?: SortOrder
    busRouteNum?: SortOrder
    busRouteTp?: SortOrder
    endNodeName?: SortOrder
    startNodeName?: SortOrder
    endVehicleTime?: SortOrder
    startVehicleTime?: SortOrder
    intervalTime?: SortOrder
    intervalSatTime?: SortOrder
    intervalSunTime?: SortOrder
  }

  export type BusRouteMaxOrderByAggregateInput = {
    busRouteId?: SortOrder
    busRouteNum?: SortOrder
    busRouteTp?: SortOrder
    endNodeName?: SortOrder
    startNodeName?: SortOrder
    endVehicleTime?: SortOrder
    startVehicleTime?: SortOrder
    intervalTime?: SortOrder
    intervalSatTime?: SortOrder
    intervalSunTime?: SortOrder
  }

  export type BusRouteMinOrderByAggregateInput = {
    busRouteId?: SortOrder
    busRouteNum?: SortOrder
    busRouteTp?: SortOrder
    endNodeName?: SortOrder
    startNodeName?: SortOrder
    endVehicleTime?: SortOrder
    startVehicleTime?: SortOrder
    intervalTime?: SortOrder
    intervalSatTime?: SortOrder
    intervalSunTime?: SortOrder
  }

  export type BusArrivalCountOrderByAggregateInput = {
    busStationId?: SortOrder
    busStationName?: SortOrder
    busRouteNum?: SortOrder
    busRouteTp?: SortOrder
    arrprevStationCnt?: SortOrder
    arrTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusArrivalMaxOrderByAggregateInput = {
    busStationId?: SortOrder
    busStationName?: SortOrder
    busRouteNum?: SortOrder
    busRouteTp?: SortOrder
    arrprevStationCnt?: SortOrder
    arrTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusArrivalMinOrderByAggregateInput = {
    busStationId?: SortOrder
    busStationName?: SortOrder
    busRouteNum?: SortOrder
    busRouteTp?: SortOrder
    arrprevStationCnt?: SortOrder
    arrTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type AskedUserCountOrderByAggregateInput = {
    userId?: SortOrder
    customId?: SortOrder
    statusMessage?: SortOrder
    receiveAnonymous?: SortOrder
    receiveOtherSchool?: SortOrder
    lastUpdateCustomId?: SortOrder
  }

  export type AskedUserMaxOrderByAggregateInput = {
    userId?: SortOrder
    customId?: SortOrder
    statusMessage?: SortOrder
    receiveAnonymous?: SortOrder
    receiveOtherSchool?: SortOrder
    lastUpdateCustomId?: SortOrder
  }

  export type AskedUserMinOrderByAggregateInput = {
    userId?: SortOrder
    customId?: SortOrder
    statusMessage?: SortOrder
    receiveAnonymous?: SortOrder
    receiveOtherSchool?: SortOrder
    lastUpdateCustomId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type AskedCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    askedUserId?: SortOrder
    process?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    answerTimeAt?: SortOrder
    isAnonymous?: SortOrder
  }

  export type AskedMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    askedUserId?: SortOrder
    process?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    answerTimeAt?: SortOrder
    isAnonymous?: SortOrder
  }

  export type AskedMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    askedUserId?: SortOrder
    process?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    createdAt?: SortOrder
    answerTimeAt?: SortOrder
    isAnonymous?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    flags?: SortOrder
  }

  export type AdminAvgOrderByAggregateInput = {
    flags?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    flags?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    loginId?: SortOrder
    password?: SortOrder
    flags?: SortOrder
  }

  export type AdminSumOrderByAggregateInput = {
    flags?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type IntNullableListFilter = {
    equals?: Enumerable<number> | null
    has?: number | null
    hasEvery?: Enumerable<number>
    hasSome?: Enumerable<number>
    isEmpty?: boolean
  }

  export type BoardCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    default?: SortOrder
    noticeId?: SortOrder
  }

  export type BoardAvgOrderByAggregateInput = {
    id?: SortOrder
    noticeId?: SortOrder
  }

  export type BoardMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    default?: SortOrder
  }

  export type BoardMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    default?: SortOrder
  }

  export type BoardSumOrderByAggregateInput = {
    id?: SortOrder
    noticeId?: SortOrder
  }

  export type BoardRelationFilter = {
    is?: BoardWhereInput | null
    isNot?: BoardWhereInput | null
  }

  export type BoardManagerCountOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
  }

  export type BoardManagerAvgOrderByAggregateInput = {
    boardId?: SortOrder
  }

  export type BoardManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
  }

  export type BoardManagerMinOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
  }

  export type BoardManagerSumOrderByAggregateInput = {
    boardId?: SortOrder
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type ArticleCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    isAnonymous?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    boardId?: SortOrder
  }

  export type ArticleAvgOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
  }

  export type ArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    boardId?: SortOrder
  }

  export type ArticleMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    boardId?: SortOrder
  }

  export type ArticleSumOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
  }

  export type DeletedArticleCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    images?: SortOrder
    isAnonymous?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    DeletedAt?: SortOrder
    boardId?: SortOrder
  }

  export type DeletedArticleAvgOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
  }

  export type DeletedArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    DeletedAt?: SortOrder
    boardId?: SortOrder
  }

  export type DeletedArticleMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    DeletedAt?: SortOrder
    boardId?: SortOrder
  }

  export type DeletedArticleSumOrderByAggregateInput = {
    id?: SortOrder
    boardId?: SortOrder
  }

  export type EnumBoardRequestProcessFilter = {
    equals?: BoardRequestProcess
    in?: Enumerable<BoardRequestProcess>
    notIn?: Enumerable<BoardRequestProcess>
    not?: NestedEnumBoardRequestProcessFilter | BoardRequestProcess
  }

  export type BoardRequestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    schoolName?: SortOrder
    process?: SortOrder
    message?: SortOrder
  }

  export type BoardRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    schoolName?: SortOrder
    process?: SortOrder
    message?: SortOrder
  }

  export type BoardRequestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    schoolId?: SortOrder
    schoolName?: SortOrder
    process?: SortOrder
    message?: SortOrder
  }

  export type EnumBoardRequestProcessWithAggregatesFilter = {
    equals?: BoardRequestProcess
    in?: Enumerable<BoardRequestProcess>
    notIn?: Enumerable<BoardRequestProcess>
    not?: NestedEnumBoardRequestProcessWithAggregatesFilter | BoardRequestProcess
    _count?: NestedIntFilter
    _min?: NestedEnumBoardRequestProcessFilter
    _max?: NestedEnumBoardRequestProcessFilter
  }

  export type ArticleRelationFilter = {
    is?: ArticleWhereInput | null
    isNot?: ArticleWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    userId?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    articleId?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    userId?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    articleId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    userId?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    articleId?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type CommentRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type ReCommentCountOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commentId?: SortOrder
  }

  export type ReCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    commentId?: SortOrder
  }

  export type ReCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commentId?: SortOrder
  }

  export type ReCommentMinOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    isAnonymous?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    commentId?: SortOrder
  }

  export type ReCommentSumOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    commentId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type EnumReportTargetTypeFilter = {
    equals?: ReportTargetType
    in?: Enumerable<ReportTargetType>
    notIn?: Enumerable<ReportTargetType>
    not?: NestedEnumReportTargetTypeFilter | ReportTargetType
  }

  export type EnumReportProcessFilter = {
    equals?: ReportProcess
    in?: Enumerable<ReportProcess>
    notIn?: Enumerable<ReportProcess>
    not?: NestedEnumReportProcessFilter | ReportProcess
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    reportUserId?: SortOrder
    targetType?: SortOrder
    message?: SortOrder
    targetId?: SortOrder
    reportUserName?: SortOrder
    process?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reportUserId?: SortOrder
    targetType?: SortOrder
    message?: SortOrder
    targetId?: SortOrder
    reportUserName?: SortOrder
    process?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    reportUserId?: SortOrder
    targetType?: SortOrder
    message?: SortOrder
    targetId?: SortOrder
    reportUserName?: SortOrder
    process?: SortOrder
  }

  export type EnumReportTargetTypeWithAggregatesFilter = {
    equals?: ReportTargetType
    in?: Enumerable<ReportTargetType>
    notIn?: Enumerable<ReportTargetType>
    not?: NestedEnumReportTargetTypeWithAggregatesFilter | ReportTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumReportTargetTypeFilter
    _max?: NestedEnumReportTargetTypeFilter
  }

  export type EnumReportProcessWithAggregatesFilter = {
    equals?: ReportProcess
    in?: Enumerable<ReportProcess>
    notIn?: Enumerable<ReportProcess>
    not?: NestedEnumReportProcessWithAggregatesFilter | ReportProcess
    _count?: NestedIntFilter
    _min?: NestedEnumReportProcessFilter
    _max?: NestedEnumReportProcessFilter
  }

  export type EnumLikeTargetTypeFilter = {
    equals?: LikeTargetType
    in?: Enumerable<LikeTargetType>
    notIn?: Enumerable<LikeTargetType>
    not?: NestedEnumLikeTargetTypeFilter | LikeTargetType
  }

  export type EnumLikeTypeFilter = {
    equals?: LikeType
    in?: Enumerable<LikeType>
    notIn?: Enumerable<LikeType>
    not?: NestedEnumLikeTypeFilter | LikeType
  }

  export type LikeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    likeType?: SortOrder
  }

  export type LikeAvgOrderByAggregateInput = {
    targetId?: SortOrder
  }

  export type LikeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    likeType?: SortOrder
  }

  export type LikeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    targetId?: SortOrder
    targetType?: SortOrder
    likeType?: SortOrder
  }

  export type LikeSumOrderByAggregateInput = {
    targetId?: SortOrder
  }

  export type EnumLikeTargetTypeWithAggregatesFilter = {
    equals?: LikeTargetType
    in?: Enumerable<LikeTargetType>
    notIn?: Enumerable<LikeTargetType>
    not?: NestedEnumLikeTargetTypeWithAggregatesFilter | LikeTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumLikeTargetTypeFilter
    _max?: NestedEnumLikeTargetTypeFilter
  }

  export type EnumLikeTypeWithAggregatesFilter = {
    equals?: LikeType
    in?: Enumerable<LikeType>
    notIn?: Enumerable<LikeType>
    not?: NestedEnumLikeTypeWithAggregatesFilter | LikeType
    _count?: NestedIntFilter
    _min?: NestedEnumLikeTypeFilter
    _max?: NestedEnumLikeTypeFilter
  }

  export type MealCountOrderByAggregateInput = {
    id?: SortOrder
    MLSV_FGR?: SortOrder
    DDISH_NM?: SortOrder
    ORPLC_INFO?: SortOrder
    CAL_INFO?: SortOrder
    NTR_INFO?: SortOrder
  }

  export type MealAvgOrderByAggregateInput = {
    MLSV_FGR?: SortOrder
  }

  export type MealMaxOrderByAggregateInput = {
    id?: SortOrder
    MLSV_FGR?: SortOrder
    DDISH_NM?: SortOrder
    ORPLC_INFO?: SortOrder
    CAL_INFO?: SortOrder
    NTR_INFO?: SortOrder
  }

  export type MealMinOrderByAggregateInput = {
    id?: SortOrder
    MLSV_FGR?: SortOrder
    DDISH_NM?: SortOrder
    ORPLC_INFO?: SortOrder
    CAL_INFO?: SortOrder
    NTR_INFO?: SortOrder
  }

  export type MealSumOrderByAggregateInput = {
    MLSV_FGR?: SortOrder
  }

  export type AgreementCreateNestedOneWithoutUserInput = {
    create?: XOR<AgreementCreateWithoutUserInput, AgreementUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutUserInput
    connect?: AgreementWhereUniqueInput
  }

  export type ArticleCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUserInput>, Enumerable<ArticleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUserInput>
    createMany?: ArticleCreateManyUserInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type AskedCreateNestedManyWithoutQuestionUserInput = {
    create?: XOR<Enumerable<AskedCreateWithoutQuestionUserInput>, Enumerable<AskedUncheckedCreateWithoutQuestionUserInput>>
    connectOrCreate?: Enumerable<AskedCreateOrConnectWithoutQuestionUserInput>
    createMany?: AskedCreateManyQuestionUserInputEnvelope
    connect?: Enumerable<AskedWhereUniqueInput>
  }

  export type AskedUserCreateNestedOneWithoutUserInput = {
    create?: XOR<AskedUserCreateWithoutUserInput, AskedUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AskedUserCreateOrConnectWithoutUserInput
    connect?: AskedUserWhereUniqueInput
  }

  export type BoardManagerCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BoardManagerCreateWithoutUserInput>, Enumerable<BoardManagerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardManagerCreateOrConnectWithoutUserInput>
    createMany?: BoardManagerCreateManyUserInputEnvelope
    connect?: Enumerable<BoardManagerWhereUniqueInput>
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentCreateWithoutUserInput>, Enumerable<CommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutUserInput>
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type ImageCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ImageCreateWithoutUserInput>, Enumerable<ImageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutUserInput>
    createMany?: ImageCreateManyUserInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
  }

  export type LikeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LikeCreateWithoutUserInput>, Enumerable<LikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LikeCreateOrConnectWithoutUserInput>
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: Enumerable<LikeWhereUniqueInput>
  }

  export type ReCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutUserInput>, Enumerable<ReCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutUserInput>
    createMany?: ReCommentCreateManyUserInputEnvelope
    connect?: Enumerable<ReCommentWhereUniqueInput>
  }

  export type SocialLoginCreateNestedOneWithoutUserInput = {
    create?: XOR<SocialLoginCreateWithoutUserInput, SocialLoginUncheckedCreateWithoutUserInput>
    connectOrCreate?: SocialLoginCreateOrConnectWithoutUserInput
    connect?: SocialLoginWhereUniqueInput
  }

  export type UserSchoolCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSchoolCreateWithoutUserInput, UserSchoolUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSchoolCreateOrConnectWithoutUserInput
    connect?: UserSchoolWhereUniqueInput
  }

  export type UserSchoolVerifyCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserSchoolVerifyCreateWithoutUserInput>, Enumerable<UserSchoolVerifyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserSchoolVerifyCreateOrConnectWithoutUserInput>
    createMany?: UserSchoolVerifyCreateManyUserInputEnvelope
    connect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
  }

  export type AgreementUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AgreementCreateWithoutUserInput, AgreementUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutUserInput
    connect?: AgreementWhereUniqueInput
  }

  export type ArticleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUserInput>, Enumerable<ArticleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUserInput>
    createMany?: ArticleCreateManyUserInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type AskedUncheckedCreateNestedManyWithoutQuestionUserInput = {
    create?: XOR<Enumerable<AskedCreateWithoutQuestionUserInput>, Enumerable<AskedUncheckedCreateWithoutQuestionUserInput>>
    connectOrCreate?: Enumerable<AskedCreateOrConnectWithoutQuestionUserInput>
    createMany?: AskedCreateManyQuestionUserInputEnvelope
    connect?: Enumerable<AskedWhereUniqueInput>
  }

  export type AskedUserUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AskedUserCreateWithoutUserInput, AskedUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AskedUserCreateOrConnectWithoutUserInput
    connect?: AskedUserWhereUniqueInput
  }

  export type BoardManagerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<BoardManagerCreateWithoutUserInput>, Enumerable<BoardManagerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardManagerCreateOrConnectWithoutUserInput>
    createMany?: BoardManagerCreateManyUserInputEnvelope
    connect?: Enumerable<BoardManagerWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<CommentCreateWithoutUserInput>, Enumerable<CommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutUserInput>
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type ImageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ImageCreateWithoutUserInput>, Enumerable<ImageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutUserInput>
    createMany?: ImageCreateManyUserInputEnvelope
    connect?: Enumerable<ImageWhereUniqueInput>
  }

  export type LikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<LikeCreateWithoutUserInput>, Enumerable<LikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LikeCreateOrConnectWithoutUserInput>
    createMany?: LikeCreateManyUserInputEnvelope
    connect?: Enumerable<LikeWhereUniqueInput>
  }

  export type ReCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutUserInput>, Enumerable<ReCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutUserInput>
    createMany?: ReCommentCreateManyUserInputEnvelope
    connect?: Enumerable<ReCommentWhereUniqueInput>
  }

  export type SocialLoginUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SocialLoginCreateWithoutUserInput, SocialLoginUncheckedCreateWithoutUserInput>
    connectOrCreate?: SocialLoginCreateOrConnectWithoutUserInput
    connect?: SocialLoginWhereUniqueInput
  }

  export type UserSchoolUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSchoolCreateWithoutUserInput, UserSchoolUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSchoolCreateOrConnectWithoutUserInput
    connect?: UserSchoolWhereUniqueInput
  }

  export type UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserSchoolVerifyCreateWithoutUserInput>, Enumerable<UserSchoolVerifyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserSchoolVerifyCreateOrConnectWithoutUserInput>
    createMany?: UserSchoolVerifyCreateManyUserInputEnvelope
    connect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumUserLoginProviderTypeFieldUpdateOperationsInput = {
    set?: UserLoginProviderType
  }

  export type AgreementUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgreementCreateWithoutUserInput, AgreementUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutUserInput
    upsert?: AgreementUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AgreementWhereUniqueInput
    update?: XOR<AgreementUpdateWithoutUserInput, AgreementUncheckedUpdateWithoutUserInput>
  }

  export type ArticleUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUserInput>, Enumerable<ArticleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ArticleCreateManyUserInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type AskedUpdateManyWithoutQuestionUserNestedInput = {
    create?: XOR<Enumerable<AskedCreateWithoutQuestionUserInput>, Enumerable<AskedUncheckedCreateWithoutQuestionUserInput>>
    connectOrCreate?: Enumerable<AskedCreateOrConnectWithoutQuestionUserInput>
    upsert?: Enumerable<AskedUpsertWithWhereUniqueWithoutQuestionUserInput>
    createMany?: AskedCreateManyQuestionUserInputEnvelope
    set?: Enumerable<AskedWhereUniqueInput>
    disconnect?: Enumerable<AskedWhereUniqueInput>
    delete?: Enumerable<AskedWhereUniqueInput>
    connect?: Enumerable<AskedWhereUniqueInput>
    update?: Enumerable<AskedUpdateWithWhereUniqueWithoutQuestionUserInput>
    updateMany?: Enumerable<AskedUpdateManyWithWhereWithoutQuestionUserInput>
    deleteMany?: Enumerable<AskedScalarWhereInput>
  }

  export type AskedUserUpdateOneWithoutUserNestedInput = {
    create?: XOR<AskedUserCreateWithoutUserInput, AskedUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AskedUserCreateOrConnectWithoutUserInput
    upsert?: AskedUserUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AskedUserWhereUniqueInput
    update?: XOR<AskedUserUpdateWithoutUserInput, AskedUserUncheckedUpdateWithoutUserInput>
  }

  export type BoardManagerUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BoardManagerCreateWithoutUserInput>, Enumerable<BoardManagerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardManagerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BoardManagerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BoardManagerCreateManyUserInputEnvelope
    set?: Enumerable<BoardManagerWhereUniqueInput>
    disconnect?: Enumerable<BoardManagerWhereUniqueInput>
    delete?: Enumerable<BoardManagerWhereUniqueInput>
    connect?: Enumerable<BoardManagerWhereUniqueInput>
    update?: Enumerable<BoardManagerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BoardManagerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BoardManagerScalarWhereInput>
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutUserInput>, Enumerable<CommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommentCreateManyUserInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type ImageUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ImageCreateWithoutUserInput>, Enumerable<ImageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ImageCreateManyUserInputEnvelope
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    connect?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
  }

  export type LikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LikeCreateWithoutUserInput>, Enumerable<LikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LikeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LikeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LikeCreateManyUserInputEnvelope
    set?: Enumerable<LikeWhereUniqueInput>
    disconnect?: Enumerable<LikeWhereUniqueInput>
    delete?: Enumerable<LikeWhereUniqueInput>
    connect?: Enumerable<LikeWhereUniqueInput>
    update?: Enumerable<LikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LikeScalarWhereInput>
  }

  export type ReCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutUserInput>, Enumerable<ReCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReCommentCreateManyUserInputEnvelope
    set?: Enumerable<ReCommentWhereUniqueInput>
    disconnect?: Enumerable<ReCommentWhereUniqueInput>
    delete?: Enumerable<ReCommentWhereUniqueInput>
    connect?: Enumerable<ReCommentWhereUniqueInput>
    update?: Enumerable<ReCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReCommentScalarWhereInput>
  }

  export type SocialLoginUpdateOneWithoutUserNestedInput = {
    create?: XOR<SocialLoginCreateWithoutUserInput, SocialLoginUncheckedCreateWithoutUserInput>
    connectOrCreate?: SocialLoginCreateOrConnectWithoutUserInput
    upsert?: SocialLoginUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: SocialLoginWhereUniqueInput
    update?: XOR<SocialLoginUpdateWithoutUserInput, SocialLoginUncheckedUpdateWithoutUserInput>
  }

  export type UserSchoolUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSchoolCreateWithoutUserInput, UserSchoolUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSchoolCreateOrConnectWithoutUserInput
    upsert?: UserSchoolUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserSchoolWhereUniqueInput
    update?: XOR<UserSchoolUpdateWithoutUserInput, UserSchoolUncheckedUpdateWithoutUserInput>
  }

  export type UserSchoolVerifyUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserSchoolVerifyCreateWithoutUserInput>, Enumerable<UserSchoolVerifyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserSchoolVerifyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserSchoolVerifyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserSchoolVerifyCreateManyUserInputEnvelope
    set?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    disconnect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    delete?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    connect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    update?: Enumerable<UserSchoolVerifyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserSchoolVerifyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserSchoolVerifyScalarWhereInput>
  }

  export type AgreementUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AgreementCreateWithoutUserInput, AgreementUncheckedCreateWithoutUserInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutUserInput
    upsert?: AgreementUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AgreementWhereUniqueInput
    update?: XOR<AgreementUpdateWithoutUserInput, AgreementUncheckedUpdateWithoutUserInput>
  }

  export type ArticleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutUserInput>, Enumerable<ArticleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ArticleCreateManyUserInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type AskedUncheckedUpdateManyWithoutQuestionUserNestedInput = {
    create?: XOR<Enumerable<AskedCreateWithoutQuestionUserInput>, Enumerable<AskedUncheckedCreateWithoutQuestionUserInput>>
    connectOrCreate?: Enumerable<AskedCreateOrConnectWithoutQuestionUserInput>
    upsert?: Enumerable<AskedUpsertWithWhereUniqueWithoutQuestionUserInput>
    createMany?: AskedCreateManyQuestionUserInputEnvelope
    set?: Enumerable<AskedWhereUniqueInput>
    disconnect?: Enumerable<AskedWhereUniqueInput>
    delete?: Enumerable<AskedWhereUniqueInput>
    connect?: Enumerable<AskedWhereUniqueInput>
    update?: Enumerable<AskedUpdateWithWhereUniqueWithoutQuestionUserInput>
    updateMany?: Enumerable<AskedUpdateManyWithWhereWithoutQuestionUserInput>
    deleteMany?: Enumerable<AskedScalarWhereInput>
  }

  export type AskedUserUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AskedUserCreateWithoutUserInput, AskedUserUncheckedCreateWithoutUserInput>
    connectOrCreate?: AskedUserCreateOrConnectWithoutUserInput
    upsert?: AskedUserUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: AskedUserWhereUniqueInput
    update?: XOR<AskedUserUpdateWithoutUserInput, AskedUserUncheckedUpdateWithoutUserInput>
  }

  export type BoardManagerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<BoardManagerCreateWithoutUserInput>, Enumerable<BoardManagerUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<BoardManagerCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<BoardManagerUpsertWithWhereUniqueWithoutUserInput>
    createMany?: BoardManagerCreateManyUserInputEnvelope
    set?: Enumerable<BoardManagerWhereUniqueInput>
    disconnect?: Enumerable<BoardManagerWhereUniqueInput>
    delete?: Enumerable<BoardManagerWhereUniqueInput>
    connect?: Enumerable<BoardManagerWhereUniqueInput>
    update?: Enumerable<BoardManagerUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<BoardManagerUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<BoardManagerScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutUserInput>, Enumerable<CommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: CommentCreateManyUserInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type ImageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ImageCreateWithoutUserInput>, Enumerable<ImageUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ImageCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ImageUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ImageCreateManyUserInputEnvelope
    set?: Enumerable<ImageWhereUniqueInput>
    disconnect?: Enumerable<ImageWhereUniqueInput>
    delete?: Enumerable<ImageWhereUniqueInput>
    connect?: Enumerable<ImageWhereUniqueInput>
    update?: Enumerable<ImageUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ImageUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ImageScalarWhereInput>
  }

  export type LikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<LikeCreateWithoutUserInput>, Enumerable<LikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<LikeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<LikeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: LikeCreateManyUserInputEnvelope
    set?: Enumerable<LikeWhereUniqueInput>
    disconnect?: Enumerable<LikeWhereUniqueInput>
    delete?: Enumerable<LikeWhereUniqueInput>
    connect?: Enumerable<LikeWhereUniqueInput>
    update?: Enumerable<LikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<LikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<LikeScalarWhereInput>
  }

  export type ReCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutUserInput>, Enumerable<ReCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ReCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ReCommentCreateManyUserInputEnvelope
    set?: Enumerable<ReCommentWhereUniqueInput>
    disconnect?: Enumerable<ReCommentWhereUniqueInput>
    delete?: Enumerable<ReCommentWhereUniqueInput>
    connect?: Enumerable<ReCommentWhereUniqueInput>
    update?: Enumerable<ReCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ReCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ReCommentScalarWhereInput>
  }

  export type SocialLoginUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SocialLoginCreateWithoutUserInput, SocialLoginUncheckedCreateWithoutUserInput>
    connectOrCreate?: SocialLoginCreateOrConnectWithoutUserInput
    upsert?: SocialLoginUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: SocialLoginWhereUniqueInput
    update?: XOR<SocialLoginUpdateWithoutUserInput, SocialLoginUncheckedUpdateWithoutUserInput>
  }

  export type UserSchoolUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSchoolCreateWithoutUserInput, UserSchoolUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSchoolCreateOrConnectWithoutUserInput
    upsert?: UserSchoolUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserSchoolWhereUniqueInput
    update?: XOR<UserSchoolUpdateWithoutUserInput, UserSchoolUncheckedUpdateWithoutUserInput>
  }

  export type UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserSchoolVerifyCreateWithoutUserInput>, Enumerable<UserSchoolVerifyUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserSchoolVerifyCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserSchoolVerifyUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserSchoolVerifyCreateManyUserInputEnvelope
    set?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    disconnect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    delete?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    connect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    update?: Enumerable<UserSchoolVerifyUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserSchoolVerifyUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserSchoolVerifyScalarWhereInput>
  }

  export type UserSchoolCreateNestedManyWithoutSchoolInput = {
    create?: XOR<Enumerable<UserSchoolCreateWithoutSchoolInput>, Enumerable<UserSchoolUncheckedCreateWithoutSchoolInput>>
    connectOrCreate?: Enumerable<UserSchoolCreateOrConnectWithoutSchoolInput>
    createMany?: UserSchoolCreateManySchoolInputEnvelope
    connect?: Enumerable<UserSchoolWhereUniqueInput>
  }

  export type ArticleCreateNestedManyWithoutSchoolInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutSchoolInput>, Enumerable<ArticleUncheckedCreateWithoutSchoolInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutSchoolInput>
    createMany?: ArticleCreateManySchoolInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type UserSchoolUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<Enumerable<UserSchoolCreateWithoutSchoolInput>, Enumerable<UserSchoolUncheckedCreateWithoutSchoolInput>>
    connectOrCreate?: Enumerable<UserSchoolCreateOrConnectWithoutSchoolInput>
    createMany?: UserSchoolCreateManySchoolInputEnvelope
    connect?: Enumerable<UserSchoolWhereUniqueInput>
  }

  export type ArticleUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutSchoolInput>, Enumerable<ArticleUncheckedCreateWithoutSchoolInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutSchoolInput>
    createMany?: ArticleCreateManySchoolInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserSchoolUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<Enumerable<UserSchoolCreateWithoutSchoolInput>, Enumerable<UserSchoolUncheckedCreateWithoutSchoolInput>>
    connectOrCreate?: Enumerable<UserSchoolCreateOrConnectWithoutSchoolInput>
    upsert?: Enumerable<UserSchoolUpsertWithWhereUniqueWithoutSchoolInput>
    createMany?: UserSchoolCreateManySchoolInputEnvelope
    set?: Enumerable<UserSchoolWhereUniqueInput>
    disconnect?: Enumerable<UserSchoolWhereUniqueInput>
    delete?: Enumerable<UserSchoolWhereUniqueInput>
    connect?: Enumerable<UserSchoolWhereUniqueInput>
    update?: Enumerable<UserSchoolUpdateWithWhereUniqueWithoutSchoolInput>
    updateMany?: Enumerable<UserSchoolUpdateManyWithWhereWithoutSchoolInput>
    deleteMany?: Enumerable<UserSchoolScalarWhereInput>
  }

  export type ArticleUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutSchoolInput>, Enumerable<ArticleUncheckedCreateWithoutSchoolInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutSchoolInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutSchoolInput>
    createMany?: ArticleCreateManySchoolInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutSchoolInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutSchoolInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type UserSchoolUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<Enumerable<UserSchoolCreateWithoutSchoolInput>, Enumerable<UserSchoolUncheckedCreateWithoutSchoolInput>>
    connectOrCreate?: Enumerable<UserSchoolCreateOrConnectWithoutSchoolInput>
    upsert?: Enumerable<UserSchoolUpsertWithWhereUniqueWithoutSchoolInput>
    createMany?: UserSchoolCreateManySchoolInputEnvelope
    set?: Enumerable<UserSchoolWhereUniqueInput>
    disconnect?: Enumerable<UserSchoolWhereUniqueInput>
    delete?: Enumerable<UserSchoolWhereUniqueInput>
    connect?: Enumerable<UserSchoolWhereUniqueInput>
    update?: Enumerable<UserSchoolUpdateWithWhereUniqueWithoutSchoolInput>
    updateMany?: Enumerable<UserSchoolUpdateManyWithWhereWithoutSchoolInput>
    deleteMany?: Enumerable<UserSchoolScalarWhereInput>
  }

  export type ArticleUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutSchoolInput>, Enumerable<ArticleUncheckedCreateWithoutSchoolInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutSchoolInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutSchoolInput>
    createMany?: ArticleCreateManySchoolInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutSchoolInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutSchoolInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutImageInput = {
    create?: XOR<UserCreateWithoutImageInput, UserUncheckedCreateWithoutImageInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageInput
    connect?: UserWhereUniqueInput
  }

  export type UserSchoolVerifyCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<UserSchoolVerifyCreateWithoutImageInput>, Enumerable<UserSchoolVerifyUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<UserSchoolVerifyCreateOrConnectWithoutImageInput>
    createMany?: UserSchoolVerifyCreateManyImageInputEnvelope
    connect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
  }

  export type UserSchoolVerifyUncheckedCreateNestedManyWithoutImageInput = {
    create?: XOR<Enumerable<UserSchoolVerifyCreateWithoutImageInput>, Enumerable<UserSchoolVerifyUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<UserSchoolVerifyCreateOrConnectWithoutImageInput>
    createMany?: UserSchoolVerifyCreateManyImageInputEnvelope
    connect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutImageNestedInput = {
    create?: XOR<UserCreateWithoutImageInput, UserUncheckedCreateWithoutImageInput>
    connectOrCreate?: UserCreateOrConnectWithoutImageInput
    upsert?: UserUpsertWithoutImageInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutImageInput, UserUncheckedUpdateWithoutImageInput>
  }

  export type UserSchoolVerifyUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<UserSchoolVerifyCreateWithoutImageInput>, Enumerable<UserSchoolVerifyUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<UserSchoolVerifyCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<UserSchoolVerifyUpsertWithWhereUniqueWithoutImageInput>
    createMany?: UserSchoolVerifyCreateManyImageInputEnvelope
    set?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    disconnect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    delete?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    connect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    update?: Enumerable<UserSchoolVerifyUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<UserSchoolVerifyUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<UserSchoolVerifyScalarWhereInput>
  }

  export type UserSchoolVerifyUncheckedUpdateManyWithoutImageNestedInput = {
    create?: XOR<Enumerable<UserSchoolVerifyCreateWithoutImageInput>, Enumerable<UserSchoolVerifyUncheckedCreateWithoutImageInput>>
    connectOrCreate?: Enumerable<UserSchoolVerifyCreateOrConnectWithoutImageInput>
    upsert?: Enumerable<UserSchoolVerifyUpsertWithWhereUniqueWithoutImageInput>
    createMany?: UserSchoolVerifyCreateManyImageInputEnvelope
    set?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    disconnect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    delete?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    connect?: Enumerable<UserSchoolVerifyWhereUniqueInput>
    update?: Enumerable<UserSchoolVerifyUpdateWithWhereUniqueWithoutImageInput>
    updateMany?: Enumerable<UserSchoolVerifyUpdateManyWithWhereWithoutImageInput>
    deleteMany?: Enumerable<UserSchoolVerifyScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutSocialLoginInput = {
    create?: XOR<UserCreateWithoutSocialLoginInput, UserUncheckedCreateWithoutSocialLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialLoginInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSocialLoginProviderTypeFieldUpdateOperationsInput = {
    set?: SocialLoginProviderType
  }

  export type UserUpdateOneRequiredWithoutSocialLoginNestedInput = {
    create?: XOR<UserCreateWithoutSocialLoginInput, UserUncheckedCreateWithoutSocialLoginInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialLoginInput
    upsert?: UserUpsertWithoutSocialLoginInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSocialLoginInput, UserUncheckedUpdateWithoutSocialLoginInput>
  }

  export type UserCreateNestedOneWithoutAgreementInput = {
    create?: XOR<UserCreateWithoutAgreementInput, UserUncheckedCreateWithoutAgreementInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgreementInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAgreementNestedInput = {
    create?: XOR<UserCreateWithoutAgreementInput, UserUncheckedCreateWithoutAgreementInput>
    connectOrCreate?: UserCreateOrConnectWithoutAgreementInput
    upsert?: UserUpsertWithoutAgreementInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAgreementInput, UserUncheckedUpdateWithoutAgreementInput>
  }

  export type ImageCreateNestedOneWithoutUserSchoolVerifyInput = {
    create?: XOR<ImageCreateWithoutUserSchoolVerifyInput, ImageUncheckedCreateWithoutUserSchoolVerifyInput>
    connectOrCreate?: ImageCreateOrConnectWithoutUserSchoolVerifyInput
    connect?: ImageWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserSchoolVerifyInput = {
    create?: XOR<UserCreateWithoutUserSchoolVerifyInput, UserUncheckedCreateWithoutUserSchoolVerifyInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSchoolVerifyInput
    connect?: UserWhereUniqueInput
  }

  export type EnumProcessFieldUpdateOperationsInput = {
    set?: Process
  }

  export type ImageUpdateOneRequiredWithoutUserSchoolVerifyNestedInput = {
    create?: XOR<ImageCreateWithoutUserSchoolVerifyInput, ImageUncheckedCreateWithoutUserSchoolVerifyInput>
    connectOrCreate?: ImageCreateOrConnectWithoutUserSchoolVerifyInput
    upsert?: ImageUpsertWithoutUserSchoolVerifyInput
    connect?: ImageWhereUniqueInput
    update?: XOR<ImageUpdateWithoutUserSchoolVerifyInput, ImageUncheckedUpdateWithoutUserSchoolVerifyInput>
  }

  export type UserUpdateOneRequiredWithoutUserSchoolVerifyNestedInput = {
    create?: XOR<UserCreateWithoutUserSchoolVerifyInput, UserUncheckedCreateWithoutUserSchoolVerifyInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSchoolVerifyInput
    upsert?: UserUpsertWithoutUserSchoolVerifyInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserSchoolVerifyInput, UserUncheckedUpdateWithoutUserSchoolVerifyInput>
  }

  export type SchoolCreateNestedOneWithoutUserSchoolInput = {
    create?: XOR<SchoolCreateWithoutUserSchoolInput, SchoolUncheckedCreateWithoutUserSchoolInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUserSchoolInput
    connect?: SchoolWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserSchoolInput = {
    create?: XOR<UserCreateWithoutUserSchoolInput, UserUncheckedCreateWithoutUserSchoolInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSchoolInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolUpdateOneRequiredWithoutUserSchoolNestedInput = {
    create?: XOR<SchoolCreateWithoutUserSchoolInput, SchoolUncheckedCreateWithoutUserSchoolInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutUserSchoolInput
    upsert?: SchoolUpsertWithoutUserSchoolInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<SchoolUpdateWithoutUserSchoolInput, SchoolUncheckedUpdateWithoutUserSchoolInput>
  }

  export type UserUpdateOneRequiredWithoutUserSchoolNestedInput = {
    create?: XOR<UserCreateWithoutUserSchoolInput, UserUncheckedCreateWithoutUserSchoolInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSchoolInput
    upsert?: UserUpsertWithoutUserSchoolInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserSchoolInput, UserUncheckedUpdateWithoutUserSchoolInput>
  }

  export type AskedCreateNestedManyWithoutAskedUserInput = {
    create?: XOR<Enumerable<AskedCreateWithoutAskedUserInput>, Enumerable<AskedUncheckedCreateWithoutAskedUserInput>>
    connectOrCreate?: Enumerable<AskedCreateOrConnectWithoutAskedUserInput>
    createMany?: AskedCreateManyAskedUserInputEnvelope
    connect?: Enumerable<AskedWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutAskedUserInput = {
    create?: XOR<UserCreateWithoutAskedUserInput, UserUncheckedCreateWithoutAskedUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutAskedUserInput
    connect?: UserWhereUniqueInput
  }

  export type AskedUncheckedCreateNestedManyWithoutAskedUserInput = {
    create?: XOR<Enumerable<AskedCreateWithoutAskedUserInput>, Enumerable<AskedUncheckedCreateWithoutAskedUserInput>>
    connectOrCreate?: Enumerable<AskedCreateOrConnectWithoutAskedUserInput>
    createMany?: AskedCreateManyAskedUserInputEnvelope
    connect?: Enumerable<AskedWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AskedUpdateManyWithoutAskedUserNestedInput = {
    create?: XOR<Enumerable<AskedCreateWithoutAskedUserInput>, Enumerable<AskedUncheckedCreateWithoutAskedUserInput>>
    connectOrCreate?: Enumerable<AskedCreateOrConnectWithoutAskedUserInput>
    upsert?: Enumerable<AskedUpsertWithWhereUniqueWithoutAskedUserInput>
    createMany?: AskedCreateManyAskedUserInputEnvelope
    set?: Enumerable<AskedWhereUniqueInput>
    disconnect?: Enumerable<AskedWhereUniqueInput>
    delete?: Enumerable<AskedWhereUniqueInput>
    connect?: Enumerable<AskedWhereUniqueInput>
    update?: Enumerable<AskedUpdateWithWhereUniqueWithoutAskedUserInput>
    updateMany?: Enumerable<AskedUpdateManyWithWhereWithoutAskedUserInput>
    deleteMany?: Enumerable<AskedScalarWhereInput>
  }

  export type UserUpdateOneRequiredWithoutAskedUserNestedInput = {
    create?: XOR<UserCreateWithoutAskedUserInput, UserUncheckedCreateWithoutAskedUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutAskedUserInput
    upsert?: UserUpsertWithoutAskedUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAskedUserInput, UserUncheckedUpdateWithoutAskedUserInput>
  }

  export type AskedUncheckedUpdateManyWithoutAskedUserNestedInput = {
    create?: XOR<Enumerable<AskedCreateWithoutAskedUserInput>, Enumerable<AskedUncheckedCreateWithoutAskedUserInput>>
    connectOrCreate?: Enumerable<AskedCreateOrConnectWithoutAskedUserInput>
    upsert?: Enumerable<AskedUpsertWithWhereUniqueWithoutAskedUserInput>
    createMany?: AskedCreateManyAskedUserInputEnvelope
    set?: Enumerable<AskedWhereUniqueInput>
    disconnect?: Enumerable<AskedWhereUniqueInput>
    delete?: Enumerable<AskedWhereUniqueInput>
    connect?: Enumerable<AskedWhereUniqueInput>
    update?: Enumerable<AskedUpdateWithWhereUniqueWithoutAskedUserInput>
    updateMany?: Enumerable<AskedUpdateManyWithWhereWithoutAskedUserInput>
    deleteMany?: Enumerable<AskedScalarWhereInput>
  }

  export type AskedUserCreateNestedOneWithoutAskedInput = {
    create?: XOR<AskedUserCreateWithoutAskedInput, AskedUserUncheckedCreateWithoutAskedInput>
    connectOrCreate?: AskedUserCreateOrConnectWithoutAskedInput
    connect?: AskedUserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAskedInput = {
    create?: XOR<UserCreateWithoutAskedInput, UserUncheckedCreateWithoutAskedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAskedInput
    connect?: UserWhereUniqueInput
  }

  export type AskedUserUpdateOneRequiredWithoutAskedNestedInput = {
    create?: XOR<AskedUserCreateWithoutAskedInput, AskedUserUncheckedCreateWithoutAskedInput>
    connectOrCreate?: AskedUserCreateOrConnectWithoutAskedInput
    upsert?: AskedUserUpsertWithoutAskedInput
    connect?: AskedUserWhereUniqueInput
    update?: XOR<AskedUserUpdateWithoutAskedInput, AskedUserUncheckedUpdateWithoutAskedInput>
  }

  export type UserUpdateOneRequiredWithoutAskedNestedInput = {
    create?: XOR<UserCreateWithoutAskedInput, UserUncheckedCreateWithoutAskedInput>
    connectOrCreate?: UserCreateOrConnectWithoutAskedInput
    upsert?: UserUpsertWithoutAskedInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAskedInput, UserUncheckedUpdateWithoutAskedInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoardCreatenoticeIdInput = {
    set: Enumerable<number>
  }

  export type ArticleCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutBoardInput>, Enumerable<ArticleUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutBoardInput>
    createMany?: ArticleCreateManyBoardInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type BoardManagerCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<BoardManagerCreateWithoutBoardInput>, Enumerable<BoardManagerUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardManagerCreateOrConnectWithoutBoardInput>
    createMany?: BoardManagerCreateManyBoardInputEnvelope
    connect?: Enumerable<BoardManagerWhereUniqueInput>
  }

  export type ArticleUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutBoardInput>, Enumerable<ArticleUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutBoardInput>
    createMany?: ArticleCreateManyBoardInputEnvelope
    connect?: Enumerable<ArticleWhereUniqueInput>
  }

  export type BoardManagerUncheckedCreateNestedManyWithoutBoardInput = {
    create?: XOR<Enumerable<BoardManagerCreateWithoutBoardInput>, Enumerable<BoardManagerUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardManagerCreateOrConnectWithoutBoardInput>
    createMany?: BoardManagerCreateManyBoardInputEnvelope
    connect?: Enumerable<BoardManagerWhereUniqueInput>
  }

  export type BoardUpdatenoticeIdInput = {
    set?: Enumerable<number>
    push?: number | Enumerable<number>
  }

  export type ArticleUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutBoardInput>, Enumerable<ArticleUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: ArticleCreateManyBoardInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type BoardManagerUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<BoardManagerCreateWithoutBoardInput>, Enumerable<BoardManagerUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardManagerCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<BoardManagerUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: BoardManagerCreateManyBoardInputEnvelope
    set?: Enumerable<BoardManagerWhereUniqueInput>
    disconnect?: Enumerable<BoardManagerWhereUniqueInput>
    delete?: Enumerable<BoardManagerWhereUniqueInput>
    connect?: Enumerable<BoardManagerWhereUniqueInput>
    update?: Enumerable<BoardManagerUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<BoardManagerUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<BoardManagerScalarWhereInput>
  }

  export type ArticleUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<ArticleCreateWithoutBoardInput>, Enumerable<ArticleUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<ArticleCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<ArticleUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: ArticleCreateManyBoardInputEnvelope
    set?: Enumerable<ArticleWhereUniqueInput>
    disconnect?: Enumerable<ArticleWhereUniqueInput>
    delete?: Enumerable<ArticleWhereUniqueInput>
    connect?: Enumerable<ArticleWhereUniqueInput>
    update?: Enumerable<ArticleUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<ArticleUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<ArticleScalarWhereInput>
  }

  export type BoardManagerUncheckedUpdateManyWithoutBoardNestedInput = {
    create?: XOR<Enumerable<BoardManagerCreateWithoutBoardInput>, Enumerable<BoardManagerUncheckedCreateWithoutBoardInput>>
    connectOrCreate?: Enumerable<BoardManagerCreateOrConnectWithoutBoardInput>
    upsert?: Enumerable<BoardManagerUpsertWithWhereUniqueWithoutBoardInput>
    createMany?: BoardManagerCreateManyBoardInputEnvelope
    set?: Enumerable<BoardManagerWhereUniqueInput>
    disconnect?: Enumerable<BoardManagerWhereUniqueInput>
    delete?: Enumerable<BoardManagerWhereUniqueInput>
    connect?: Enumerable<BoardManagerWhereUniqueInput>
    update?: Enumerable<BoardManagerUpdateWithWhereUniqueWithoutBoardInput>
    updateMany?: Enumerable<BoardManagerUpdateManyWithWhereWithoutBoardInput>
    deleteMany?: Enumerable<BoardManagerScalarWhereInput>
  }

  export type BoardCreateNestedOneWithoutManagersInput = {
    create?: XOR<BoardCreateWithoutManagersInput, BoardUncheckedCreateWithoutManagersInput>
    connectOrCreate?: BoardCreateOrConnectWithoutManagersInput
    connect?: BoardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBoardOrganizationsInput = {
    create?: XOR<UserCreateWithoutBoardOrganizationsInput, UserUncheckedCreateWithoutBoardOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardOrganizationsInput
    connect?: UserWhereUniqueInput
  }

  export type BoardUpdateOneRequiredWithoutManagersNestedInput = {
    create?: XOR<BoardCreateWithoutManagersInput, BoardUncheckedCreateWithoutManagersInput>
    connectOrCreate?: BoardCreateOrConnectWithoutManagersInput
    upsert?: BoardUpsertWithoutManagersInput
    connect?: BoardWhereUniqueInput
    update?: XOR<BoardUpdateWithoutManagersInput, BoardUncheckedUpdateWithoutManagersInput>
  }

  export type UserUpdateOneRequiredWithoutBoardOrganizationsNestedInput = {
    create?: XOR<UserCreateWithoutBoardOrganizationsInput, UserUncheckedCreateWithoutBoardOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBoardOrganizationsInput
    upsert?: UserUpsertWithoutBoardOrganizationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutBoardOrganizationsInput, UserUncheckedUpdateWithoutBoardOrganizationsInput>
  }

  export type ArticleCreateimagesInput = {
    set: Enumerable<string>
  }

  export type BoardCreateNestedOneWithoutArticleInput = {
    create?: XOR<BoardCreateWithoutArticleInput, BoardUncheckedCreateWithoutArticleInput>
    connectOrCreate?: BoardCreateOrConnectWithoutArticleInput
    connect?: BoardWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutArticleInput = {
    create?: XOR<UserCreateWithoutArticleInput, UserUncheckedCreateWithoutArticleInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticleInput
    connect?: UserWhereUniqueInput
  }

  export type SchoolCreateNestedOneWithoutArticleInput = {
    create?: XOR<SchoolCreateWithoutArticleInput, SchoolUncheckedCreateWithoutArticleInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutArticleInput
    connect?: SchoolWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<CommentCreateWithoutArticleInput>, Enumerable<CommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutArticleInput>
    createMany?: CommentCreateManyArticleInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type ReCommentCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutArticleInput>, Enumerable<ReCommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutArticleInput>
    createMany?: ReCommentCreateManyArticleInputEnvelope
    connect?: Enumerable<ReCommentWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<CommentCreateWithoutArticleInput>, Enumerable<CommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutArticleInput>
    createMany?: CommentCreateManyArticleInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type ReCommentUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutArticleInput>, Enumerable<ReCommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutArticleInput>
    createMany?: ReCommentCreateManyArticleInputEnvelope
    connect?: Enumerable<ReCommentWhereUniqueInput>
  }

  export type ArticleUpdateimagesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type BoardUpdateOneRequiredWithoutArticleNestedInput = {
    create?: XOR<BoardCreateWithoutArticleInput, BoardUncheckedCreateWithoutArticleInput>
    connectOrCreate?: BoardCreateOrConnectWithoutArticleInput
    upsert?: BoardUpsertWithoutArticleInput
    connect?: BoardWhereUniqueInput
    update?: XOR<BoardUpdateWithoutArticleInput, BoardUncheckedUpdateWithoutArticleInput>
  }

  export type UserUpdateOneRequiredWithoutArticleNestedInput = {
    create?: XOR<UserCreateWithoutArticleInput, UserUncheckedCreateWithoutArticleInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticleInput
    upsert?: UserUpsertWithoutArticleInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutArticleInput, UserUncheckedUpdateWithoutArticleInput>
  }

  export type SchoolUpdateOneRequiredWithoutArticleNestedInput = {
    create?: XOR<SchoolCreateWithoutArticleInput, SchoolUncheckedCreateWithoutArticleInput>
    connectOrCreate?: SchoolCreateOrConnectWithoutArticleInput
    upsert?: SchoolUpsertWithoutArticleInput
    connect?: SchoolWhereUniqueInput
    update?: XOR<SchoolUpdateWithoutArticleInput, SchoolUncheckedUpdateWithoutArticleInput>
  }

  export type CommentUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutArticleInput>, Enumerable<CommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: CommentCreateManyArticleInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type ReCommentUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutArticleInput>, Enumerable<ReCommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<ReCommentUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: ReCommentCreateManyArticleInputEnvelope
    set?: Enumerable<ReCommentWhereUniqueInput>
    disconnect?: Enumerable<ReCommentWhereUniqueInput>
    delete?: Enumerable<ReCommentWhereUniqueInput>
    connect?: Enumerable<ReCommentWhereUniqueInput>
    update?: Enumerable<ReCommentUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<ReCommentUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<ReCommentScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutArticleInput>, Enumerable<CommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: CommentCreateManyArticleInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type ReCommentUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutArticleInput>, Enumerable<ReCommentUncheckedCreateWithoutArticleInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutArticleInput>
    upsert?: Enumerable<ReCommentUpsertWithWhereUniqueWithoutArticleInput>
    createMany?: ReCommentCreateManyArticleInputEnvelope
    set?: Enumerable<ReCommentWhereUniqueInput>
    disconnect?: Enumerable<ReCommentWhereUniqueInput>
    delete?: Enumerable<ReCommentWhereUniqueInput>
    connect?: Enumerable<ReCommentWhereUniqueInput>
    update?: Enumerable<ReCommentUpdateWithWhereUniqueWithoutArticleInput>
    updateMany?: Enumerable<ReCommentUpdateManyWithWhereWithoutArticleInput>
    deleteMany?: Enumerable<ReCommentScalarWhereInput>
  }

  export type DeletedArticleCreateimagesInput = {
    set: Enumerable<string>
  }

  export type DeletedArticleUpdateimagesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type EnumBoardRequestProcessFieldUpdateOperationsInput = {
    set?: BoardRequestProcess
  }

  export type ArticleCreateNestedOneWithoutCommentInput = {
    create?: XOR<ArticleCreateWithoutCommentInput, ArticleUncheckedCreateWithoutCommentInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutCommentInput
    connect?: ArticleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    connect?: UserWhereUniqueInput
  }

  export type ReCommentCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutCommentInput>, Enumerable<ReCommentUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutCommentInput>
    createMany?: ReCommentCreateManyCommentInputEnvelope
    connect?: Enumerable<ReCommentWhereUniqueInput>
  }

  export type ReCommentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutCommentInput>, Enumerable<ReCommentUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutCommentInput>
    createMany?: ReCommentCreateManyCommentInputEnvelope
    connect?: Enumerable<ReCommentWhereUniqueInput>
  }

  export type ArticleUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<ArticleCreateWithoutCommentInput, ArticleUncheckedCreateWithoutCommentInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutCommentInput
    upsert?: ArticleUpsertWithoutCommentInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutCommentInput, ArticleUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    upsert?: UserUpsertWithoutCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
  }

  export type ReCommentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutCommentInput>, Enumerable<ReCommentUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<ReCommentUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: ReCommentCreateManyCommentInputEnvelope
    set?: Enumerable<ReCommentWhereUniqueInput>
    disconnect?: Enumerable<ReCommentWhereUniqueInput>
    delete?: Enumerable<ReCommentWhereUniqueInput>
    connect?: Enumerable<ReCommentWhereUniqueInput>
    update?: Enumerable<ReCommentUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<ReCommentUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<ReCommentScalarWhereInput>
  }

  export type ReCommentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<Enumerable<ReCommentCreateWithoutCommentInput>, Enumerable<ReCommentUncheckedCreateWithoutCommentInput>>
    connectOrCreate?: Enumerable<ReCommentCreateOrConnectWithoutCommentInput>
    upsert?: Enumerable<ReCommentUpsertWithWhereUniqueWithoutCommentInput>
    createMany?: ReCommentCreateManyCommentInputEnvelope
    set?: Enumerable<ReCommentWhereUniqueInput>
    disconnect?: Enumerable<ReCommentWhereUniqueInput>
    delete?: Enumerable<ReCommentWhereUniqueInput>
    connect?: Enumerable<ReCommentWhereUniqueInput>
    update?: Enumerable<ReCommentUpdateWithWhereUniqueWithoutCommentInput>
    updateMany?: Enumerable<ReCommentUpdateManyWithWhereWithoutCommentInput>
    deleteMany?: Enumerable<ReCommentScalarWhereInput>
  }

  export type ArticleCreateNestedOneWithoutReCommentInput = {
    create?: XOR<ArticleCreateWithoutReCommentInput, ArticleUncheckedCreateWithoutReCommentInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutReCommentInput
    connect?: ArticleWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRecommentsInput = {
    create?: XOR<CommentCreateWithoutRecommentsInput, CommentUncheckedCreateWithoutRecommentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRecommentsInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReCommentInput = {
    create?: XOR<UserCreateWithoutReCommentInput, UserUncheckedCreateWithoutReCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutReCommentInput
    connect?: UserWhereUniqueInput
  }

  export type ArticleUpdateOneRequiredWithoutReCommentNestedInput = {
    create?: XOR<ArticleCreateWithoutReCommentInput, ArticleUncheckedCreateWithoutReCommentInput>
    connectOrCreate?: ArticleCreateOrConnectWithoutReCommentInput
    upsert?: ArticleUpsertWithoutReCommentInput
    connect?: ArticleWhereUniqueInput
    update?: XOR<ArticleUpdateWithoutReCommentInput, ArticleUncheckedUpdateWithoutReCommentInput>
  }

  export type CommentUpdateOneWithoutRecommentsNestedInput = {
    create?: XOR<CommentCreateWithoutRecommentsInput, CommentUncheckedCreateWithoutRecommentsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRecommentsInput
    upsert?: CommentUpsertWithoutRecommentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<CommentUpdateWithoutRecommentsInput, CommentUncheckedUpdateWithoutRecommentsInput>
  }

  export type UserUpdateOneRequiredWithoutReCommentNestedInput = {
    create?: XOR<UserCreateWithoutReCommentInput, UserUncheckedCreateWithoutReCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutReCommentInput
    upsert?: UserUpsertWithoutReCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReCommentInput, UserUncheckedUpdateWithoutReCommentInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumReportTargetTypeFieldUpdateOperationsInput = {
    set?: ReportTargetType
  }

  export type EnumReportProcessFieldUpdateOperationsInput = {
    set?: ReportProcess
  }

  export type UserCreateNestedOneWithoutLikeInput = {
    create?: XOR<UserCreateWithoutLikeInput, UserUncheckedCreateWithoutLikeInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikeInput
    connect?: UserWhereUniqueInput
  }

  export type EnumLikeTargetTypeFieldUpdateOperationsInput = {
    set?: LikeTargetType
  }

  export type EnumLikeTypeFieldUpdateOperationsInput = {
    set?: LikeType
  }

  export type UserUpdateOneRequiredWithoutLikeNestedInput = {
    create?: XOR<UserCreateWithoutLikeInput, UserUncheckedCreateWithoutLikeInput>
    connectOrCreate?: UserCreateOrConnectWithoutLikeInput
    upsert?: UserUpsertWithoutLikeInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLikeInput, UserUncheckedUpdateWithoutLikeInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedEnumUserLoginProviderTypeFilter = {
    equals?: UserLoginProviderType
    in?: Enumerable<UserLoginProviderType>
    notIn?: Enumerable<UserLoginProviderType>
    not?: NestedEnumUserLoginProviderTypeFilter | UserLoginProviderType
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumUserLoginProviderTypeWithAggregatesFilter = {
    equals?: UserLoginProviderType
    in?: Enumerable<UserLoginProviderType>
    notIn?: Enumerable<UserLoginProviderType>
    not?: NestedEnumUserLoginProviderTypeWithAggregatesFilter | UserLoginProviderType
    _count?: NestedIntFilter
    _min?: NestedEnumUserLoginProviderTypeFilter
    _max?: NestedEnumUserLoginProviderTypeFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedEnumSocialLoginProviderTypeFilter = {
    equals?: SocialLoginProviderType
    in?: Enumerable<SocialLoginProviderType>
    notIn?: Enumerable<SocialLoginProviderType>
    not?: NestedEnumSocialLoginProviderTypeFilter | SocialLoginProviderType
  }

  export type NestedEnumSocialLoginProviderTypeWithAggregatesFilter = {
    equals?: SocialLoginProviderType
    in?: Enumerable<SocialLoginProviderType>
    notIn?: Enumerable<SocialLoginProviderType>
    not?: NestedEnumSocialLoginProviderTypeWithAggregatesFilter | SocialLoginProviderType
    _count?: NestedIntFilter
    _min?: NestedEnumSocialLoginProviderTypeFilter
    _max?: NestedEnumSocialLoginProviderTypeFilter
  }

  export type NestedEnumProcessFilter = {
    equals?: Process
    in?: Enumerable<Process>
    notIn?: Enumerable<Process>
    not?: NestedEnumProcessFilter | Process
  }

  export type NestedEnumProcessWithAggregatesFilter = {
    equals?: Process
    in?: Enumerable<Process>
    notIn?: Enumerable<Process>
    not?: NestedEnumProcessWithAggregatesFilter | Process
    _count?: NestedIntFilter
    _min?: NestedEnumProcessFilter
    _max?: NestedEnumProcessFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedEnumBoardRequestProcessFilter = {
    equals?: BoardRequestProcess
    in?: Enumerable<BoardRequestProcess>
    notIn?: Enumerable<BoardRequestProcess>
    not?: NestedEnumBoardRequestProcessFilter | BoardRequestProcess
  }

  export type NestedEnumBoardRequestProcessWithAggregatesFilter = {
    equals?: BoardRequestProcess
    in?: Enumerable<BoardRequestProcess>
    notIn?: Enumerable<BoardRequestProcess>
    not?: NestedEnumBoardRequestProcessWithAggregatesFilter | BoardRequestProcess
    _count?: NestedIntFilter
    _min?: NestedEnumBoardRequestProcessFilter
    _max?: NestedEnumBoardRequestProcessFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedEnumReportTargetTypeFilter = {
    equals?: ReportTargetType
    in?: Enumerable<ReportTargetType>
    notIn?: Enumerable<ReportTargetType>
    not?: NestedEnumReportTargetTypeFilter | ReportTargetType
  }

  export type NestedEnumReportProcessFilter = {
    equals?: ReportProcess
    in?: Enumerable<ReportProcess>
    notIn?: Enumerable<ReportProcess>
    not?: NestedEnumReportProcessFilter | ReportProcess
  }

  export type NestedEnumReportTargetTypeWithAggregatesFilter = {
    equals?: ReportTargetType
    in?: Enumerable<ReportTargetType>
    notIn?: Enumerable<ReportTargetType>
    not?: NestedEnumReportTargetTypeWithAggregatesFilter | ReportTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumReportTargetTypeFilter
    _max?: NestedEnumReportTargetTypeFilter
  }

  export type NestedEnumReportProcessWithAggregatesFilter = {
    equals?: ReportProcess
    in?: Enumerable<ReportProcess>
    notIn?: Enumerable<ReportProcess>
    not?: NestedEnumReportProcessWithAggregatesFilter | ReportProcess
    _count?: NestedIntFilter
    _min?: NestedEnumReportProcessFilter
    _max?: NestedEnumReportProcessFilter
  }

  export type NestedEnumLikeTargetTypeFilter = {
    equals?: LikeTargetType
    in?: Enumerable<LikeTargetType>
    notIn?: Enumerable<LikeTargetType>
    not?: NestedEnumLikeTargetTypeFilter | LikeTargetType
  }

  export type NestedEnumLikeTypeFilter = {
    equals?: LikeType
    in?: Enumerable<LikeType>
    notIn?: Enumerable<LikeType>
    not?: NestedEnumLikeTypeFilter | LikeType
  }

  export type NestedEnumLikeTargetTypeWithAggregatesFilter = {
    equals?: LikeTargetType
    in?: Enumerable<LikeTargetType>
    notIn?: Enumerable<LikeTargetType>
    not?: NestedEnumLikeTargetTypeWithAggregatesFilter | LikeTargetType
    _count?: NestedIntFilter
    _min?: NestedEnumLikeTargetTypeFilter
    _max?: NestedEnumLikeTargetTypeFilter
  }

  export type NestedEnumLikeTypeWithAggregatesFilter = {
    equals?: LikeType
    in?: Enumerable<LikeType>
    notIn?: Enumerable<LikeType>
    not?: NestedEnumLikeTypeWithAggregatesFilter | LikeType
    _count?: NestedIntFilter
    _min?: NestedEnumLikeTypeFilter
    _max?: NestedEnumLikeTypeFilter
  }

  export type AgreementCreateWithoutUserInput = {
    updatedAt?: Date | string
    receive?: boolean
  }

  export type AgreementUncheckedCreateWithoutUserInput = {
    updatedAt?: Date | string
    receive?: boolean
  }

  export type AgreementCreateOrConnectWithoutUserInput = {
    where: AgreementWhereUniqueInput
    create: XOR<AgreementCreateWithoutUserInput, AgreementUncheckedCreateWithoutUserInput>
  }

  export type ArticleCreateWithoutUserInput = {
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    createdAt?: Date | string
    Board: BoardCreateNestedOneWithoutArticleInput
    school: SchoolCreateNestedOneWithoutArticleInput
    Comment?: CommentCreateNestedManyWithoutArticleInput
    ReComment?: ReCommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutUserInput = {
    id?: number
    schoolId: string
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    createdAt?: Date | string
    boardId: number
    Comment?: CommentUncheckedCreateNestedManyWithoutArticleInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutUserInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutUserInput, ArticleUncheckedCreateWithoutUserInput>
  }

  export type ArticleCreateManyUserInputEnvelope = {
    data: Enumerable<ArticleCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AskedCreateWithoutQuestionUserInput = {
    id?: string
    process?: Process
    question: string
    answer?: string | null
    createdAt?: Date | string
    answerTimeAt?: Date | string | null
    isAnonymous: boolean
    AskedUser: AskedUserCreateNestedOneWithoutAskedInput
  }

  export type AskedUncheckedCreateWithoutQuestionUserInput = {
    id?: string
    askedUserId: string
    process?: Process
    question: string
    answer?: string | null
    createdAt?: Date | string
    answerTimeAt?: Date | string | null
    isAnonymous: boolean
  }

  export type AskedCreateOrConnectWithoutQuestionUserInput = {
    where: AskedWhereUniqueInput
    create: XOR<AskedCreateWithoutQuestionUserInput, AskedUncheckedCreateWithoutQuestionUserInput>
  }

  export type AskedCreateManyQuestionUserInputEnvelope = {
    data: Enumerable<AskedCreateManyQuestionUserInput>
    skipDuplicates?: boolean
  }

  export type AskedUserCreateWithoutUserInput = {
    customId?: string | null
    statusMessage?: string | null
    receiveAnonymous?: boolean
    receiveOtherSchool?: boolean
    lastUpdateCustomId?: Date | string | null
    Asked?: AskedCreateNestedManyWithoutAskedUserInput
  }

  export type AskedUserUncheckedCreateWithoutUserInput = {
    customId?: string | null
    statusMessage?: string | null
    receiveAnonymous?: boolean
    receiveOtherSchool?: boolean
    lastUpdateCustomId?: Date | string | null
    Asked?: AskedUncheckedCreateNestedManyWithoutAskedUserInput
  }

  export type AskedUserCreateOrConnectWithoutUserInput = {
    where: AskedUserWhereUniqueInput
    create: XOR<AskedUserCreateWithoutUserInput, AskedUserUncheckedCreateWithoutUserInput>
  }

  export type BoardManagerCreateWithoutUserInput = {
    id?: string
    name: string
    board: BoardCreateNestedOneWithoutManagersInput
  }

  export type BoardManagerUncheckedCreateWithoutUserInput = {
    id?: string
    boardId: number
    name: string
  }

  export type BoardManagerCreateOrConnectWithoutUserInput = {
    where: BoardManagerWhereUniqueInput
    create: XOR<BoardManagerCreateWithoutUserInput, BoardManagerUncheckedCreateWithoutUserInput>
  }

  export type BoardManagerCreateManyUserInputEnvelope = {
    data: Enumerable<BoardManagerCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Article: ArticleCreateNestedOneWithoutCommentInput
    recomments?: ReCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    articleId: number
    recomments?: ReCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: Enumerable<CommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ImageCreateWithoutUserInput = {
    id?: string
    key: string
    createdAt?: Date | string
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutUserInput = {
    id?: string
    key: string
    createdAt?: Date | string
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutImageInput
  }

  export type ImageCreateOrConnectWithoutUserInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutUserInput, ImageUncheckedCreateWithoutUserInput>
  }

  export type ImageCreateManyUserInputEnvelope = {
    data: Enumerable<ImageCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type LikeCreateWithoutUserInput = {
    id?: string
    targetId: number
    targetType: LikeTargetType
    likeType: LikeType
  }

  export type LikeUncheckedCreateWithoutUserInput = {
    id?: string
    targetId: number
    targetType: LikeTargetType
    likeType: LikeType
  }

  export type LikeCreateOrConnectWithoutUserInput = {
    where: LikeWhereUniqueInput
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeCreateManyUserInputEnvelope = {
    data: Enumerable<LikeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ReCommentCreateWithoutUserInput = {
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Article: ArticleCreateNestedOneWithoutReCommentInput
    Comment?: CommentCreateNestedOneWithoutRecommentsInput
  }

  export type ReCommentUncheckedCreateWithoutUserInput = {
    id?: number
    articleId: number
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commentId?: number | null
  }

  export type ReCommentCreateOrConnectWithoutUserInput = {
    where: ReCommentWhereUniqueInput
    create: XOR<ReCommentCreateWithoutUserInput, ReCommentUncheckedCreateWithoutUserInput>
  }

  export type ReCommentCreateManyUserInputEnvelope = {
    data: Enumerable<ReCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type SocialLoginCreateWithoutUserInput = {
    accessToken: string
    refreshToken?: string | null
    socialId: string
    provider: SocialLoginProviderType
  }

  export type SocialLoginUncheckedCreateWithoutUserInput = {
    accessToken: string
    refreshToken?: string | null
    socialId: string
    provider: SocialLoginProviderType
  }

  export type SocialLoginCreateOrConnectWithoutUserInput = {
    where: SocialLoginWhereUniqueInput
    create: XOR<SocialLoginCreateWithoutUserInput, SocialLoginUncheckedCreateWithoutUserInput>
  }

  export type UserSchoolCreateWithoutUserInput = {
    dept: string
    grade: string
    class: string
    school: SchoolCreateNestedOneWithoutUserSchoolInput
  }

  export type UserSchoolUncheckedCreateWithoutUserInput = {
    schoolId: string
    dept: string
    grade: string
    class: string
  }

  export type UserSchoolCreateOrConnectWithoutUserInput = {
    where: UserSchoolWhereUniqueInput
    create: XOR<UserSchoolCreateWithoutUserInput, UserSchoolUncheckedCreateWithoutUserInput>
  }

  export type UserSchoolVerifyCreateWithoutUserInput = {
    id?: string
    schoolId: string
    grade: string
    class: string
    message?: string | null
    process?: Process
    createdAt?: Date | string
    schoolName: string
    userName: string
    dept: string
    image: ImageCreateNestedOneWithoutUserSchoolVerifyInput
  }

  export type UserSchoolVerifyUncheckedCreateWithoutUserInput = {
    id?: string
    imageId: string
    schoolId: string
    grade: string
    class: string
    message?: string | null
    process?: Process
    createdAt?: Date | string
    schoolName: string
    userName: string
    dept: string
  }

  export type UserSchoolVerifyCreateOrConnectWithoutUserInput = {
    where: UserSchoolVerifyWhereUniqueInput
    create: XOR<UserSchoolVerifyCreateWithoutUserInput, UserSchoolVerifyUncheckedCreateWithoutUserInput>
  }

  export type UserSchoolVerifyCreateManyUserInputEnvelope = {
    data: Enumerable<UserSchoolVerifyCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type AgreementUpsertWithoutUserInput = {
    update: XOR<AgreementUpdateWithoutUserInput, AgreementUncheckedUpdateWithoutUserInput>
    create: XOR<AgreementCreateWithoutUserInput, AgreementUncheckedCreateWithoutUserInput>
  }

  export type AgreementUpdateWithoutUserInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AgreementUncheckedUpdateWithoutUserInput = {
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArticleUpsertWithWhereUniqueWithoutUserInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutUserInput, ArticleUncheckedUpdateWithoutUserInput>
    create: XOR<ArticleCreateWithoutUserInput, ArticleUncheckedCreateWithoutUserInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutUserInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutUserInput, ArticleUncheckedUpdateWithoutUserInput>
  }

  export type ArticleUpdateManyWithWhereWithoutUserInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutArticleInput>
  }

  export type ArticleScalarWhereInput = {
    AND?: Enumerable<ArticleScalarWhereInput>
    OR?: Enumerable<ArticleScalarWhereInput>
    NOT?: Enumerable<ArticleScalarWhereInput>
    id?: IntFilter | number
    schoolId?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    images?: StringNullableListFilter
    isAnonymous?: BoolFilter | boolean
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    boardId?: IntFilter | number
  }

  export type AskedUpsertWithWhereUniqueWithoutQuestionUserInput = {
    where: AskedWhereUniqueInput
    update: XOR<AskedUpdateWithoutQuestionUserInput, AskedUncheckedUpdateWithoutQuestionUserInput>
    create: XOR<AskedCreateWithoutQuestionUserInput, AskedUncheckedCreateWithoutQuestionUserInput>
  }

  export type AskedUpdateWithWhereUniqueWithoutQuestionUserInput = {
    where: AskedWhereUniqueInput
    data: XOR<AskedUpdateWithoutQuestionUserInput, AskedUncheckedUpdateWithoutQuestionUserInput>
  }

  export type AskedUpdateManyWithWhereWithoutQuestionUserInput = {
    where: AskedScalarWhereInput
    data: XOR<AskedUpdateManyMutationInput, AskedUncheckedUpdateManyWithoutAskedInput>
  }

  export type AskedScalarWhereInput = {
    AND?: Enumerable<AskedScalarWhereInput>
    OR?: Enumerable<AskedScalarWhereInput>
    NOT?: Enumerable<AskedScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    askedUserId?: StringFilter | string
    process?: EnumProcessFilter | Process
    question?: StringFilter | string
    answer?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    answerTimeAt?: DateTimeNullableFilter | Date | string | null
    isAnonymous?: BoolFilter | boolean
  }

  export type AskedUserUpsertWithoutUserInput = {
    update: XOR<AskedUserUpdateWithoutUserInput, AskedUserUncheckedUpdateWithoutUserInput>
    create: XOR<AskedUserCreateWithoutUserInput, AskedUserUncheckedCreateWithoutUserInput>
  }

  export type AskedUserUpdateWithoutUserInput = {
    customId?: NullableStringFieldUpdateOperationsInput | string | null
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    receiveAnonymous?: BoolFieldUpdateOperationsInput | boolean
    receiveOtherSchool?: BoolFieldUpdateOperationsInput | boolean
    lastUpdateCustomId?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Asked?: AskedUpdateManyWithoutAskedUserNestedInput
  }

  export type AskedUserUncheckedUpdateWithoutUserInput = {
    customId?: NullableStringFieldUpdateOperationsInput | string | null
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    receiveAnonymous?: BoolFieldUpdateOperationsInput | boolean
    receiveOtherSchool?: BoolFieldUpdateOperationsInput | boolean
    lastUpdateCustomId?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Asked?: AskedUncheckedUpdateManyWithoutAskedUserNestedInput
  }

  export type BoardManagerUpsertWithWhereUniqueWithoutUserInput = {
    where: BoardManagerWhereUniqueInput
    update: XOR<BoardManagerUpdateWithoutUserInput, BoardManagerUncheckedUpdateWithoutUserInput>
    create: XOR<BoardManagerCreateWithoutUserInput, BoardManagerUncheckedCreateWithoutUserInput>
  }

  export type BoardManagerUpdateWithWhereUniqueWithoutUserInput = {
    where: BoardManagerWhereUniqueInput
    data: XOR<BoardManagerUpdateWithoutUserInput, BoardManagerUncheckedUpdateWithoutUserInput>
  }

  export type BoardManagerUpdateManyWithWhereWithoutUserInput = {
    where: BoardManagerScalarWhereInput
    data: XOR<BoardManagerUpdateManyMutationInput, BoardManagerUncheckedUpdateManyWithoutBoardOrganizationsInput>
  }

  export type BoardManagerScalarWhereInput = {
    AND?: Enumerable<BoardManagerScalarWhereInput>
    OR?: Enumerable<BoardManagerScalarWhereInput>
    NOT?: Enumerable<BoardManagerScalarWhereInput>
    id?: StringFilter | string
    boardId?: IntFilter | number
    name?: StringFilter | string
    userId?: StringFilter | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentScalarWhereInput = {
    AND?: Enumerable<CommentScalarWhereInput>
    OR?: Enumerable<CommentScalarWhereInput>
    NOT?: Enumerable<CommentScalarWhereInput>
    userId?: StringFilter | string
    content?: StringFilter | string
    isAnonymous?: BoolFilter | boolean
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    id?: IntFilter | number
    articleId?: IntFilter | number
  }

  export type ImageUpsertWithWhereUniqueWithoutUserInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutUserInput, ImageUncheckedUpdateWithoutUserInput>
    create: XOR<ImageCreateWithoutUserInput, ImageUncheckedCreateWithoutUserInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutUserInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutUserInput, ImageUncheckedUpdateWithoutUserInput>
  }

  export type ImageUpdateManyWithWhereWithoutUserInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutImageInput>
  }

  export type ImageScalarWhereInput = {
    AND?: Enumerable<ImageScalarWhereInput>
    OR?: Enumerable<ImageScalarWhereInput>
    NOT?: Enumerable<ImageScalarWhereInput>
    id?: StringFilter | string
    key?: StringFilter | string
    userId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type LikeUpsertWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    update: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
    create: XOR<LikeCreateWithoutUserInput, LikeUncheckedCreateWithoutUserInput>
  }

  export type LikeUpdateWithWhereUniqueWithoutUserInput = {
    where: LikeWhereUniqueInput
    data: XOR<LikeUpdateWithoutUserInput, LikeUncheckedUpdateWithoutUserInput>
  }

  export type LikeUpdateManyWithWhereWithoutUserInput = {
    where: LikeScalarWhereInput
    data: XOR<LikeUpdateManyMutationInput, LikeUncheckedUpdateManyWithoutLikeInput>
  }

  export type LikeScalarWhereInput = {
    AND?: Enumerable<LikeScalarWhereInput>
    OR?: Enumerable<LikeScalarWhereInput>
    NOT?: Enumerable<LikeScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    targetId?: IntFilter | number
    targetType?: EnumLikeTargetTypeFilter | LikeTargetType
    likeType?: EnumLikeTypeFilter | LikeType
  }

  export type ReCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ReCommentWhereUniqueInput
    update: XOR<ReCommentUpdateWithoutUserInput, ReCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ReCommentCreateWithoutUserInput, ReCommentUncheckedCreateWithoutUserInput>
  }

  export type ReCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ReCommentWhereUniqueInput
    data: XOR<ReCommentUpdateWithoutUserInput, ReCommentUncheckedUpdateWithoutUserInput>
  }

  export type ReCommentUpdateManyWithWhereWithoutUserInput = {
    where: ReCommentScalarWhereInput
    data: XOR<ReCommentUpdateManyMutationInput, ReCommentUncheckedUpdateManyWithoutReCommentInput>
  }

  export type ReCommentScalarWhereInput = {
    AND?: Enumerable<ReCommentScalarWhereInput>
    OR?: Enumerable<ReCommentScalarWhereInput>
    NOT?: Enumerable<ReCommentScalarWhereInput>
    id?: IntFilter | number
    articleId?: IntFilter | number
    userId?: StringFilter | string
    content?: StringFilter | string
    isAnonymous?: BoolFilter | boolean
    isDeleted?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    commentId?: IntNullableFilter | number | null
  }

  export type SocialLoginUpsertWithoutUserInput = {
    update: XOR<SocialLoginUpdateWithoutUserInput, SocialLoginUncheckedUpdateWithoutUserInput>
    create: XOR<SocialLoginCreateWithoutUserInput, SocialLoginUncheckedCreateWithoutUserInput>
  }

  export type SocialLoginUpdateWithoutUserInput = {
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: StringFieldUpdateOperationsInput | string
    provider?: EnumSocialLoginProviderTypeFieldUpdateOperationsInput | SocialLoginProviderType
  }

  export type SocialLoginUncheckedUpdateWithoutUserInput = {
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    socialId?: StringFieldUpdateOperationsInput | string
    provider?: EnumSocialLoginProviderTypeFieldUpdateOperationsInput | SocialLoginProviderType
  }

  export type UserSchoolUpsertWithoutUserInput = {
    update: XOR<UserSchoolUpdateWithoutUserInput, UserSchoolUncheckedUpdateWithoutUserInput>
    create: XOR<UserSchoolCreateWithoutUserInput, UserSchoolUncheckedCreateWithoutUserInput>
  }

  export type UserSchoolUpdateWithoutUserInput = {
    dept?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    school?: SchoolUpdateOneRequiredWithoutUserSchoolNestedInput
  }

  export type UserSchoolUncheckedUpdateWithoutUserInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
  }

  export type UserSchoolVerifyUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSchoolVerifyWhereUniqueInput
    update: XOR<UserSchoolVerifyUpdateWithoutUserInput, UserSchoolVerifyUncheckedUpdateWithoutUserInput>
    create: XOR<UserSchoolVerifyCreateWithoutUserInput, UserSchoolVerifyUncheckedCreateWithoutUserInput>
  }

  export type UserSchoolVerifyUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSchoolVerifyWhereUniqueInput
    data: XOR<UserSchoolVerifyUpdateWithoutUserInput, UserSchoolVerifyUncheckedUpdateWithoutUserInput>
  }

  export type UserSchoolVerifyUpdateManyWithWhereWithoutUserInput = {
    where: UserSchoolVerifyScalarWhereInput
    data: XOR<UserSchoolVerifyUpdateManyMutationInput, UserSchoolVerifyUncheckedUpdateManyWithoutUserSchoolVerifyInput>
  }

  export type UserSchoolVerifyScalarWhereInput = {
    AND?: Enumerable<UserSchoolVerifyScalarWhereInput>
    OR?: Enumerable<UserSchoolVerifyScalarWhereInput>
    NOT?: Enumerable<UserSchoolVerifyScalarWhereInput>
    id?: StringFilter | string
    userId?: StringFilter | string
    imageId?: StringFilter | string
    schoolId?: StringFilter | string
    grade?: StringFilter | string
    class?: StringFilter | string
    message?: StringNullableFilter | string | null
    process?: EnumProcessFilter | Process
    createdAt?: DateTimeFilter | Date | string
    schoolName?: StringFilter | string
    userName?: StringFilter | string
    dept?: StringFilter | string
  }

  export type UserSchoolCreateWithoutSchoolInput = {
    dept: string
    grade: string
    class: string
    user: UserCreateNestedOneWithoutUserSchoolInput
  }

  export type UserSchoolUncheckedCreateWithoutSchoolInput = {
    userId: string
    dept: string
    grade: string
    class: string
  }

  export type UserSchoolCreateOrConnectWithoutSchoolInput = {
    where: UserSchoolWhereUniqueInput
    create: XOR<UserSchoolCreateWithoutSchoolInput, UserSchoolUncheckedCreateWithoutSchoolInput>
  }

  export type UserSchoolCreateManySchoolInputEnvelope = {
    data: Enumerable<UserSchoolCreateManySchoolInput>
    skipDuplicates?: boolean
  }

  export type ArticleCreateWithoutSchoolInput = {
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    createdAt?: Date | string
    Board: BoardCreateNestedOneWithoutArticleInput
    User: UserCreateNestedOneWithoutArticleInput
    Comment?: CommentCreateNestedManyWithoutArticleInput
    ReComment?: ReCommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutSchoolInput = {
    id?: number
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt?: Date | string
    boardId: number
    Comment?: CommentUncheckedCreateNestedManyWithoutArticleInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutSchoolInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutSchoolInput, ArticleUncheckedCreateWithoutSchoolInput>
  }

  export type ArticleCreateManySchoolInputEnvelope = {
    data: Enumerable<ArticleCreateManySchoolInput>
    skipDuplicates?: boolean
  }

  export type UserSchoolUpsertWithWhereUniqueWithoutSchoolInput = {
    where: UserSchoolWhereUniqueInput
    update: XOR<UserSchoolUpdateWithoutSchoolInput, UserSchoolUncheckedUpdateWithoutSchoolInput>
    create: XOR<UserSchoolCreateWithoutSchoolInput, UserSchoolUncheckedCreateWithoutSchoolInput>
  }

  export type UserSchoolUpdateWithWhereUniqueWithoutSchoolInput = {
    where: UserSchoolWhereUniqueInput
    data: XOR<UserSchoolUpdateWithoutSchoolInput, UserSchoolUncheckedUpdateWithoutSchoolInput>
  }

  export type UserSchoolUpdateManyWithWhereWithoutSchoolInput = {
    where: UserSchoolScalarWhereInput
    data: XOR<UserSchoolUpdateManyMutationInput, UserSchoolUncheckedUpdateManyWithoutUserSchoolInput>
  }

  export type UserSchoolScalarWhereInput = {
    AND?: Enumerable<UserSchoolScalarWhereInput>
    OR?: Enumerable<UserSchoolScalarWhereInput>
    NOT?: Enumerable<UserSchoolScalarWhereInput>
    userId?: StringFilter | string
    schoolId?: StringFilter | string
    dept?: StringFilter | string
    grade?: StringFilter | string
    class?: StringFilter | string
  }

  export type ArticleUpsertWithWhereUniqueWithoutSchoolInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutSchoolInput, ArticleUncheckedUpdateWithoutSchoolInput>
    create: XOR<ArticleCreateWithoutSchoolInput, ArticleUncheckedCreateWithoutSchoolInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutSchoolInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutSchoolInput, ArticleUncheckedUpdateWithoutSchoolInput>
  }

  export type ArticleUpdateManyWithWhereWithoutSchoolInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutArticleInput>
  }

  export type UserCreateWithoutImageInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutImageInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutImageInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutImageInput, UserUncheckedCreateWithoutImageInput>
  }

  export type UserSchoolVerifyCreateWithoutImageInput = {
    id?: string
    schoolId: string
    grade: string
    class: string
    message?: string | null
    process?: Process
    createdAt?: Date | string
    schoolName: string
    userName: string
    dept: string
    user: UserCreateNestedOneWithoutUserSchoolVerifyInput
  }

  export type UserSchoolVerifyUncheckedCreateWithoutImageInput = {
    id?: string
    userId: string
    schoolId: string
    grade: string
    class: string
    message?: string | null
    process?: Process
    createdAt?: Date | string
    schoolName: string
    userName: string
    dept: string
  }

  export type UserSchoolVerifyCreateOrConnectWithoutImageInput = {
    where: UserSchoolVerifyWhereUniqueInput
    create: XOR<UserSchoolVerifyCreateWithoutImageInput, UserSchoolVerifyUncheckedCreateWithoutImageInput>
  }

  export type UserSchoolVerifyCreateManyImageInputEnvelope = {
    data: Enumerable<UserSchoolVerifyCreateManyImageInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutImageInput = {
    update: XOR<UserUpdateWithoutImageInput, UserUncheckedUpdateWithoutImageInput>
    create: XOR<UserCreateWithoutImageInput, UserUncheckedCreateWithoutImageInput>
  }

  export type UserUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserSchoolVerifyUpsertWithWhereUniqueWithoutImageInput = {
    where: UserSchoolVerifyWhereUniqueInput
    update: XOR<UserSchoolVerifyUpdateWithoutImageInput, UserSchoolVerifyUncheckedUpdateWithoutImageInput>
    create: XOR<UserSchoolVerifyCreateWithoutImageInput, UserSchoolVerifyUncheckedCreateWithoutImageInput>
  }

  export type UserSchoolVerifyUpdateWithWhereUniqueWithoutImageInput = {
    where: UserSchoolVerifyWhereUniqueInput
    data: XOR<UserSchoolVerifyUpdateWithoutImageInput, UserSchoolVerifyUncheckedUpdateWithoutImageInput>
  }

  export type UserSchoolVerifyUpdateManyWithWhereWithoutImageInput = {
    where: UserSchoolVerifyScalarWhereInput
    data: XOR<UserSchoolVerifyUpdateManyMutationInput, UserSchoolVerifyUncheckedUpdateManyWithoutUserSchoolVerifyInput>
  }

  export type UserCreateWithoutSocialLoginInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSocialLoginInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSocialLoginInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocialLoginInput, UserUncheckedCreateWithoutSocialLoginInput>
  }

  export type UserUpsertWithoutSocialLoginInput = {
    update: XOR<UserUpdateWithoutSocialLoginInput, UserUncheckedUpdateWithoutSocialLoginInput>
    create: XOR<UserCreateWithoutSocialLoginInput, UserUncheckedCreateWithoutSocialLoginInput>
  }

  export type UserUpdateWithoutSocialLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSocialLoginInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAgreementInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAgreementInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAgreementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAgreementInput, UserUncheckedCreateWithoutAgreementInput>
  }

  export type UserUpsertWithoutAgreementInput = {
    update: XOR<UserUpdateWithoutAgreementInput, UserUncheckedUpdateWithoutAgreementInput>
    create: XOR<UserCreateWithoutAgreementInput, UserUncheckedCreateWithoutAgreementInput>
  }

  export type UserUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ImageCreateWithoutUserSchoolVerifyInput = {
    id?: string
    key: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutImageInput
  }

  export type ImageUncheckedCreateWithoutUserSchoolVerifyInput = {
    id?: string
    key: string
    userId: string
    createdAt?: Date | string
  }

  export type ImageCreateOrConnectWithoutUserSchoolVerifyInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutUserSchoolVerifyInput, ImageUncheckedCreateWithoutUserSchoolVerifyInput>
  }

  export type UserCreateWithoutUserSchoolVerifyInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSchoolVerifyInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSchoolVerifyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSchoolVerifyInput, UserUncheckedCreateWithoutUserSchoolVerifyInput>
  }

  export type ImageUpsertWithoutUserSchoolVerifyInput = {
    update: XOR<ImageUpdateWithoutUserSchoolVerifyInput, ImageUncheckedUpdateWithoutUserSchoolVerifyInput>
    create: XOR<ImageCreateWithoutUserSchoolVerifyInput, ImageUncheckedCreateWithoutUserSchoolVerifyInput>
  }

  export type ImageUpdateWithoutUserSchoolVerifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutUserSchoolVerifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutUserSchoolVerifyInput = {
    update: XOR<UserUpdateWithoutUserSchoolVerifyInput, UserUncheckedUpdateWithoutUserSchoolVerifyInput>
    create: XOR<UserCreateWithoutUserSchoolVerifyInput, UserUncheckedCreateWithoutUserSchoolVerifyInput>
  }

  export type UserUpdateWithoutUserSchoolVerifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSchoolVerifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
  }

  export type SchoolCreateWithoutUserSchoolInput = {
    schoolId: string
    org: string
    x: number
    y: number
    atptCode: string
    defaultName: string
    name?: string | null
    type: string
    Article?: ArticleCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutUserSchoolInput = {
    schoolId: string
    org: string
    x: number
    y: number
    atptCode: string
    defaultName: string
    name?: string | null
    type: string
    Article?: ArticleUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutUserSchoolInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutUserSchoolInput, SchoolUncheckedCreateWithoutUserSchoolInput>
  }

  export type UserCreateWithoutUserSchoolInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserSchoolInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserSchoolInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSchoolInput, UserUncheckedCreateWithoutUserSchoolInput>
  }

  export type SchoolUpsertWithoutUserSchoolInput = {
    update: XOR<SchoolUpdateWithoutUserSchoolInput, SchoolUncheckedUpdateWithoutUserSchoolInput>
    create: XOR<SchoolCreateWithoutUserSchoolInput, SchoolUncheckedCreateWithoutUserSchoolInput>
  }

  export type SchoolUpdateWithoutUserSchoolInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    org?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    atptCode?: StringFieldUpdateOperationsInput | string
    defaultName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    Article?: ArticleUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutUserSchoolInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    org?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    atptCode?: StringFieldUpdateOperationsInput | string
    defaultName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    Article?: ArticleUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type UserUpsertWithoutUserSchoolInput = {
    update: XOR<UserUpdateWithoutUserSchoolInput, UserUncheckedUpdateWithoutUserSchoolInput>
    create: XOR<UserCreateWithoutUserSchoolInput, UserUncheckedCreateWithoutUserSchoolInput>
  }

  export type UserUpdateWithoutUserSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSchoolInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AskedCreateWithoutAskedUserInput = {
    id?: string
    process?: Process
    question: string
    answer?: string | null
    createdAt?: Date | string
    answerTimeAt?: Date | string | null
    isAnonymous: boolean
    QuestionUser: UserCreateNestedOneWithoutAskedInput
  }

  export type AskedUncheckedCreateWithoutAskedUserInput = {
    id?: string
    userId: string
    process?: Process
    question: string
    answer?: string | null
    createdAt?: Date | string
    answerTimeAt?: Date | string | null
    isAnonymous: boolean
  }

  export type AskedCreateOrConnectWithoutAskedUserInput = {
    where: AskedWhereUniqueInput
    create: XOR<AskedCreateWithoutAskedUserInput, AskedUncheckedCreateWithoutAskedUserInput>
  }

  export type AskedCreateManyAskedUserInputEnvelope = {
    data: Enumerable<AskedCreateManyAskedUserInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAskedUserInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAskedUserInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAskedUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAskedUserInput, UserUncheckedCreateWithoutAskedUserInput>
  }

  export type AskedUpsertWithWhereUniqueWithoutAskedUserInput = {
    where: AskedWhereUniqueInput
    update: XOR<AskedUpdateWithoutAskedUserInput, AskedUncheckedUpdateWithoutAskedUserInput>
    create: XOR<AskedCreateWithoutAskedUserInput, AskedUncheckedCreateWithoutAskedUserInput>
  }

  export type AskedUpdateWithWhereUniqueWithoutAskedUserInput = {
    where: AskedWhereUniqueInput
    data: XOR<AskedUpdateWithoutAskedUserInput, AskedUncheckedUpdateWithoutAskedUserInput>
  }

  export type AskedUpdateManyWithWhereWithoutAskedUserInput = {
    where: AskedScalarWhereInput
    data: XOR<AskedUpdateManyMutationInput, AskedUncheckedUpdateManyWithoutAskedInput>
  }

  export type UserUpsertWithoutAskedUserInput = {
    update: XOR<UserUpdateWithoutAskedUserInput, UserUncheckedUpdateWithoutAskedUserInput>
    create: XOR<UserCreateWithoutAskedUserInput, UserUncheckedCreateWithoutAskedUserInput>
  }

  export type UserUpdateWithoutAskedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAskedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AskedUserCreateWithoutAskedInput = {
    customId?: string | null
    statusMessage?: string | null
    receiveAnonymous?: boolean
    receiveOtherSchool?: boolean
    lastUpdateCustomId?: Date | string | null
    user: UserCreateNestedOneWithoutAskedUserInput
  }

  export type AskedUserUncheckedCreateWithoutAskedInput = {
    userId: string
    customId?: string | null
    statusMessage?: string | null
    receiveAnonymous?: boolean
    receiveOtherSchool?: boolean
    lastUpdateCustomId?: Date | string | null
  }

  export type AskedUserCreateOrConnectWithoutAskedInput = {
    where: AskedUserWhereUniqueInput
    create: XOR<AskedUserCreateWithoutAskedInput, AskedUserUncheckedCreateWithoutAskedInput>
  }

  export type UserCreateWithoutAskedInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAskedInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAskedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAskedInput, UserUncheckedCreateWithoutAskedInput>
  }

  export type AskedUserUpsertWithoutAskedInput = {
    update: XOR<AskedUserUpdateWithoutAskedInput, AskedUserUncheckedUpdateWithoutAskedInput>
    create: XOR<AskedUserCreateWithoutAskedInput, AskedUserUncheckedCreateWithoutAskedInput>
  }

  export type AskedUserUpdateWithoutAskedInput = {
    customId?: NullableStringFieldUpdateOperationsInput | string | null
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    receiveAnonymous?: BoolFieldUpdateOperationsInput | boolean
    receiveOtherSchool?: BoolFieldUpdateOperationsInput | boolean
    lastUpdateCustomId?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAskedUserNestedInput
  }

  export type AskedUserUncheckedUpdateWithoutAskedInput = {
    userId?: StringFieldUpdateOperationsInput | string
    customId?: NullableStringFieldUpdateOperationsInput | string | null
    statusMessage?: NullableStringFieldUpdateOperationsInput | string | null
    receiveAnonymous?: BoolFieldUpdateOperationsInput | boolean
    receiveOtherSchool?: BoolFieldUpdateOperationsInput | boolean
    lastUpdateCustomId?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUpsertWithoutAskedInput = {
    update: XOR<UserUpdateWithoutAskedInput, UserUncheckedUpdateWithoutAskedInput>
    create: XOR<UserCreateWithoutAskedInput, UserUncheckedCreateWithoutAskedInput>
  }

  export type UserUpdateWithoutAskedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAskedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ArticleCreateWithoutBoardInput = {
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    createdAt?: Date | string
    User: UserCreateNestedOneWithoutArticleInput
    school: SchoolCreateNestedOneWithoutArticleInput
    Comment?: CommentCreateNestedManyWithoutArticleInput
    ReComment?: ReCommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutBoardInput = {
    id?: number
    schoolId: string
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt?: Date | string
    Comment?: CommentUncheckedCreateNestedManyWithoutArticleInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutBoardInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutBoardInput, ArticleUncheckedCreateWithoutBoardInput>
  }

  export type ArticleCreateManyBoardInputEnvelope = {
    data: Enumerable<ArticleCreateManyBoardInput>
    skipDuplicates?: boolean
  }

  export type BoardManagerCreateWithoutBoardInput = {
    id?: string
    name: string
    user: UserCreateNestedOneWithoutBoardOrganizationsInput
  }

  export type BoardManagerUncheckedCreateWithoutBoardInput = {
    id?: string
    name: string
    userId: string
  }

  export type BoardManagerCreateOrConnectWithoutBoardInput = {
    where: BoardManagerWhereUniqueInput
    create: XOR<BoardManagerCreateWithoutBoardInput, BoardManagerUncheckedCreateWithoutBoardInput>
  }

  export type BoardManagerCreateManyBoardInputEnvelope = {
    data: Enumerable<BoardManagerCreateManyBoardInput>
    skipDuplicates?: boolean
  }

  export type ArticleUpsertWithWhereUniqueWithoutBoardInput = {
    where: ArticleWhereUniqueInput
    update: XOR<ArticleUpdateWithoutBoardInput, ArticleUncheckedUpdateWithoutBoardInput>
    create: XOR<ArticleCreateWithoutBoardInput, ArticleUncheckedCreateWithoutBoardInput>
  }

  export type ArticleUpdateWithWhereUniqueWithoutBoardInput = {
    where: ArticleWhereUniqueInput
    data: XOR<ArticleUpdateWithoutBoardInput, ArticleUncheckedUpdateWithoutBoardInput>
  }

  export type ArticleUpdateManyWithWhereWithoutBoardInput = {
    where: ArticleScalarWhereInput
    data: XOR<ArticleUpdateManyMutationInput, ArticleUncheckedUpdateManyWithoutArticleInput>
  }

  export type BoardManagerUpsertWithWhereUniqueWithoutBoardInput = {
    where: BoardManagerWhereUniqueInput
    update: XOR<BoardManagerUpdateWithoutBoardInput, BoardManagerUncheckedUpdateWithoutBoardInput>
    create: XOR<BoardManagerCreateWithoutBoardInput, BoardManagerUncheckedCreateWithoutBoardInput>
  }

  export type BoardManagerUpdateWithWhereUniqueWithoutBoardInput = {
    where: BoardManagerWhereUniqueInput
    data: XOR<BoardManagerUpdateWithoutBoardInput, BoardManagerUncheckedUpdateWithoutBoardInput>
  }

  export type BoardManagerUpdateManyWithWhereWithoutBoardInput = {
    where: BoardManagerScalarWhereInput
    data: XOR<BoardManagerUpdateManyMutationInput, BoardManagerUncheckedUpdateManyWithoutManagersInput>
  }

  export type BoardCreateWithoutManagersInput = {
    schoolId: string
    name: string
    description: string
    default?: boolean
    noticeId?: BoardCreatenoticeIdInput | Enumerable<number>
    Article?: ArticleCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutManagersInput = {
    id?: number
    schoolId: string
    name: string
    description: string
    default?: boolean
    noticeId?: BoardCreatenoticeIdInput | Enumerable<number>
    Article?: ArticleUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutManagersInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutManagersInput, BoardUncheckedCreateWithoutManagersInput>
  }

  export type UserCreateWithoutBoardOrganizationsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBoardOrganizationsInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBoardOrganizationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBoardOrganizationsInput, UserUncheckedCreateWithoutBoardOrganizationsInput>
  }

  export type BoardUpsertWithoutManagersInput = {
    update: XOR<BoardUpdateWithoutManagersInput, BoardUncheckedUpdateWithoutManagersInput>
    create: XOR<BoardCreateWithoutManagersInput, BoardUncheckedCreateWithoutManagersInput>
  }

  export type BoardUpdateWithoutManagersInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    noticeId?: BoardUpdatenoticeIdInput | Enumerable<number>
    Article?: ArticleUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutManagersInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    noticeId?: BoardUpdatenoticeIdInput | Enumerable<number>
    Article?: ArticleUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type UserUpsertWithoutBoardOrganizationsInput = {
    update: XOR<UserUpdateWithoutBoardOrganizationsInput, UserUncheckedUpdateWithoutBoardOrganizationsInput>
    create: XOR<UserCreateWithoutBoardOrganizationsInput, UserUncheckedCreateWithoutBoardOrganizationsInput>
  }

  export type UserUpdateWithoutBoardOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBoardOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BoardCreateWithoutArticleInput = {
    schoolId: string
    name: string
    description: string
    default?: boolean
    noticeId?: BoardCreatenoticeIdInput | Enumerable<number>
    managers?: BoardManagerCreateNestedManyWithoutBoardInput
  }

  export type BoardUncheckedCreateWithoutArticleInput = {
    id?: number
    schoolId: string
    name: string
    description: string
    default?: boolean
    noticeId?: BoardCreatenoticeIdInput | Enumerable<number>
    managers?: BoardManagerUncheckedCreateNestedManyWithoutBoardInput
  }

  export type BoardCreateOrConnectWithoutArticleInput = {
    where: BoardWhereUniqueInput
    create: XOR<BoardCreateWithoutArticleInput, BoardUncheckedCreateWithoutArticleInput>
  }

  export type UserCreateWithoutArticleInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArticleInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArticleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArticleInput, UserUncheckedCreateWithoutArticleInput>
  }

  export type SchoolCreateWithoutArticleInput = {
    schoolId: string
    org: string
    x: number
    y: number
    atptCode: string
    defaultName: string
    name?: string | null
    type: string
    UserSchool?: UserSchoolCreateNestedManyWithoutSchoolInput
  }

  export type SchoolUncheckedCreateWithoutArticleInput = {
    schoolId: string
    org: string
    x: number
    y: number
    atptCode: string
    defaultName: string
    name?: string | null
    type: string
    UserSchool?: UserSchoolUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type SchoolCreateOrConnectWithoutArticleInput = {
    where: SchoolWhereUniqueInput
    create: XOR<SchoolCreateWithoutArticleInput, SchoolUncheckedCreateWithoutArticleInput>
  }

  export type CommentCreateWithoutArticleInput = {
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutCommentInput
    recomments?: ReCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutArticleInput = {
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    recomments?: ReCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutArticleInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
  }

  export type CommentCreateManyArticleInputEnvelope = {
    data: Enumerable<CommentCreateManyArticleInput>
    skipDuplicates?: boolean
  }

  export type ReCommentCreateWithoutArticleInput = {
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Comment?: CommentCreateNestedOneWithoutRecommentsInput
    User: UserCreateNestedOneWithoutReCommentInput
  }

  export type ReCommentUncheckedCreateWithoutArticleInput = {
    id?: number
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commentId?: number | null
  }

  export type ReCommentCreateOrConnectWithoutArticleInput = {
    where: ReCommentWhereUniqueInput
    create: XOR<ReCommentCreateWithoutArticleInput, ReCommentUncheckedCreateWithoutArticleInput>
  }

  export type ReCommentCreateManyArticleInputEnvelope = {
    data: Enumerable<ReCommentCreateManyArticleInput>
    skipDuplicates?: boolean
  }

  export type BoardUpsertWithoutArticleInput = {
    update: XOR<BoardUpdateWithoutArticleInput, BoardUncheckedUpdateWithoutArticleInput>
    create: XOR<BoardCreateWithoutArticleInput, BoardUncheckedCreateWithoutArticleInput>
  }

  export type BoardUpdateWithoutArticleInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    noticeId?: BoardUpdatenoticeIdInput | Enumerable<number>
    managers?: BoardManagerUpdateManyWithoutBoardNestedInput
  }

  export type BoardUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    noticeId?: BoardUpdatenoticeIdInput | Enumerable<number>
    managers?: BoardManagerUncheckedUpdateManyWithoutBoardNestedInput
  }

  export type UserUpsertWithoutArticleInput = {
    update: XOR<UserUpdateWithoutArticleInput, UserUncheckedUpdateWithoutArticleInput>
    create: XOR<UserCreateWithoutArticleInput, UserUncheckedCreateWithoutArticleInput>
  }

  export type UserUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArticleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SchoolUpsertWithoutArticleInput = {
    update: XOR<SchoolUpdateWithoutArticleInput, SchoolUncheckedUpdateWithoutArticleInput>
    create: XOR<SchoolCreateWithoutArticleInput, SchoolUncheckedCreateWithoutArticleInput>
  }

  export type SchoolUpdateWithoutArticleInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    org?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    atptCode?: StringFieldUpdateOperationsInput | string
    defaultName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    UserSchool?: UserSchoolUpdateManyWithoutSchoolNestedInput
  }

  export type SchoolUncheckedUpdateWithoutArticleInput = {
    schoolId?: StringFieldUpdateOperationsInput | string
    org?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    atptCode?: StringFieldUpdateOperationsInput | string
    defaultName?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    UserSchool?: UserSchoolUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutArticleInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutArticleInput, CommentUncheckedUpdateWithoutArticleInput>
    create: XOR<CommentCreateWithoutArticleInput, CommentUncheckedCreateWithoutArticleInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutArticleInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutArticleInput, CommentUncheckedUpdateWithoutArticleInput>
  }

  export type CommentUpdateManyWithWhereWithoutArticleInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type ReCommentUpsertWithWhereUniqueWithoutArticleInput = {
    where: ReCommentWhereUniqueInput
    update: XOR<ReCommentUpdateWithoutArticleInput, ReCommentUncheckedUpdateWithoutArticleInput>
    create: XOR<ReCommentCreateWithoutArticleInput, ReCommentUncheckedCreateWithoutArticleInput>
  }

  export type ReCommentUpdateWithWhereUniqueWithoutArticleInput = {
    where: ReCommentWhereUniqueInput
    data: XOR<ReCommentUpdateWithoutArticleInput, ReCommentUncheckedUpdateWithoutArticleInput>
  }

  export type ReCommentUpdateManyWithWhereWithoutArticleInput = {
    where: ReCommentScalarWhereInput
    data: XOR<ReCommentUpdateManyMutationInput, ReCommentUncheckedUpdateManyWithoutReCommentInput>
  }

  export type ArticleCreateWithoutCommentInput = {
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    createdAt?: Date | string
    Board: BoardCreateNestedOneWithoutArticleInput
    User: UserCreateNestedOneWithoutArticleInput
    school: SchoolCreateNestedOneWithoutArticleInput
    ReComment?: ReCommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutCommentInput = {
    id?: number
    schoolId: string
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt?: Date | string
    boardId: number
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutCommentInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutCommentInput, ArticleUncheckedCreateWithoutCommentInput>
  }

  export type UserCreateWithoutCommentInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type ReCommentCreateWithoutCommentInput = {
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Article: ArticleCreateNestedOneWithoutReCommentInput
    User: UserCreateNestedOneWithoutReCommentInput
  }

  export type ReCommentUncheckedCreateWithoutCommentInput = {
    id?: number
    articleId: number
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReCommentCreateOrConnectWithoutCommentInput = {
    where: ReCommentWhereUniqueInput
    create: XOR<ReCommentCreateWithoutCommentInput, ReCommentUncheckedCreateWithoutCommentInput>
  }

  export type ReCommentCreateManyCommentInputEnvelope = {
    data: Enumerable<ReCommentCreateManyCommentInput>
    skipDuplicates?: boolean
  }

  export type ArticleUpsertWithoutCommentInput = {
    update: XOR<ArticleUpdateWithoutCommentInput, ArticleUncheckedUpdateWithoutCommentInput>
    create: XOR<ArticleCreateWithoutCommentInput, ArticleUncheckedCreateWithoutCommentInput>
  }

  export type ArticleUpdateWithoutCommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Board?: BoardUpdateOneRequiredWithoutArticleNestedInput
    User?: UserUpdateOneRequiredWithoutArticleNestedInput
    school?: SchoolUpdateOneRequiredWithoutArticleNestedInput
    ReComment?: ReCommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
    ReComment?: ReCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserUpsertWithoutCommentInput = {
    update: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type UserUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReCommentUpsertWithWhereUniqueWithoutCommentInput = {
    where: ReCommentWhereUniqueInput
    update: XOR<ReCommentUpdateWithoutCommentInput, ReCommentUncheckedUpdateWithoutCommentInput>
    create: XOR<ReCommentCreateWithoutCommentInput, ReCommentUncheckedCreateWithoutCommentInput>
  }

  export type ReCommentUpdateWithWhereUniqueWithoutCommentInput = {
    where: ReCommentWhereUniqueInput
    data: XOR<ReCommentUpdateWithoutCommentInput, ReCommentUncheckedUpdateWithoutCommentInput>
  }

  export type ReCommentUpdateManyWithWhereWithoutCommentInput = {
    where: ReCommentScalarWhereInput
    data: XOR<ReCommentUpdateManyMutationInput, ReCommentUncheckedUpdateManyWithoutRecommentsInput>
  }

  export type ArticleCreateWithoutReCommentInput = {
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    createdAt?: Date | string
    Board: BoardCreateNestedOneWithoutArticleInput
    User: UserCreateNestedOneWithoutArticleInput
    school: SchoolCreateNestedOneWithoutArticleInput
    Comment?: CommentCreateNestedManyWithoutArticleInput
  }

  export type ArticleUncheckedCreateWithoutReCommentInput = {
    id?: number
    schoolId: string
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt?: Date | string
    boardId: number
    Comment?: CommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type ArticleCreateOrConnectWithoutReCommentInput = {
    where: ArticleWhereUniqueInput
    create: XOR<ArticleCreateWithoutReCommentInput, ArticleUncheckedCreateWithoutReCommentInput>
  }

  export type CommentCreateWithoutRecommentsInput = {
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Article: ArticleCreateNestedOneWithoutCommentInput
    User: UserCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutRecommentsInput = {
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    articleId: number
  }

  export type CommentCreateOrConnectWithoutRecommentsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRecommentsInput, CommentUncheckedCreateWithoutRecommentsInput>
  }

  export type UserCreateWithoutReCommentInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    Like?: LikeCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReCommentInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    Like?: LikeUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReCommentInput, UserUncheckedCreateWithoutReCommentInput>
  }

  export type ArticleUpsertWithoutReCommentInput = {
    update: XOR<ArticleUpdateWithoutReCommentInput, ArticleUncheckedUpdateWithoutReCommentInput>
    create: XOR<ArticleCreateWithoutReCommentInput, ArticleUncheckedCreateWithoutReCommentInput>
  }

  export type ArticleUpdateWithoutReCommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Board?: BoardUpdateOneRequiredWithoutArticleNestedInput
    User?: UserUpdateOneRequiredWithoutArticleNestedInput
    school?: SchoolUpdateOneRequiredWithoutArticleNestedInput
    Comment?: CommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutReCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
    Comment?: CommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type CommentUpsertWithoutRecommentsInput = {
    update: XOR<CommentUpdateWithoutRecommentsInput, CommentUncheckedUpdateWithoutRecommentsInput>
    create: XOR<CommentCreateWithoutRecommentsInput, CommentUncheckedCreateWithoutRecommentsInput>
  }

  export type CommentUpdateWithoutRecommentsInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Article?: ArticleUpdateOneRequiredWithoutCommentNestedInput
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutRecommentsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutReCommentInput = {
    update: XOR<UserUpdateWithoutReCommentInput, UserUncheckedUpdateWithoutReCommentInput>
    create: XOR<UserCreateWithoutReCommentInput, UserUncheckedCreateWithoutReCommentInput>
  }

  export type UserUpdateWithoutReCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    Like?: LikeUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    Like?: LikeUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLikeInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementCreateNestedOneWithoutUserInput
    Article?: ArticleCreateNestedManyWithoutUserInput
    Asked?: AskedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Image?: ImageCreateNestedManyWithoutUserInput
    ReComment?: ReCommentCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLikeInput = {
    id?: string
    email?: string | null
    password?: string | null
    name: string
    profile?: string | null
    isVerified?: boolean
    phone?: string | null
    createdAt?: Date | string
    provider: UserLoginProviderType
    userSchoolId?: string | null
    Agreement?: AgreementUncheckedCreateNestedOneWithoutUserInput
    Article?: ArticleUncheckedCreateNestedManyWithoutUserInput
    Asked?: AskedUncheckedCreateNestedManyWithoutQuestionUserInput
    AskedUser?: AskedUserUncheckedCreateNestedOneWithoutUserInput
    BoardOrganizations?: BoardManagerUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Image?: ImageUncheckedCreateNestedManyWithoutUserInput
    ReComment?: ReCommentUncheckedCreateNestedManyWithoutUserInput
    SocialLogin?: SocialLoginUncheckedCreateNestedOneWithoutUserInput
    UserSchool?: UserSchoolUncheckedCreateNestedOneWithoutUserInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLikeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikeInput, UserUncheckedCreateWithoutLikeInput>
  }

  export type UserUpsertWithoutLikeInput = {
    update: XOR<UserUpdateWithoutLikeInput, UserUncheckedUpdateWithoutLikeInput>
    create: XOR<UserCreateWithoutLikeInput, UserUncheckedCreateWithoutLikeInput>
  }

  export type UserUpdateWithoutLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUpdateOneWithoutUserNestedInput
    Article?: ArticleUpdateManyWithoutUserNestedInput
    Asked?: AskedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Image?: ImageUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    profile?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: EnumUserLoginProviderTypeFieldUpdateOperationsInput | UserLoginProviderType
    userSchoolId?: NullableStringFieldUpdateOperationsInput | string | null
    Agreement?: AgreementUncheckedUpdateOneWithoutUserNestedInput
    Article?: ArticleUncheckedUpdateManyWithoutUserNestedInput
    Asked?: AskedUncheckedUpdateManyWithoutQuestionUserNestedInput
    AskedUser?: AskedUserUncheckedUpdateOneWithoutUserNestedInput
    BoardOrganizations?: BoardManagerUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Image?: ImageUncheckedUpdateManyWithoutUserNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutUserNestedInput
    SocialLogin?: SocialLoginUncheckedUpdateOneWithoutUserNestedInput
    UserSchool?: UserSchoolUncheckedUpdateOneWithoutUserNestedInput
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ArticleCreateManyUserInput = {
    id?: number
    schoolId: string
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    createdAt?: Date | string
    boardId: number
  }

  export type AskedCreateManyQuestionUserInput = {
    id?: string
    askedUserId: string
    process?: Process
    question: string
    answer?: string | null
    createdAt?: Date | string
    answerTimeAt?: Date | string | null
    isAnonymous: boolean
  }

  export type BoardManagerCreateManyUserInput = {
    id?: string
    boardId: number
    name: string
  }

  export type CommentCreateManyUserInput = {
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
    articleId: number
  }

  export type ImageCreateManyUserInput = {
    id?: string
    key: string
    createdAt?: Date | string
  }

  export type LikeCreateManyUserInput = {
    id?: string
    targetId: number
    targetType: LikeTargetType
    likeType: LikeType
  }

  export type ReCommentCreateManyUserInput = {
    id?: number
    articleId: number
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commentId?: number | null
  }

  export type UserSchoolVerifyCreateManyUserInput = {
    id?: string
    imageId: string
    schoolId: string
    grade: string
    class: string
    message?: string | null
    process?: Process
    createdAt?: Date | string
    schoolName: string
    userName: string
    dept: string
  }

  export type ArticleUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Board?: BoardUpdateOneRequiredWithoutArticleNestedInput
    school?: SchoolUpdateOneRequiredWithoutArticleNestedInput
    Comment?: CommentUpdateManyWithoutArticleNestedInput
    ReComment?: ReCommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
    Comment?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateManyWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
  }

  export type AskedUpdateWithoutQuestionUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    process?: EnumProcessFieldUpdateOperationsInput | Process
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answerTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    AskedUser?: AskedUserUpdateOneRequiredWithoutAskedNestedInput
  }

  export type AskedUncheckedUpdateWithoutQuestionUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    askedUserId?: StringFieldUpdateOperationsInput | string
    process?: EnumProcessFieldUpdateOperationsInput | Process
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answerTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AskedUncheckedUpdateManyWithoutAskedInput = {
    id?: StringFieldUpdateOperationsInput | string
    askedUserId?: StringFieldUpdateOperationsInput | string
    process?: EnumProcessFieldUpdateOperationsInput | Process
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answerTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BoardManagerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    board?: BoardUpdateOneRequiredWithoutManagersNestedInput
  }

  export type BoardManagerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BoardManagerUncheckedUpdateManyWithoutBoardOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    boardId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Article?: ArticleUpdateOneRequiredWithoutCommentNestedInput
    recomments?: ReCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    recomments?: ReCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
  }

  export type ImageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSchoolVerify?: UserSchoolVerifyUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UserSchoolVerify?: UserSchoolVerifyUncheckedUpdateManyWithoutImageNestedInput
  }

  export type ImageUncheckedUpdateManyWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LikeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumLikeTargetTypeFieldUpdateOperationsInput | LikeTargetType
    likeType?: EnumLikeTypeFieldUpdateOperationsInput | LikeType
  }

  export type LikeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumLikeTargetTypeFieldUpdateOperationsInput | LikeTargetType
    likeType?: EnumLikeTypeFieldUpdateOperationsInput | LikeType
  }

  export type LikeUncheckedUpdateManyWithoutLikeInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetId?: IntFieldUpdateOperationsInput | number
    targetType?: EnumLikeTargetTypeFieldUpdateOperationsInput | LikeTargetType
    likeType?: EnumLikeTypeFieldUpdateOperationsInput | LikeType
  }

  export type ReCommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Article?: ArticleUpdateOneRequiredWithoutReCommentNestedInput
    Comment?: CommentUpdateOneWithoutRecommentsNestedInput
  }

  export type ReCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReCommentUncheckedUpdateManyWithoutReCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserSchoolVerifyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    process?: EnumProcessFieldUpdateOperationsInput | Process
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
    image?: ImageUpdateOneRequiredWithoutUserSchoolVerifyNestedInput
  }

  export type UserSchoolVerifyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    process?: EnumProcessFieldUpdateOperationsInput | Process
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
  }

  export type UserSchoolVerifyUncheckedUpdateManyWithoutUserSchoolVerifyInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    process?: EnumProcessFieldUpdateOperationsInput | Process
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
  }

  export type UserSchoolCreateManySchoolInput = {
    userId: string
    dept: string
    grade: string
    class: string
  }

  export type ArticleCreateManySchoolInput = {
    id?: number
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt?: Date | string
    boardId: number
  }

  export type UserSchoolUpdateWithoutSchoolInput = {
    dept?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserSchoolNestedInput
  }

  export type UserSchoolUncheckedUpdateWithoutSchoolInput = {
    userId?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
  }

  export type UserSchoolUncheckedUpdateManyWithoutUserSchoolInput = {
    userId?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleUpdateWithoutSchoolInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Board?: BoardUpdateOneRequiredWithoutArticleNestedInput
    User?: UserUpdateOneRequiredWithoutArticleNestedInput
    Comment?: CommentUpdateManyWithoutArticleNestedInput
    ReComment?: ReCommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boardId?: IntFieldUpdateOperationsInput | number
    Comment?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserSchoolVerifyCreateManyImageInput = {
    id?: string
    userId: string
    schoolId: string
    grade: string
    class: string
    message?: string | null
    process?: Process
    createdAt?: Date | string
    schoolName: string
    userName: string
    dept: string
  }

  export type UserSchoolVerifyUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    process?: EnumProcessFieldUpdateOperationsInput | Process
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutUserSchoolVerifyNestedInput
  }

  export type UserSchoolVerifyUncheckedUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    schoolId?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    process?: EnumProcessFieldUpdateOperationsInput | Process
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schoolName?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    dept?: StringFieldUpdateOperationsInput | string
  }

  export type AskedCreateManyAskedUserInput = {
    id?: string
    userId: string
    process?: Process
    question: string
    answer?: string | null
    createdAt?: Date | string
    answerTimeAt?: Date | string | null
    isAnonymous: boolean
  }

  export type AskedUpdateWithoutAskedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    process?: EnumProcessFieldUpdateOperationsInput | Process
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answerTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    QuestionUser?: UserUpdateOneRequiredWithoutAskedNestedInput
  }

  export type AskedUncheckedUpdateWithoutAskedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    process?: EnumProcessFieldUpdateOperationsInput | Process
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answerTimeAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ArticleCreateManyBoardInput = {
    id?: number
    schoolId: string
    title: string
    content: string
    images?: ArticleCreateimagesInput | Enumerable<string>
    isAnonymous: boolean
    userId: string
    createdAt?: Date | string
  }

  export type BoardManagerCreateManyBoardInput = {
    id?: string
    name: string
    userId: string
  }

  export type ArticleUpdateWithoutBoardInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutArticleNestedInput
    school?: SchoolUpdateOneRequiredWithoutArticleNestedInput
    Comment?: CommentUpdateManyWithoutArticleNestedInput
    ReComment?: ReCommentUpdateManyWithoutArticleNestedInput
  }

  export type ArticleUncheckedUpdateWithoutBoardInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    images?: ArticleUpdateimagesInput | Enumerable<string>
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUncheckedUpdateManyWithoutArticleNestedInput
    ReComment?: ReCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type BoardManagerUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutBoardOrganizationsNestedInput
  }

  export type BoardManagerUncheckedUpdateWithoutBoardInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type BoardManagerUncheckedUpdateManyWithoutManagersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyArticleInput = {
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: number
  }

  export type ReCommentCreateManyArticleInput = {
    id?: number
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    commentId?: number | null
  }

  export type CommentUpdateWithoutArticleInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    recomments?: ReCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutArticleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    recomments?: ReCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type ReCommentUpdateWithoutArticleInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Comment?: CommentUpdateOneWithoutRecommentsNestedInput
    User?: UserUpdateOneRequiredWithoutReCommentNestedInput
  }

  export type ReCommentUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    commentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReCommentCreateManyCommentInput = {
    id?: number
    articleId: number
    userId: string
    content: string
    isAnonymous: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReCommentUpdateWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Article?: ArticleUpdateOneRequiredWithoutReCommentNestedInput
    User?: UserUpdateOneRequiredWithoutReCommentNestedInput
  }

  export type ReCommentUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReCommentUncheckedUpdateManyWithoutRecommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}